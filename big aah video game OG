import pygame
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flight Simulator</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <script>
    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a simple airplane (a box for the body and wings)
    const airplane = new THREE.Group();

    const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 0.5);
    const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    airplane.add(body);

    const wingGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.5);
    const wingMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const wing = new THREE.Mesh(wingGeometry, wingMaterial);
    wing.position.y = -0.25;
    airplane.add(wing);

    scene.add(airplane);

    // Add a ground plane
    const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
    const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = Math.PI / 2;
    scene.add(ground);

    // Lighting
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5);
    scene.add(light);

    // Camera position
    camera.position.set(0, 2, 5);
    camera.lookAt(airplane.position);

    // Movement variables
    let pitch = 0; // Up/Down
    let roll = 0;  // Left/Right
    let speed = 0.1;

    // Handle keyboard input
    document.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'ArrowUp': pitch = 0.02; break;
        case 'ArrowDown': pitch = -0.02; break;
        case 'ArrowLeft': roll = 0.02; break;
        case 'ArrowRight': roll = -0.02; break;
        case 'KeyW': speed += 0.01; break; // Increase speed
        case 'KeyS': speed -= 0.01; break; // Decrease speed
      }
    });

    document.addEventListener('keyup', (event) => {
      if (['ArrowUp', 'ArrowDown'].includes(event.code)) pitch = 0;
      if (['ArrowLeft', 'ArrowRight'].includes(event.code)) roll = 0;
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Apply movement
      airplane.rotation.x += pitch;
      airplane.rotation.z += roll;

      // Move forward in the direction the airplane is facing
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(airplane.quaternion);
      airplane.position.addScaledVector(direction, speed);

      // Update camera to follow the airplane
      camera.position.lerp(
        new THREE.Vector3(
          airplane.position.x,
          airplane.position.y + 2,
          airplane.position.z + 5
        ),
        0.1
      );
      camera.lookAt(airplane.position);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flight Simulator</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <script>
    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Skybox
    const loader = new THREE.CubeTextureLoader();
    const skyboxTexture = loader.load([
      'https://threejs.org/examples/textures/cube/skybox/px.jpg', // Right
      'https://threejs.org/examples/textures/cube/skybox/nx.jpg', // Left
      'https://threejs.org/examples/textures/cube/skybox/py.jpg', // Top
      'https://threejs.org/examples/textures/cube/skybox/ny.jpg', // Bottom
      'https://threejs.org/examples/textures/cube/skybox/pz.jpg', // Front
      'https://threejs.org/examples/textures/cube/skybox/nz.jpg'  // Back
    ]);
    scene.background = skyboxTexture;

    // Create a simple airplane (a box for the body and wings)
    const airplane = new THREE.Group();

    const bodyGeometry = new THREE.BoxGeometry(1, 0.5, 0.5);
    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    airplane.add(body);

    const wingGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.5);
    const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
    const wing = new THREE.Mesh(wingGeometry, wingMaterial);
    wing.position.y = -0.25;
    airplane.add(wing);

    scene.add(airplane);

    // Add a textured ground plane
    const groundTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
    groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
    groundTexture.repeat.set(100, 100);

    const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
    const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft light
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    // Camera position
    camera.position.set(0, 2, 5);
    camera.lookAt(airplane.position);

    // Movement variables
    let pitch = 0; // Up/Down
    let roll = 0;  // Left/Right
    let speed = 0.1;

    // Handle keyboard input
    document.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'ArrowUp': pitch = 0.02; break;
        case 'ArrowDown': pitch = -0.02; break;
        case 'ArrowLeft': roll = 0.02; break;
        case 'ArrowRight': roll = -0.02; break;
        case 'KeyW': speed += 0.01; break; // Increase speed
        case 'KeyS': speed -= 0.01; break; // Decrease speed
      }
    });

    document.addEventListener('keyup', (event) => {
      if (['ArrowUp', 'ArrowDown'].includes(event.code)) pitch = 0;
      if (['ArrowLeft', 'ArrowRight'].includes(event.code)) roll = 0;
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Apply movement
      airplane.rotation.x += pitch;
      airplane.rotation.z += roll;

      // Move forward in the direction the airplane is facing
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(airplane.quaternion);
      airplane.position.addScaledVector(direction, speed);

      // Update camera to follow the airplane
      camera.position.lerp(
        new THREE.Vector3(
          airplane.position.x,
          airplane.position.y + 2,
          airplane.position.z + 5
        ),
        0.1
      );
      camera.lookAt(airplane.position);

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
// Create a more realistic airplane model
const airplane = new THREE.Group();

// Fuselage (cylinder for the body)
const fuselageGeometry = new THREE.CylinderGeometry(0.25, 0.25, 2, 32);
const fuselageMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
fuselage.rotation.z = Math.PI / 2; // Rotate to align with the x-axis
airplane.add(fuselage);

// Wings (rectangular planes)
const wingGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.5);
const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
leftWing.position.set(-0.75, 0, 0.5); // Position left wing
airplane.add(leftWing);

const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
rightWing.position.set(-0.75, 0, -0.5); // Position right wing
airplane.add(rightWing);

// Tail (vertical and horizontal stabilizers)
const tailFinGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.05);
const tailFinMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const tailFin = new THREE.Mesh(tailFinGeometry, tailFinMaterial);
tailFin.position.set(1, 0.25, 0); // Position vertical stabilizer
airplane.add(tailFin);

const tailWingGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.2);
const tailWingMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
const tailWing = new THREE.Mesh(tailWingGeometry, tailWingMaterial);
tailWing.position.set(1, -0.1, 0); // Position horizontal stabilizer
airplane.add(tailWing);

// Propeller (rotating blade at the front)
const propellerGeometry = new THREE.BoxGeometry(0.05, 0.5, 0.05);
const propellerMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
propeller.position.set(-1.1, 0, 0); // Position at the front of the fuselage
airplane.add(propeller);

// Add rotation animation for the propeller
function animatePropeller() {
  propeller.rotation.z += 0.2; // Rotate the propeller
}

// Add the airplane to the scene
scene.add(airplane);

// Update the animation loop to include the propeller animation
function animate() {
  requestAnimationFrame(animate);

  // Apply movement
  airplane.rotation.x += pitch;
  airplane.rotation.z += roll;

  // Move forward in the direction the airplane is facing
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(airplane.quaternion);
  airplane.position.addScaledVector(direction, speed);

  // Rotate the propeller
  animatePropeller();

  // Update camera to follow the airplane
  camera.position.lerp(
    new THREE.Vector3(
      airplane.position.x,
      airplane.position.y + 2,
      airplane.position.z + 5
    ),
    0.1
  );
  camera.lookAt(airplane.position);

  renderer.render(scene, camera);
}

animate();
// Wings (tapered with winglets)
const wingShape = new THREE.Shape();
wingShape.moveTo(0, 0);
wingShape.lineTo(1.5, 0.1); // Tapered edge
wingShape.lineTo(1.5, -0.1);
wingShape.lineTo(0, -0.1);
wingShape.lineTo(0, 0);

const extrudeSettings = {
  steps: 2,
  depth: 0.5, // Wing thickness
  bevelEnabled: false,
};

const wingGeometry = new THREE.ExtrudeGeometry(wingShape, extrudeSettings);
const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
leftWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
leftWing.position.set(-0.75, 0, 0.5); // Position left wing
airplane.add(leftWing);

const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
rightWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
rightWing.position.set(-0.75, 0, -0.5); // Position right wing
airplane.add(rightWing);

// Winglets (small vertical extensions at the tips)
const wingletGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.05);
const wingletMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
const leftWinglet = new THREE.Mesh(wingletGeometry, wingletMaterial);
leftWinglet.position.set(-0.75, 0.15, 0.75); // Position at the tip of the left wing
airplane.add(leftWinglet);

const rightWinglet = new THREE.Mesh(wingletGeometry, wingletMaterial);
rightWinglet.position.set(-0.75, 0.15, -0.75); // Position at the tip of the right wing
airplane.add(rightWinglet);
// Vertical Stabilizer (Tail Fin)
const tailFinShape = new THREE.Shape();
tailFinShape.moveTo(0, 0);
tailFinShape.lineTo(0.2, 0.5); // Tapered top
tailFinShape.lineTo(0.2, -0.1);
tailFinShape.lineTo(0, -0.1);
tailFinShape.lineTo(0, 0);

const tailFinExtrudeSettings = {
  steps: 2,
  depth: 0.05, // Thickness of the tail fin
  bevelEnabled: false,
};

const tailFinGeometry = new THREE.ExtrudeGeometry(tailFinShape, tailFinExtrudeSettings);
const tailFinMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const tailFin = new THREE.Mesh(tailFinGeometry, tailFinMaterial);
tailFin.position.set(1, 0.25, 0); // Position vertical stabilizer
airplane.add(tailFin);

// Horizontal Stabilizers (Rear Wings)
const rearWingShape = new THREE.Shape();
rearWingShape.moveTo(0, 0);
rearWingShape.lineTo(0.5, 0.1); // Tapered edge
rearWingShape.lineTo(0.5, -0.1);
rearWingShape.lineTo(0, -0.1);
rearWingShape.lineTo(0, 0);

const rearWingExtrudeSettings = {
  steps: 2,
  depth: 0.2, // Thickness of the rear wings
  bevelEnabled: false,
};

const rearWingGeometry = new THREE.ExtrudeGeometry(rearWingShape, rearWingExtrudeSettings);
const rearWingMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
const leftRearWing = new THREE.Mesh(rearWingGeometry, rearWingMaterial);
leftRearWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
leftRearWing.position.set(1, -0.1, 0.3); // Position left rear wing
airplane.add(leftRearWing);

const rightRearWing = new THREE.Mesh(rearWingGeometry, rearWingMaterial);
rightRearWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
rightRearWing.position.set(1, -0.1, -0.3); // Position right rear wing
airplane.add(rightRearWing);
// Create doors
const doorGeometry = new THREE.BoxGeometry(0.05, 0.5, 0.8); // Thin rectangular door
const doorMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
const leftDoor = new THREE.Mesh(doorGeometry, doorMaterial);
const rightDoor = new THREE.Mesh(doorGeometry, doorMaterial);

// Position doors
leftDoor.position.set(-0.5, 0, 0.4); // Left side of the fuselage
rightDoor.position.set(-0.5, 0, -0.4); // Right side of the fuselage
airplane.add(leftDoor);
airplane.add(rightDoor);

// Door animation variables
let leftDoorOpen = false;
let rightDoorOpen = false;

// Function to animate doors
function animateDoors() {
  if (leftDoorOpen) {
    leftDoor.rotation.y = Math.min(leftDoor.rotation.y + 0.05, Math.PI / 2); // Open left door
  } else {
    leftDoor.rotation.y = Math.max(leftDoor.rotation.y - 0.05, 0); // Close left door
  }

  if (rightDoorOpen) {
    rightDoor.rotation.y = Math.max(rightDoor.rotation.y - 0.05, -Math.PI / 2); // Open right door
  } else {
    rightDoor.rotation.y = Math.min(rightDoor.rotation.y + 0.05, 0); // Close right door
  }
}

// Handle keyboard input for doors
document.addEventListener('keydown', (event) => {
  switch (event.code) {
    case 'KeyO': // Open doors
      leftDoorOpen = true;
      rightDoorOpen = true;
      break;
    case 'KeyC': // Close doors
      leftDoorOpen = false;
      rightDoorOpen = false;
      break;
  }
});

// Update the animation loop to include door animations
function animate() {
  requestAnimationFrame(animate);

  // Apply movement
  airplane.rotation.x += pitch;
  airplane.rotation.z += roll;

  // Move forward in the direction the airplane is facing
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(airplane.quaternion);
  airplane.position.addScaledVector(direction, speed);

  // Animate doors
  animateDoors();

  // Update camera to follow the airplane
  camera.position.lerp(
    new THREE.Vector3(
      airplane.position.x,
      airplane.position.y + 2,
      airplane.position.z + 5
    ),
    0.1
  );
  camera.lookAt(airplane.position);

  renderer.render(scene, camera);
}

animate();
// Landing Gear Group
const landingGear = new THREE.Group();

// Main Landing Gear (Wheels under the wings)
const wheelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 32); // Wheel shape
const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
leftWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
leftWheel.position.set(-0.75, -0.3, 0.6); // Position under the left wing
landingGear.add(leftWheel);

const rightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
rightWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
rightWheel.position.set(-0.75, -0.3, -0.6); // Position under the right wing
landingGear.add(rightWheel);

// Nose Gear (Wheel under the front fuselage)
const noseWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
noseWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
noseWheel.scale.set(0.8, 0.8, 0.8); // Slightly smaller wheel
noseWheel.position.set(-1.2, -0.3, 0); // Position under the nose
landingGear.add(noseWheel);

// Struts (Cylinders connecting wheels to the airplane)
const strutGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 16); // Thin cylinder
const strutMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });

const leftStrut = new THREE.Mesh(strutGeometry, strutMaterial);
leftStrut.position.set(-0.75, -0.15, 0.6); // Connect left wheel to fuselage
leftStrut.rotation.x = Math.PI / 4; // Slight angle
landingGear.add(leftStrut);

const rightStrut = new THREE.Mesh(strutGeometry, strutMaterial);
rightStrut.position.set(-0.75, -0.15, -0.6); // Connect right wheel to fuselage
rightStrut.rotation.x = -Math.PI / 4; // Slight angle
landingGear.add(rightStrut);

const noseStrut = new THREE.Mesh(strutGeometry, strutMaterial);
noseStrut.position.set(-1.2, -0.15, 0); // Connect nose wheel to fuselage
noseStrut.rotation.x = Math.PI / 2; // Vertical strut
landingGear.add(noseStrut);

// Add landing gear to the airplane
airplane.add(landingGear);
// Landing Gear Group
const landingGear = new THREE.Group();

// Main Landing Gear (Wheels under the wings)
const wheelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 32); // Wheel shape
const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
leftWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
leftWheel.position.set(-0.75, -0.3, 0.6); // Position under the left wing
landingGear.add(leftWheel);

const rightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
rightWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
rightWheel.position.set(-0.75, -0.3, -0.6); // Position under the right wing
landingGear.add(rightWheel);

// Nose Gear (Wheel under the front fuselage)
const noseWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
noseWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
noseWheel.scale.set(0.8, 0.8, 0.8); // Slightly smaller wheel
noseWheel.position.set(-1.2, -0.3, 0); // Position under the nose
landingGear.add(noseWheel);

// Struts (Cylinders connecting wheels to the airplane)
const strutGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 16); // Thin cylinder
const strutMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });

const leftStrut = new THREE.Mesh(strutGeometry, strutMaterial);
leftStrut.position.set(-0.75, -0.15, 0.6); // Connect left wheel to fuselage
leftStrut.rotation.x = Math.PI / 4; // Slight angle
landingGear.add(leftStrut);

const rightStrut = new THREE.Mesh(strutGeometry, strutMaterial);
rightStrut.position.set(-0.75, -0.15, -0.6); // Connect right wheel to fuselage
rightStrut.rotation.x = -Math.PI / 4; // Slight angle
landingGear.add(rightStrut);

const noseStrut = new THREE.Mesh(strutGeometry, strutMaterial);
noseStrut.position.set(-1.2, -0.15, 0); // Connect nose wheel to fuselage
noseStrut.rotation.x = Math.PI / 2; // Vertical strut
landingGear.add(noseStrut);

// Add landing gear to the airplane
airplane.add(landingGear);

// Landing gear animation variables
let gearDeployed = true; // Start with gear deployed
let gearAnimationProgress = 0; // Progress of the animation (0 to 1)

// Function to animate landing gear
function animateLandingGear() {
  if (gearDeployed && gearAnimationProgress < 1) {
    gearAnimationProgress += 0.02; // Move gear down
  } else if (!gearDeployed && gearAnimationProgress > 0) {
    gearAnimationProgress -= 0.02; // Move gear up
  }

  // Update positions based on animation progress
  const gearOffset = THREE.MathUtils.lerp(-0.3, 0.3, gearAnimationProgress); // Interpolate between retracted and deployed positions
  leftWheel.position.y = gearOffset;
  rightWheel.position.y = gearOffset;
  noseWheel.position.y = THREE.MathUtils.lerp(-0.3, 0, gearAnimationProgress); // Nose gear moves differently
}

// Handle keyboard input for landing gear
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyG') {
    gearDeployed = !gearDeployed; // Toggle gear state
  }
});

// Update the animation loop to include landing gear animation
function animate() {
  requestAnimationFrame(animate);

  // Apply movement
  airplane.rotation.x += pitch;
  airplane.rotation.z += roll;

  // Move forward in the direction the airplane is facing
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(airplane.quaternion);
  airplane.position.addScaledVector(direction, speed);

  // Animate landing gear
  animateLandingGear();

  // Update camera to follow the airplane
  camera.position.lerp(
    new THREE.Vector3(
      airplane.position.x,
      airplane.position.y + 2,
      airplane.position.z + 5
    ),
    0.1
  );
  camera.lookAt(airplane.position);

  renderer.render(scene, camera);
}

animate();
// Smooth Airplane Geometry
const airplane = new THREE.Group();

// Fuselage (cylinder for the body)
const fuselageGeometry = new THREE.CylinderGeometry(0.25, 0.25, 2, 32); // Smooth cylinder
const fuselageMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.3, roughness: 0.6 });
const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
fuselage.rotation.z = Math.PI / 2; // Rotate to align with the x-axis
airplane.add(fuselage);

// Wings (tapered with smooth edges)
const wingShape = new THREE.Shape();
wingShape.moveTo(0, 0);
wingShape.lineTo(1.5, 0.1); // Tapered edge
wingShape.lineTo(1.5, -0.1);
wingShape.lineTo(0, -0.1);
wingShape.lineTo(0, 0);

const extrudeSettings = { steps: 2, depth: 0.5, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02 };
const wingGeometry = new THREE.ExtrudeGeometry(wingShape, extrudeSettings);
const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, metalness: 0.2, roughness: 0.7 });
const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
leftWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
leftWing.position.set(-0.75, 0, 0.5); // Position left wing
airplane.add(leftWing);

const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
rightWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
rightWing.position.set(-0.75, 0, -0.5); // Position right wing
airplane.add(rightWing);

// Propeller (rotating blade with blur effect)
const propellerGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 16);
const propellerMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
propeller.position.set(-1.1, 0, 0); // Position at the front of the fuselage
propeller.rotation.x = Math.PI / 2; // Align with the x-axis
airplane.add(propeller);

// Add rotation animation for the propeller
function animatePropeller() {
  propeller.rotation.z += 0.5; // Rotate the propeller
}

// Lighting for Realism
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft ambient light
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

const spotLight = new THREE.SpotLight(0xffffff, 0.8);
spotLight.position.set(0, 5, 5);
spotLight.castShadow = true;
scene.add(spotLight);

// Ground with Texture
const groundTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
groundTexture.repeat.set(100, 100);

const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture });
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

// Skybox for Environment
const skyboxLoader = new THREE.CubeTextureLoader();
const skybox = skyboxLoader.load([
  'https://threejs.org/examples/textures/cube/skybox/px.jpg', // Right
  'https://threejs.org/examples/textures/cube/skybox/nx.jpg', // Left
  'https://threejs.org/examples/textures/cube/skybox/py.jpg', // Top
  'https://threejs.org/examples/textures/cube/skybox/ny.jpg', // Bottom
  'https://threejs.org/examples/textures/cube/skybox/pz.jpg', // Front
  'https://threejs.org/examples/textures/cube/skybox/nz.jpg'  // Back
]);
scene.background = skybox;

// Smooth Animation Loop
function animate() {
  requestAnimationFrame(animate);

  // Apply movement
  airplane.rotation.x += pitch;
  airplane.rotation.z += roll;

  // Move forward in the direction the airplane is facing
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(airplane.quaternion);
  airplane.position.addScaledVector(direction, speed);

  // Animate propeller
  animatePropeller();

  // Update camera to follow the airplane
  camera.position.lerp(
    new THREE.Vector3(
      airplane.position.x,
      airplane.position.y + 2,
      airplane.position.z + 5
    ),
    0.1
  );
  camera.lookAt(airplane.position);

  renderer.render(scene, camera);
}

animate();
<!-- Bottom Bar -->
<div id="bottom-bar">
  <button id="nav-btn">Nav</button>
  <button id="fuel-btn">Fuel</button>
  <button id="light-btn">Light Control</button>
  <button id="settings-btn">Settings</button>
  <button id="chat-btn">Chat</button>
  <button id="multiplayer-btn">Multiplayer</button>
  <button id="pause-btn">Pause</button>
  <button id="unpause-btn">Unpause</button>
  <button id="graphics-btn">Graphics</button>
  <button id="sleep-btn">Sleep Indicator</button>
  <button id="camera-btn">Camera</button>
</div>
/* Bottom Bar Styling */
#bottom-bar {
  position: fixed;
  bottom: 0;
  width: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding: 10px 0;
  z-index: 1000;
}

#bottom-bar button {
  background-color: #333;
  color: white;
  border: none;
  padding: 10px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s;
}

#bottom-bar button:hover {
  background-color: #555;
}
// Add event listeners for the buttons
document.getElementById('nav-btn').addEventListener('click', () => {
  alert('Navigation menu clicked!');
});

document.getElementById('fuel-btn').addEventListener('click', () => {
  alert('Fuel status clicked!');
});

document.getElementById('light-btn').addEventListener('click', () => {
  alert('Light control clicked!');
});

document.getElementById('settings-btn').addEventListener('click', () => {
  alert('Settings menu clicked!');
});

document.getElementById('chat-btn').addEventListener('click', () => {
  alert('Chat clicked!');
});

document.getElementById('multiplayer-btn').addEventListener('click', () => {
  alert('Multiplayer menu clicked!');
});

document.getElementById('pause-btn').addEventListener('click', () => {
  alert('Game paused!');
});

document.getElementById('unpause-btn').addEventListener('click', () => {
  alert('Game unpaused!');
});

document.getElementById('graphics-btn').addEventListener('click', () => {
  alert('Graphics settings clicked!');
});

document.getElementById('sleep-btn').addEventListener('click', () => {
  alert('Sleep indicator clicked!');
});

document.getElementById('camera-btn').addEventListener('click', () => {
  alert('Camera settings clicked!');
});

<!-- Navigation Sidebar -->
<div id="nav-sidebar" class="hidden">
  <h3>Navigation Tool</h3>
  <button id="atc-btn">ATC</button>
  <button id="teleport-btn">Teleport to Nearest Airport</button>
  <button id="flight-path-btn">Flight Path</button>
  <button id="zoom-in-btn">Zoom In</button>
  <button id="zoom-out-btn">Zoom Out</button>
  <button id="minimize-btn">Minimize</button>
  <button id="adjust-btn">Adjust/Lock in Place</button>
  <button id="recenter-btn">Recenter</button>
  <button id="where-am-i-btn">Where Am I?</button>
</div>
/* Navigation Sidebar Styling */
#nav-sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 250px;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.9);
  color: white;
  padding: 20px;
  box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
  overflow-y: auto;
  transform: translateX(-100%);
  transition: transform 0.3s ease-in-out;
  z-index: 1001;
}

#nav-sidebar h3 {
  margin-top: 0;
  font-size: 20px;
  text-align: center;
}

#nav-sidebar button {
  display: block;
  width: 100%;
  margin: 10px 0;
  padding: 10px;
  background-color: #333;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s;
}

#nav-sidebar button:hover {
  background-color: #555;
}

/* Hidden Sidebar */
.hidden {
  transform: translateX(-100%);
}

/* Visible Sidebar */
.visible {
  transform: translateX(0);
}
// Toggle Navigation Sidebar
const navSidebar = document.getElementById('nav-sidebar');
document.getElementById('nav-btn').addEventListener('click', () => {
  navSidebar.classList.toggle('visible');
  navSidebar.classList.toggle('hidden');
});

// Add functionality for each button
document.getElementById('atc-btn').addEventListener('click', () => {
  alert('ATC toggled!');
});

document.getElementById('teleport-btn').addEventListener('click', () => {
  alert('Teleporting to the nearest airport...');
});

document.getElementById('flight-path-btn').addEventListener('click', () => {
  alert('Flight Path toggled!');
});

document.getElementById('zoom-in-btn').addEventListener('click', () => {
  alert('Zooming in...');
});

document.getElementById('zoom-out-btn').addEventListener('click', () => {
  alert('Zooming out...');
});

document.getElementById('minimize-btn').addEventListener('click', () => {
  navSidebar.classList.add('hidden');
  navSidebar.classList.remove('visible');
});

document.getElementById('adjust-btn').addEventListener('click', () => {
  alert('Adjusting or locking the navigation tool in place...');
});

document.getElementById('recenter-btn').addEventListener('click', () => {
  alert('Recentered!');
});

document.getElementById('where-am-i-btn').addEventListener('click', () => {
  alert('Displaying current location...');
});
// Create the MD-11 airplane
const md11 = new THREE.Group();

// Fuselage (long cylinder for the body)
const fuselageGeometry = new THREE.CylinderGeometry(0.3, 0.3, 6, 32);
const fuselageMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.3, roughness: 0.6 });
const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
fuselage.rotation.z = Math.PI / 2; // Rotate to align with the x-axis
md11.add(fuselage);

// Wings (tapered with smooth edges)
const wingShape = new THREE.Shape();
wingShape.moveTo(0, 0);
wingShape.lineTo(2, 0.2); // Tapered edge
wingShape.lineTo(2, -0.2);
wingShape.lineTo(0, -0.2);
wingShape.lineTo(0, 0);

const extrudeSettings = { steps: 2, depth: 0.5, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02 };
const wingGeometry = new THREE.ExtrudeGeometry(wingShape, extrudeSettings);
const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, metalness: 0.2, roughness: 0.7 });
const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
leftWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
leftWing.position.set(-1, 0, 1.5); // Position left wing
md11.add(leftWing);

const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
rightWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
rightWing.position.set(-1, 0, -1.5); // Position right wing
md11.add(rightWing);

// Engines (cylinders for the engines)
const engineGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 32);
const engineMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
leftEngine.rotation.z = Math.PI / 2; // Rotate to align with the wings
leftEngine.position.set(-1.5, -0.3, 1.5); // Position under the left wing
md11.add(leftEngine);

const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
rightEngine.rotation.z = Math.PI / 2; // Rotate to align with the wings
rightEngine.position.set(-1.5, -0.3, -1.5); // Position under the right wing
md11.add(rightEngine);

const tailEngine = new THREE.Mesh(engineGeometry, engineMaterial);
tailEngine.rotation.z = Math.PI / 2; // Rotate to align with the fuselage
tailEngine.position.set(2.5, 0.5, 0); // Position at the tail
md11.add(tailEngine);

// Tail (T-tail structure)
const verticalStabilizerGeometry = new THREE.BoxGeometry(0.2, 1.5, 0.05);
const verticalStabilizerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const verticalStabilizer = new THREE.Mesh(verticalStabilizerGeometry, verticalStabilizerMaterial);
verticalStabilizer.position.set(2.8, 0.75, 0); // Position vertical stabilizer
md11.add(verticalStabilizer);

const horizontalStabilizerGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.5);
const horizontalStabilizerMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
const horizontalStabilizer = new THREE.Mesh(horizontalStabilizerGeometry, horizontalStabilizerMaterial);
horizontalStabilizer.position.set(2.8, 1.25, 0); // Position horizontal stabilizer
md11.add(horizontalStabilizer);

// Add the MD-11 to the scene
scene.add(md11);

// Position the MD-11
md11.position.set(0, 1, 0);
// Load textures
const textureLoader = new THREE.TextureLoader();
const fuselageTexture = textureLoader.load('path/to/fuselage-texture.jpg'); // Replace with your texture path
const wingTexture = textureLoader.load('path/to/wing-texture.jpg');

// Apply textures to materials
const fuselageMaterial = new THREE.MeshStandardMaterial({ map: fuselageTexture });
const wingMaterial = new THREE.MeshStandardMaterial({ map: wingTexture });
// Add rotation animation for the engines
function animateEngines() {
  leftEngine.rotation.z += 0.1; // Rotate left engine
  rightEngine.rotation.z += 0.1; // Rotate right engine
  tailEngine.rotation.z += 0.1; // Rotate tail engine
}

// Call this function inside the animation loop
function animate() {
  requestAnimationFrame(animate);

  // Animate engines
  animateEngines();

  // Other animations (e.g., airplane movement)
  renderer.render(scene, camera);
}
// Landing Gear Group
const landingGear = new THREE.Group();

// Main Landing Gear (Wheels under the wings)
const wheelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 32);
const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
leftWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
leftWheel.position.set(-0.75, -0.3, 0.6); // Position under the left wing
landingGear.add(leftWheel);

const rightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
rightWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
rightWheel.position.set(-0.75, -0.3, -0.6); // Position under the right wing
landingGear.add(rightWheel);

// Nose Gear (Wheel under the front fuselage)
const noseWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
noseWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
noseWheel.scale.set(0.8, 0.8, 0.8); // Slightly smaller wheel
noseWheel.position.set(-1.2, -0.3, 0); // Position under the nose
landingGear.add(noseWheel);

// Add landing gear to the airplane
md11.add(landingGear);
// Landing gear animation variables
let gearDeployed = true; // Start with gear deployed
let gearAnimationProgress = 0; // Progress of the animation (0 to 1)

// Function to animate landing gear
function animateLandingGear() {
  if (gearDeployed && gearAnimationProgress < 1) {
    gearAnimationProgress += 0.02; // Move gear down
  } else if (!gearDeployed && gearAnimationProgress > 0) {
    gearAnimationProgress -= 0.02; // Move gear up
  }

  // Update positions based on animation progress
  const gearOffset = THREE.MathUtils.lerp(-0.3, 0.3, gearAnimationProgress); // Interpolate between retracted and deployed positions
  leftWheel.position.y = gearOffset;
  rightWheel.position.y = gearOffset;
  noseWheel.position.y = THREE.MathUtils.lerp(-0.3, 0, gearAnimationProgress); // Nose gear moves differently
}

// Handle keyboard input for landing gear
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyG') {
    gearDeployed = !gearDeployed; // Toggle gear state
  }
});

// Call this function inside the animation loop
function animate() {
  requestAnimationFrame(animate);

  // Animate landing gear
  animateLandingGear();

  // Other animations (e.g., airplane movement)
  renderer.render(scene, camera);
}
function animate() {
  requestAnimationFrame(animate);

  // Animate engines
  animateEngines();

  // Animate landing gear
  animateLandingGear();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
// Create the C-130 airplane
const c130 = new THREE.Group();

// Fuselage (long cylinder for the body)
const fuselageGeometry = new THREE.CylinderGeometry(0.5, 0.5, 8, 32);
const fuselageMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.3, roughness: 0.6 });
const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
fuselage.rotation.z = Math.PI / 2; // Rotate to align with the x-axis
c130.add(fuselage);

// Wings (high-wing design)
const wingGeometry = new THREE.BoxGeometry(6, 0.2, 1);
const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
const wing = new THREE.Mesh(wingGeometry, wingMaterial);
wing.position.set(0, 0.5, 0); // Position above the fuselage
c130.add(wing);

// Engines (four turboprop engines)
const engineGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 32);
const engineMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const engines = [];
for (let i = 0; i < 4; i++) {
  const engine = new THREE.Mesh(engineGeometry, engineMaterial);
  engine.rotation.z = Math.PI / 2; // Rotate to align with the wings
  engine.position.set(i < 2 ? -1.5 : 1.5, 0.5, i % 2 === 0 ? 1.5 : -1.5); // Position engines symmetrically
  c130.add(engine);
  engines.push(engine);
}

// Propellers (rotating blades for each engine)
const propellerGeometry = new THREE.BoxGeometry(0.1, 1, 0.05);
const propellerMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const propellers = [];
engines.forEach((engine) => {
  const propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
  propeller.position.set(engine.position.x + 0.6, engine.position.y, engine.position.z); // Position in front of the engine
  c130.add(propeller);
  propellers.push(propeller);
});

// Tail (vertical and horizontal stabilizers)
const verticalStabilizerGeometry = new THREE.BoxGeometry(0.2, 1.5, 0.05);
const verticalStabilizerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const verticalStabilizer = new THREE.Mesh(verticalStabilizerGeometry, verticalStabilizerMaterial);
verticalStabilizer.position.set(3.5, 1, 0); // Position vertical stabilizer
c130.add(verticalStabilizer);

const horizontalStabilizerGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.5);
const horizontalStabilizerMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
const horizontalStabilizer = new THREE.Mesh(horizontalStabilizerGeometry, horizontalStabilizerMaterial);
horizontalStabilizer.position.set(3.5, 0.5, 0); // Position horizontal stabilizer
c130.add(horizontalStabilizer);

// Rear Cargo Ramp
const rampGeometry = new THREE.BoxGeometry(1, 0.1, 1.5);
const rampMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
ramp.position.set(-3.5, -0.5, 0); // Position at the rear of the fuselage
ramp.rotation.x = Math.PI / 6; // Slightly angled down
c130.add(ramp);

// Add the C-130 to the scene
scene.add(c130);

// Position the C-130
c130.position.set(0, 1, 0);

// Animate Propellers
function animatePropellers() {
  propellers.forEach((propeller) => {
    propeller.rotation.z += 0.2; // Rotate the propellers
  });
}

// Update the animation loop to include propeller animation
function animate() {
  requestAnimationFrame(animate);

  // Animate propellers
  animatePropellers();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
// Load textures
const textureLoader = new THREE.TextureLoader();
const fuselageTexture = textureLoader.load('path/to/fuselage-texture.jpg'); // Replace with your fuselage texture path
const wingTexture = textureLoader.load('path/to/wing-texture.jpg'); // Replace with your wing texture path

// Apply textures to materials
const fuselageMaterial = new THREE.MeshStandardMaterial({ map: fuselageTexture });
const wingMaterial = new THREE.MeshStandardMaterial({ map: wingTexture });

// Update fuselage and wings with textured materials
fuselage.material = fuselageMaterial;
wing.material = wingMaterial;
// Landing Gear Group
const landingGear = new THREE.Group();

// Main Landing Gear (Wheels under the wings)
const wheelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 32);
const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
leftWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
leftWheel.position.set(-1.5, -0.5, 1.5); // Position under the left wing
landingGear.add(leftWheel);

const rightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
rightWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
rightWheel.position.set(-1.5, -0.5, -1.5); // Position under the right wing
landingGear.add(rightWheel);

// Nose Gear (Wheel under the front fuselage)
const noseWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
noseWheel.rotation.z = Math.PI / 2; // Rotate to align with the ground
noseWheel.scale.set(0.8, 0.8, 0.8); // Slightly smaller wheel
noseWheel.position.set(-3.5, -0.5, 0); // Position under the nose
landingGear.add(noseWheel);

// Add landing gear to the airplane
c130.add(landingGear);
// Landing gear animation variables
let gearDeployed = true; // Start with gear deployed
let gearAnimationProgress = 0; // Progress of the animation (0 to 1)

// Function to animate landing gear
function animateLandingGear() {
  if (gearDeployed && gearAnimationProgress < 1) {
    gearAnimationProgress += 0.02; // Move gear down
  } else if (!gearDeployed && gearAnimationProgress > 0) {
    gearAnimationProgress -= 0.02; // Move gear up
  }

  // Update positions based on animation progress
  const gearOffset = THREE.MathUtils.lerp(-0.5, 0.5, gearAnimationProgress); // Interpolate between retracted and deployed positions
  leftWheel.position.y = gearOffset;
  rightWheel.position.y = gearOffset;
  noseWheel.position.y = THREE.MathUtils.lerp(-0.5, 0, gearAnimationProgress); // Nose gear moves differently
}

// Handle keyboard input for landing gear
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyG') {
    gearDeployed = !gearDeployed; // Toggle gear state
  }
});
// Ambient Light
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft ambient light
scene.add(ambientLight);

// Directional Light
const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Spot Light for Focused Lighting
const spotLight = new THREE.SpotLight(0xffffff, 0.8);
spotLight.position.set(0, 5, 5);
spotLight.castShadow = true;
scene.add(spotLight);
function animate() {
  requestAnimationFrame(animate);

  // Animate propellers
  animatePropellers();

  // Animate landing gear
  animateLandingGear();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
// Create the KORD airport group
const airport = new THREE.Group();

// Runway
const runwayGeometry = new THREE.PlaneGeometry(200, 20); // Long rectangular runway
const runwayMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
runway.rotation.x = -Math.PI / 2; // Align with the ground
runway.position.set(0, 0, 0); // Center of the airport
airport.add(runway);

// Runway markings
const markingGeometry = new THREE.PlaneGeometry(2, 0.5); // Small rectangular markings
const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
for (let i = -90; i <= 90; i += 10) {
  const marking = new THREE.Mesh(markingGeometry, markingMaterial);
  marking.rotation.x = -Math.PI / 2;
  marking.position.set(i, 0.01, 0); // Slightly above the runway
  airport.add(marking);
}

// Taxiways
const taxiwayGeometry = new THREE.PlaneGeometry(100, 10); // Shorter and narrower than the runway
const taxiwayMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
const taxiway = new THREE.Mesh(taxiwayGeometry, taxiwayMaterial);
taxiway.rotation.x = -Math.PI / 2;
taxiway.position.set(0, 0, -15); // Parallel to the runway
airport.add(taxiway);

// Terminal building
const terminalGeometry = new THREE.BoxGeometry(30, 10, 10); // Rectangular terminal
const terminalMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
const terminal = new THREE.Mesh(terminalGeometry, terminalMaterial);
terminal.position.set(-50, 5, -20); // Near the taxiway
airport.add(terminal);

// Control tower
const towerGeometry = new THREE.CylinderGeometry(2, 2, 20, 32); // Tall cylinder for the tower
const towerMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
const tower = new THREE.Mesh(towerGeometry, towerMaterial);
tower.position.set(-60, 10, -20); // Next to the terminal
airport.add(tower);

// Add the airport to the scene
scene.add(airport);

// Position the airport
airport.position.set(0, 0, 0);
// Runway texture
const runwayTexture = new THREE.TextureLoader().load('path/to/runway-texture.jpg'); // Replace with your texture path
runway.material.map = runwayTexture;
runway.material.needsUpdate = true;

// Add runway lights
const lightMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
for (let i = -90; i <= 90; i += 20) {
  const light = new THREE.SphereGeometry(0.2, 16, 16); // Small spheres for lights
  const lightMesh = new THREE.Mesh(light, lightMaterial);
  lightMesh.position.set(i, 0.5, 10); // Along the runway edges
  airport.add(lightMesh);
}
// Pushback variables
let isPushingBack = false; // Indicates if pushback is active
const pushbackSpeed = 0.05; // Speed of the pushback

// Handle keyboard input for pushback
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyP') {
    isPushingBack = true; // Start pushback
  }
});

document.addEventListener('keyup', (event) => {
  if (event.code === 'KeyP') {
    isPushingBack = false; // Stop pushback
  }
});

// Update the animation loop to include pushback
function animate() {
  requestAnimationFrame(animate);

  // Apply movement
  airplane.rotation.x += pitch;
  airplane.rotation.z += roll;

  // Move forward in the direction the airplane is facing
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(airplane.quaternion);

  if (isPushingBack) {
    // Pushback: Move backward
    airplane.position.addScaledVector(direction, -pushbackSpeed);
  } else {
    // Normal forward movement
    airplane.position.addScaledVector(direction, speed);
  }

  // Update camera to follow the airplane
  camera.position.lerp(
    new THREE.Vector3(
      airplane.position.x,
      airplane.position.y + 2,
      airplane.position.z + 5
    ),
    0.1
  );
  camera.lookAt(airplane.position);

  renderer.render(scene, camera);
}

animate();
// Pushback Tug
const tugGeometry = new THREE.BoxGeometry(1, 0.5, 0.5); // Simple rectangular tug
const tugMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
const pushbackTug = new THREE.Mesh(tugGeometry, tugMaterial);
pushbackTug.position.set(-1.5, -0.25, 0); // Position in front of the airplane
scene.add(pushbackTug);
pushbackTug.visible = false; // Hide tug initially
// Pushback variables
let isPushingBack = false; // Indicates if pushback is active
const pushbackSpeed = 0.05; // Speed of the pushback
let pushbackAngle = 0; // Angle for directional pushback

// Handle keyboard input for pushback
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyP') {
    isPushingBack = true; // Start pushback
    pushbackTug.visible = true; // Show the tug
  }
  if (event.code === 'ArrowLeft') pushbackAngle = 0.02; // Rotate left during pushback
  if (event.code === 'ArrowRight') pushbackAngle = -0.02; // Rotate right during pushback
});

document.addEventListener('keyup', (event) => {
  if (event.code === 'KeyP') {
    isPushingBack = false; // Stop pushback
    pushbackTug.visible = false; // Hide the tug
  }
  if (['ArrowLeft', 'ArrowRight'].includes(event.code)) pushbackAngle = 0; // Stop rotation
});

// Animate pushback
function animatePushback() {
  if (isPushingBack) {
    // Move airplane backward
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(airplane.quaternion);
    airplane.position.addScaledVector(direction, -pushbackSpeed);

    // Rotate airplane slightly
    airplane.rotation.y += pushbackAngle;

    // Move the tug with the airplane
    pushbackTug.position.set(
      airplane.position.x - 1.5 * Math.cos(airplane.rotation.y),
      airplane.position.y - 0.25,
      airplane.position.z - 1.5 * Math.sin(airplane.rotation.y)
    );
    pushbackTug.rotation.y = airplane.rotation.y;
  }
}
function animateWheels() {
  if (isPushingBack) {
    leftWheel.rotation.x -= 0.1; // Rotate wheels backward
    rightWheel.rotation.x -= 0.1;
    noseWheel.rotation.x -= 0.1;
  }
}
function animateWheels() {
  if (isPushingBack) {
    leftWheel.rotation.x -= 0.1; // Rotate wheels backward
    rightWheel.rotation.x -= 0.1;
    noseWheel.rotation.x -= 0.1;
  }
}
// Load pushback sound
const listener = new THREE.AudioListener();
camera.add(listener);

const pushbackSound = new THREE.Audio(listener);
const audioLoader = new THREE.AudioLoader();
audioLoader.load('path/to/pushback-sound.mp3', (buffer) => {
  pushbackSound.setBuffer(buffer);
  pushbackSound.setLoop(true);
  pushbackSound.setVolume(0.5);
});

// Play/stop sound during pushback
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyP' && !pushbackSound.isPlaying) {
    pushbackSound.play();
  }
});

document.addEventListener('keyup', (event) => {
  if (event.code === 'KeyP') {
    pushbackSound.stop();
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Apply movement
  airplane.rotation.x += pitch;
  airplane.rotation.z += roll;

  // Move forward in the direction the airplane is facing
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(airplane.quaternion);
  airplane.position.addScaledVector(direction, speed);

  // Animate pushback
  animatePushback();

  // Animate wheels
  animateWheels();

  // Update camera to follow the airplane
  camera.position.lerp(
    new THREE.Vector3(
      airplane.position.x,
      airplane.position.y + 2,
      airplane.position.z + 5
    ),
    0.1
  );
  camera.lookAt(airplane.position);

  renderer.render(scene, camera);
}

animate();
// Create the EGLL airport group
const heathrow = new THREE.Group();

// Runways
const runwayGeometry = new THREE.PlaneGeometry(300, 20); // Long rectangular runways
const runwayMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const runway1 = new THREE.Mesh(runwayGeometry, runwayMaterial);
runway1.rotation.x = -Math.PI / 2; // Align with the ground
runway1.position.set(0, 0, -50); // Position for the first runway
heathrow.add(runway1);

const runway2 = new THREE.Mesh(runwayGeometry, runwayMaterial);
runway2.rotation.x = -Math.PI / 2;
runway2.position.set(0, 0, 50); // Position for the second runway
heathrow.add(runway2);

// Runway markings
const markingGeometry = new THREE.PlaneGeometry(2, 0.5); // Small rectangular markings
const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
for (let i = -140; i <= 140; i += 10) {
  const marking1 = new THREE.Mesh(markingGeometry, markingMaterial);
  marking1.rotation.x = -Math.PI / 2;
  marking1.position.set(i, 0.01, -50); // Slightly above the first runway
  heathrow.add(marking1);

  const marking2 = new THREE.Mesh(markingGeometry, markingMaterial);
  marking2.rotation.x = -Math.PI / 2;
  marking2.position.set(i, 0.01, 50); // Slightly above the second runway
  heathrow.add(marking2);
}

// Taxiways
const taxiwayGeometry = new THREE.PlaneGeometry(150, 10); // Shorter and narrower than the runways
const taxiwayMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });

const taxiway1 = new THREE.Mesh(taxiwayGeometry, taxiwayMaterial);
taxiway1.rotation.x = -Math.PI / 2;
taxiway1.position.set(-75, 0, -30); // Parallel to the first runway
heathrow.add(taxiway1);

const taxiway2 = new THREE.Mesh(taxiwayGeometry, taxiwayMaterial);
taxiway2.rotation.x = -Math.PI / 2;
taxiway2.position.set(-75, 0, 30); // Parallel to the second runway
heathrow.add(taxiway2);

// Terminals
const terminalGeometry = new THREE.BoxGeometry(50, 15, 20); // Rectangular terminals
const terminalMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });

const terminal1 = new THREE.Mesh(terminalGeometry, terminalMaterial);
terminal1.position.set(-100, 7.5, -30); // Near the first taxiway
heathrow.add(terminal1);

const terminal2 = new THREE.Mesh(terminalGeometry, terminalMaterial);
terminal2.position.set(-100, 7.5, 30); // Near the second taxiway
heathrow.add(terminal2);

// Control Tower
const towerGeometry = new THREE.CylinderGeometry(3, 3, 30, 32); // Tall cylinder for the tower
const towerMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
const controlTower = new THREE.Mesh(towerGeometry, towerMaterial);
controlTower.position.set(-150, 15, 0); // Between the terminals
heathrow.add(controlTower);

// Add the airport to the scene
scene.add(heathrow);

// Position the airport
heathrow.position.set(0, 0, 0);
// Runway texture
const runwayTexture = new THREE.TextureLoader().load('path/to/runway-texture.jpg'); // Replace with your texture path
runway1.material.map = runwayTexture;
runway1.material.needsUpdate = true;
runway2.material.map = runwayTexture;
runway2.material.needsUpdate = true;

// Add runway lights
const lightMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
for (let i = -140; i <= 140; i += 20) {
  const light1 = new THREE.SphereGeometry(0.2, 16, 16); // Small spheres for lights
  const lightMesh1 = new THREE.Mesh(light1, lightMaterial);
  lightMesh1.position.set(i, 0.5, -60); // Along the edges of the first runway
  heathrow.add(lightMesh1);

  const light2 = new THREE.SphereGeometry(0.2, 16, 16);
  const lightMesh2 = new THREE.Mesh(light2, lightMaterial);
  lightMesh2.position.set(i, 0.5, 60); // Along the edges of the second runway
  heathrow.add(lightMesh2);
}
// Create the EGLL airport group
const heathrow = new THREE.Group();

// Runways
const runwayGeometry = new THREE.PlaneGeometry(300, 20); // Long rectangular runways
const runwayMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const runway1 = new THREE.Mesh(runwayGeometry, runwayMaterial);
runway1.rotation.x = -Math.PI / 2; // Align with the ground
runway1.position.set(0, 0, -50); // Position for the first runway
heathrow.add(runway1);

const runway2 = new THREE.Mesh(runwayGeometry, runwayMaterial);
runway2.rotation.x = -Math.PI / 2;
runway2.position.set(0, 0, 50); // Position for the second runway
heathrow.add(runway2);

// Runway markings
const markingGeometry = new THREE.PlaneGeometry(2, 0.5); // Small rectangular markings
const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
for (let i = -140; i <= 140; i += 10) {
  const marking1 = new THREE.Mesh(markingGeometry, markingMaterial);
  marking1.rotation.x = -Math.PI / 2;
  marking1.position.set(i, 0.01, -50); // Slightly above the first runway
  heathrow.add(marking1);

  const marking2 = new THREE.Mesh(markingGeometry, markingMaterial);
  marking2.rotation.x = -Math.PI / 2;
  marking2.position.set(i, 0.01, 50); // Slightly above the second runway
  heathrow.add(marking2);
}

// Taxiways
const taxiwayGeometry = new THREE.PlaneGeometry(150, 10); // Shorter and narrower than the runways
const taxiwayMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });

const taxiway1 = new THREE.Mesh(taxiwayGeometry, taxiwayMaterial);
taxiway1.rotation.x = -Math.PI / 2;
taxiway1.position.set(-75, 0, -30); // Parallel to the first runway
heathrow.add(taxiway1);

const taxiway2 = new THREE.Mesh(taxiwayGeometry, taxiwayMaterial);
taxiway2.rotation.x = -Math.PI / 2;
taxiway2.position.set(-75, 0, 30); // Parallel to the second runway
heathrow.add(taxiway2);

// Terminals
const terminalGeometry = new THREE.BoxGeometry(50, 15, 20); // Rectangular terminals
const terminalMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });

const terminal1 = new THREE.Mesh(terminalGeometry, terminalMaterial);
terminal1.position.set(-100, 7.5, -30); // Near the first taxiway
heathrow.add(terminal1);

const terminal2 = new THREE.Mesh(terminalGeometry, terminalMaterial);
terminal2.position.set(-100, 7.5, 30); // Near the second taxiway
heathrow.add(terminal2);

// Control Tower
const towerGeometry = new THREE.CylinderGeometry(3, 3, 30, 32); // Tall cylinder for the tower
const towerMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
const controlTower = new THREE.Mesh(towerGeometry, towerMaterial);
controlTower.position.set(-150, 15, 0); // Between the terminals
heathrow.add(controlTower);

// Add the airport to the scene
scene.add(heathrow);

// Position the airport
heathrow.position.set(0, 0, 0);

// Runway texture
const runwayTexture = new THREE.TextureLoader().load('path/to/runway-texture.jpg'); // Replace with your texture path
runway1.material.map = runwayTexture;
runway1.material.needsUpdate = true;
runway2.material.map = runwayTexture;
runway2.material.needsUpdate = true;

// Add runway lights
const lightMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
for (let i = -140; i <= 140; i += 20) {
  const light1 = new THREE.SphereGeometry(0.2, 16, 16); // Small spheres for lights
  const lightMesh1 = new THREE.Mesh(light1, lightMaterial);
  lightMesh1.position.set(i, 0.5, -60); // Along the edges of the first runway
  heathrow.add(lightMesh1);

  const light2 = new THREE.SphereGeometry(0.2, 16, 16);
  const lightMesh2 = new THREE.Mesh(light2, lightMaterial);
  lightMesh2.position.set(i, 0.5, 60); // Along the edges of the second runway
  heathrow.add(lightMesh2);
}
// Create the EGLL airport group
const heathrow = new THREE.Group();

// Runways
const runwayGeometry = new THREE.PlaneGeometry(300, 20); // Long rectangular runways
const runwayMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const runway1 = new THREE.Mesh(runwayGeometry, runwayMaterial);
runway1.rotation.x = -Math.PI / 2; // Align with the ground
runway1.position.set(0, 0, -50); // Position for the first runway
heathrow.add(runway1);

const runway2 = new THREE.Mesh(runwayGeometry, runwayMaterial);
runway2.rotation.x = -Math.PI / 2;
runway2.position.set(0, 0, 50); // Position for the second runway
heathrow.add(runway2);

// Runway markings
const markingGeometry = new THREE.PlaneGeometry(2, 0.5); // Small rectangular markings
const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
for (let i = -140; i <= 140; i += 10) {
  const marking1 = new THREE.Mesh(markingGeometry, markingMaterial);
  marking1.rotation.x = -Math.PI / 2;
  marking1.position.set(i, 0.01, -50); // Slightly above the first runway
  heathrow.add(marking1);

  const marking2 = new THREE.Mesh(markingGeometry, markingMaterial);
  marking2.rotation.x = -Math.PI / 2;
  marking2.position.set(i, 0.01, 50); // Slightly above the second runway
  heathrow.add(marking2);
}

// Taxiways
const taxiwayGeometry = new THREE.PlaneGeometry(150, 10); // Shorter and narrower than the runways
const taxiwayMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });

const taxiway1 = new THREE.Mesh(taxiwayGeometry, taxiwayMaterial);
taxiway1.rotation.x = -Math.PI / 2;
taxiway1.position.set(-75, 0, -30); // Parallel to the first runway
heathrow.add(taxiway1);

const taxiway2 = new THREE.Mesh(taxiwayGeometry, taxiwayMaterial);
taxiway2.rotation.x = -Math.PI / 2;
taxiway2.position.set(-75, 0, 30); // Parallel to the second runway
heathrow.add(taxiway2);

// Terminals
const terminalGeometry = new THREE.BoxGeometry(50, 15, 20); // Rectangular terminals
const terminalMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });

const terminal1 = new THREE.Mesh(terminalGeometry, terminalMaterial);
terminal1.position.set(-100, 7.5, -30); // Near the first taxiway
heathrow.add(terminal1);

const terminal2 = new THREE.Mesh(terminalGeometry, terminalMaterial);
terminal2.position.set(-100, 7.5, 30); // Near the second taxiway
heathrow.add(terminal2);

// Control Tower
const towerGeometry = new THREE.CylinderGeometry(3, 3, 30, 32); // Tall cylinder for the tower
const towerMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
const controlTower = new THREE.Mesh(towerGeometry, towerMaterial);
controlTower.position.set(-150, 15, 0); // Between the terminals
heathrow.add(controlTower);

// Add the airport to the scene
scene.add(heathrow);

// Position the airport
heathrow.position.set(0, 0, 0);

// Runway texture
const runwayTexture = new THREE.TextureLoader().load('path/to/runway-texture.jpg'); // Replace with your texture path
runway1.material.map = runwayTexture;
runway1.material.needsUpdate = true;
runway2.material.map = runwayTexture;
runway2.material.needsUpdate = true;

// Add runway lights
const lightMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
for (let i = -140; i <= 140; i += 20) {
  const light1 = new THREE.SphereGeometry(0.2, 16, 16); // Small spheres for lights
  const lightMesh1 = new THREE.Mesh(light1, lightMaterial);
  lightMesh1.position.set(i, 0.5, -60); // Along the edges of the first runway
  heathrow.add(lightMesh1);

  const light2 = new THREE.SphereGeometry(0.2, 16, 16);
  const lightMesh2 = new THREE.Mesh(light2, lightMaterial);
  lightMesh2.position.set(i, 0.5, 60); // Along the edges of the second runway
  heathrow.add(lightMesh2);
}

// Pushback Tug
const tugGeometry = new THREE.BoxGeometry(1, 0.5, 0.5); // Simple rectangular tug
const tugMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
const pushbackTug = new THREE.Mesh(tugGeometry, tugMaterial);
pushbackTug.position.set(-1.5, -0.25, 0); // Position in front of the airplane
scene.add(pushbackTug);
pushbackTug.visible = false; // Hide tug initially

// Pushback variables
let isPushingBack = false; // Indicates if pushback is active
const pushbackSpeed = 0.05; // Speed of the pushback
let pushbackAngle = 0; // Angle for directional pushback

// Handle keyboard input for pushback
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyP') {
    isPushingBack = true; // Start pushback
    pushbackTug.visible = true; // Show the tug
  }
  if (event.code === 'ArrowLeft') pushbackAngle = 0.02; // Rotate left during pushback
  if (event.code === 'ArrowRight') pushbackAngle = -0.02; // Rotate right during pushback
});

document.addEventListener('keyup', (event) => {
  if (event.code === 'KeyP') {
    isPushingBack = false; // Stop pushback
    pushbackTug.visible = false; // Hide the tug
  }
  if (['ArrowLeft', 'ArrowRight'].includes(event.code)) pushbackAngle = 0; // Stop rotation
});

// Animate pushback
function animatePushback() {
  if (isPushingBack) {
    // Move airplane backward
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(airplane.quaternion);
    airplane.position.addScaledVector(direction, -pushbackSpeed);

    // Rotate airplane slightly
    airplane.rotation.y += pushbackAngle;

    // Move the tug with the airplane
    pushbackTug.position.set(
      airplane.position.x - 1.5 * Math.cos(airplane.rotation.y),
      airplane.position.y - 0.25,
      airplane.position.z - 1.5 * Math.sin(airplane.rotation.y)
    );
    pushbackTug.rotation.y = airplane.rotation.y;
  }
}

// Lighting for Night Operations
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft ambient light
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

const spotLight = new THREE.SpotLight(0xffffff, 0.8);
spotLight.position.set(0, 5, 5);
spotLight.castShadow = true;
scene.add(spotLight);

// Animation Loop
function animate() {
  requestAnimationFrame(animate);

  // Animate pushback
  animatePushback();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
// Create the SU-35 airplane group
const su35 = new THREE.Group();

// Fuselage (long cylinder for the body)
const fuselageGeometry = new THREE.CylinderGeometry(0.3, 0.3, 6, 32);
const fuselageMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.5, roughness: 0.3 });
const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
fuselage.rotation.z = Math.PI / 2; // Rotate to align with the x-axis
su35.add(fuselage);

// Cockpit (transparent dome)
const cockpitGeometry = new THREE.SphereGeometry(0.5, 32, 32, 0, Math.PI);
const cockpitMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, transparent: true, opacity: 0.6 });
const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
cockpit.position.set(1.5, 0.3, 0); // Position on top of the fuselage
su35.add(cockpit);

// Wings (delta-shaped wings)
const wingShape = new THREE.Shape();
wingShape.moveTo(0, 0);
wingShape.lineTo(2, 0.5); // Tapered edge
wingShape.lineTo(2, -0.5);
wingShape.lineTo(0, -0.2);
wingShape.lineTo(0, 0);

const wingExtrudeSettings = { steps: 2, depth: 0.1, bevelEnabled: false };
const wingGeometry = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
leftWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
leftWing.position.set(-1, 0, 1.5); // Position left wing
su35.add(leftWing);

const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
rightWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
rightWing.position.set(-1, 0, -1.5); // Position right wing
su35.add(rightWing);

// Vertical Stabilizers (tail fins)
const stabilizerGeometry = new THREE.BoxGeometry(0.1, 1, 0.5);
const stabilizerMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });

const leftStabilizer = new THREE.Mesh(stabilizerGeometry, stabilizerMaterial);
leftStabilizer.position.set(2.5, 0.5, 0.6); // Position left stabilizer
leftStabilizer.rotation.z = Math.PI / 12; // Slight angle outward
su35.add(leftStabilizer);

const rightStabilizer = new THREE.Mesh(stabilizerGeometry, stabilizerMaterial);
rightStabilizer.position.set(2.5, 0.5, -0.6); // Position right stabilizer
rightStabilizer.rotation.z = -Math.PI / 12; // Slight angle outward
su35.add(rightStabilizer);

// Engines (cylinders for the engines)
const engineGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 32);
const engineMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
leftEngine.rotation.z = Math.PI / 2; // Rotate to align with the fuselage
leftEngine.position.set(-2.5, -0.3, 0.5); // Position under the left wing
su35.add(leftEngine);

const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
rightEngine.rotation.z = Math.PI / 2; // Rotate to align with the fuselage
rightEngine.position.set(-2.5, -0.3, -0.5); // Position under the right wing
su35.add(rightEngine);

// Nose Cone (pointed front)
const noseGeometry = new THREE.ConeGeometry(0.3, 1, 32);
const noseMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
const nose = new THREE.Mesh(noseGeometry, noseMaterial);
nose.rotation.z = Math.PI / 2; // Rotate to align with the fuselage
nose.position.set(3, 0, 0); // Position at the front of the fuselage
su35.add(nose);

// Add the SU-35 to the scene
scene.add(su35);

// Position the SU-35
su35.position.set(0, 1, 0);

// Animation Loop
function animate() {
  requestAnimationFrame(animate);

  // Rotate the engines slightly for realism
  leftEngine.rotation.x += 0.01;
  rightEngine.rotation.x += 0.01;

  renderer.render(scene, camera);
}

animate();
// Create the SU-35 airplane group
const su35 = new THREE.Group();

// Fuselage (smooth cylinder for the body)
const fuselageGeometry = new THREE.CylinderGeometry(0.3, 0.3, 6, 64);
const fuselageTexture = new THREE.TextureLoader().load('path/to/fuselage-texture.jpg'); // Replace with your texture path
const fuselageMaterial = new THREE.MeshStandardMaterial({
  map: fuselageTexture,
  metalness: 0.5,
  roughness: 0.3,
});
const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
fuselage.rotation.z = Math.PI / 2; // Rotate to align with the x-axis
su35.add(fuselage);

// Cockpit (transparent dome with reflection)
const cockpitGeometry = new THREE.SphereGeometry(0.5, 64, 64, 0, Math.PI);
const cockpitMaterial = new THREE.MeshStandardMaterial({
  color: 0x0000ff,
  transparent: true,
  opacity: 0.6,
  metalness: 0.8,
  roughness: 0.1,
});
const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
cockpit.position.set(1.5, 0.3, 0); // Position on top of the fuselage
su35.add(cockpit);

// Wings (delta-shaped wings with smooth edges)
const wingShape = new THREE.Shape();
wingShape.moveTo(0, 0);
wingShape.lineTo(2, 0.5); // Tapered edge
wingShape.lineTo(2, -0.5);
wingShape.lineTo(0, -0.2);
wingShape.lineTo(0, 0);

const wingExtrudeSettings = { steps: 2, depth: 0.1, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02 };
const wingGeometry = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
const wingTexture = new THREE.TextureLoader().load('path/to/wing-texture.jpg'); // Replace with your texture path
const wingMaterial = new THREE.MeshStandardMaterial({
  map: wingTexture,
  metalness: 0.4,
  roughness: 0.5,
});

const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
leftWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
leftWing.position.set(-1, 0, 1.5); // Position left wing
su35.add(leftWing);

const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
rightWing.rotation.y = Math.PI / 2; // Rotate to align with the fuselage
rightWing.position.set(-1, 0, -1.5); // Position right wing
su35.add(rightWing);

// Vertical Stabilizers (tail fins with slight angle)
const stabilizerGeometry = new THREE.BoxGeometry(0.1, 1, 0.5);
const stabilizerMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });

const leftStabilizer = new THREE.Mesh(stabilizerGeometry, stabilizerMaterial);
leftStabilizer.position.set(2.5, 0.5, 0.6); // Position left stabilizer
leftStabilizer.rotation.z = Math.PI / 12; // Slight angle outward
su35.add(leftStabilizer);

const rightStabilizer = new THREE.Mesh(stabilizerGeometry, stabilizerMaterial);
rightStabilizer.position.set(2.5, 0.5, -0.6); // Position right stabilizer
rightStabilizer.rotation.z = -Math.PI / 12; // Slight angle outward
su35.add(rightStabilizer);

// Engines (cylinders with emissive afterburner effect)
const engineGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 64);
const engineMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });

const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
leftEngine.rotation.z = Math.PI / 2; // Rotate to align with the fuselage
leftEngine.position.set(-2.5, -0.3, 0.5); // Position under the left wing
su35.add(leftEngine);

const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
rightEngine.rotation.z = Math.PI / 2; // Rotate to align with the fuselage
rightEngine.position.set(-2.5, -0.3, -0.5); // Position under the right wing
su35.add(rightEngine);

// Afterburners (glowing spheres at the engine exhaust)
const afterburnerGeometry = new THREE.SphereGeometry(0.2, 32, 32);
const afterburnerMaterial = new THREE.MeshStandardMaterial({
  color: 0xff4500,
  emissive: 0xff4500,
  emissiveIntensity: 1,
});
const leftAfterburner = new THREE.Mesh(afterburnerGeometry, afterburnerMaterial);
leftAfterburner.position.set(-3, -0.3, 0.5); // Position at the exhaust of the left engine
su35.add(leftAfterburner);

const rightAfterburner = new THREE.Mesh(afterburnerGeometry, afterburnerMaterial);
rightAfterburner.position.set(-3, -0.3, -0.5); // Position at the exhaust of the right engine
su35.add(rightAfterburner);

// Nose Cone (pointed front with smooth finish)
const noseGeometry = new THREE.ConeGeometry(0.3, 1, 64);
const noseMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
const nose = new THREE.Mesh(noseGeometry, noseMaterial);
nose.rotation.z = Math.PI / 2; // Rotate to align with the fuselage
nose.position.set(3, 0, 0); // Position at the front of the fuselage
su35.add(nose);

// Add the SU-35 to the scene
scene.add(su35);

// Position the SU-35
su35.position.set(0, 1, 0);

// Animation Loop
function animate() {
  requestAnimationFrame(animate);

  // Rotate the afterburners for a glowing effect
  leftAfterburner.rotation.y += 0.1;
  rightAfterburner.rotation.y += 0.1;

  // Render the scene
  renderer.render(scene, camera);
}

animate();
// Add volumetric clouds
const cloudTexture = new THREE.TextureLoader().load('path/to/cloud-texture.png'); // Replace with your texture
const cloudMaterial = new THREE.SpriteMaterial({ map: cloudTexture, transparent: true });
const clouds = new THREE.Group();

for (let i = 0; i < 100; i++) {
  const cloud = new THREE.Sprite(cloudMaterial);
  cloud.position.set(
    Math.random() * 1000 - 500,
    Math.random() * 200 + 100,
    Math.random() * 1000 - 500
  );
  cloud.scale.set(200, 200, 1);
  clouds.add(cloud);
}

scene.add(clouds);

// Add rain effect
const rainGeometry = new THREE.BufferGeometry();
const rainCount = 10000;
const rainPositions = new Float32Array(rainCount * 3);

for (let i = 0; i < rainCount; i++) {
  rainPositions[i * 3] = Math.random() * 1000 - 500;
  rainPositions[i * 3 + 1] = Math.random() * 500;
  rainPositions[i * 3 + 2] = Math.random() * 1000 - 500;
}

rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
const rainMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1, transparent: true });
const rain = new THREE.Points(rainGeometry, rainMaterial);

scene.add(rain);

// Animate rain
function animateRain() {
  const positions = rain.geometry.attributes.position.array;
  for (let i = 0; i < rainCount; i++) {
    positions[i * 3 + 1] -= 2; // Move rain down
    if (positions[i * 3 + 1] < 0) {
      positions[i * 3 + 1] = Math.random() * 500; // Reset rain position
    }
  }
  rain.geometry.attributes.position.needsUpdate = true;
}
let lift = 0;
let drag = 0;
let thrust = 0.5;
let weight = 9.8;

function updatePhysics() {
  // Calculate lift
  lift = 0.5 * airDensity * wingArea * Math.pow(airspeed, 2);

  // Calculate drag
  drag = 0.5 * dragCoefficient * wingArea * Math.pow(airspeed, 2);

  // Update forces
  const netForce = thrust - drag - weight + lift;

  // Update airplane position
  airplane.position.y += lift * 0.01;
  airplane.position.x += thrust * 0.01;
  airplane.rotation.x += pitch;
  airplane.rotation.z += roll;
}
<!-- Settings Menu -->
<div id="settings-menu" class="hidden">
  <h3>Settings</h3>
  <label for="control-scheme">Control Scheme:</label>
  <select id="control-scheme">
    <option value="keyboard">Keyboard</option>
    <option value="mouse">Mouse</option>
    <option value="gamepad">Gamepad</option>
  </select>
  <button id="apply-settings">Apply</button>
</div>

<style>
  #settings-menu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    z-index: 1001;
  }

  #settings-menu.hidden {
    display: none;
  }

  #settings-menu h3 {
    margin-top: 0;
    text-align: center;
  }

  #settings-menu label, #settings-menu select, #settings-menu button {
    display: block;
    margin: 10px auto;
    width: 80%;
  }
</style>
let controlScheme = 'keyboard'; // Default control scheme

// Handle control scheme selection
document.getElementById('apply-settings').addEventListener('click', () => {
  controlScheme = document.getElementById('control-scheme').value;
  alert(`Control scheme set to: ${controlScheme}`);
  document.getElementById('settings-menu').classList.add('hidden');
});

// Keyboard Controls
function handleKeyboardInput(event) {
  switch (event.code) {
    case 'ArrowUp': pitch = 0.02; break;
    case 'ArrowDown': pitch = -0.02; break;
    case 'ArrowLeft': roll = 0.02; break;
    case 'ArrowRight': roll = -0.02; break;
    case 'KeyW': speed += 0.01; break;
    case 'KeyS': speed -= 0.01; break;
  }
}

// Mouse Controls
function handleMouseInput(event) {
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;

  pitch = (centerY - event.clientY) * 0.0001; // Adjust pitch based on vertical mouse movement
  roll = (centerX - event.clientX) * 0.0001; // Adjust roll based on horizontal mouse movement
}

// Gamepad Controls
function handleGamepadInput() {
  const gamepad = navigator.getGamepads()[0];
  if (gamepad) {
    pitch = gamepad.axes[1] * 0.02; // Vertical axis for pitch
    roll = gamepad.axes[0] * 0.02;  // Horizontal axis for roll
    speed += gamepad.buttons[7].value * 0.01; // Right trigger for throttle
    speed -= gamepad.buttons[6].value * 0.01; // Left trigger for brake
  }
}

// Main Input Handler
function handleInput(event) {
  if (controlScheme === 'keyboard') {
    handleKeyboardInput(event);
  } else if (controlScheme === 'mouse') {
    document.addEventListener('mousemove', handleMouseInput);
  } else if (controlScheme === 'gamepad') {
    handleGamepadInput();
  }
}

// Add Event Listeners
document.addEventListener('keydown', handleInput);
document.addEventListener('keyup', (event) => {
  if (['ArrowUp', 'ArrowDown'].includes(event.code)) pitch = 0;
  if (['ArrowLeft', 'ArrowRight'].includes(event.code)) roll = 0;
});
function animate() {
  requestAnimationFrame(animate);

  // Handle gamepad input if the control scheme is gamepad
  if (controlScheme === 'gamepad') {
    handleGamepadInput();
  }

  // Apply movement
  airplane.rotation.x += pitch;
  airplane.rotation.z += roll;

  // Move forward in the direction the airplane is facing
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(airplane.quaternion);
  airplane.position.addScaledVector(direction, speed);

  // Update camera to follow the airplane
  camera.position.lerp(
    new THREE.Vector3(
      airplane.position.x,
      airplane.position.y + 2,
      airplane.position.z + 5
    ),
    0.1
  );
  camera.lookAt(airplane.position);

  renderer.render(scene, camera);
}

animate();
document.getElementById('settings-btn').addEventListener('click', () => {
  const settingsMenu = document.getElementById('settings-menu');
  settingsMenu.classList.toggle('hidden');
});
<!-- Settings Menu -->
<div id="settings-menu" class="hidden">
  <h3>Settings</h3>
  
  <!-- Control Scheme -->
  <label for="control-scheme">Control Scheme:</label>
  <select id="control-scheme">
    <option value="keyboard">Keyboard</option>
    <option value="mouse">Mouse</option>
    <option value="gamepad">Gamepad</option>
  </select>

  <!-- Sensitivity -->
  <label for="sensitivity">Sensitivity:</label>
  <input id="sensitivity" type="range" min="0.1" max="2" step="0.1" value="1">

  <!-- Invert Pitch/Roll/Yaw -->
  <label for="invert-pitch">
    <input id="invert-pitch" type="checkbox"> Invert Pitch
  </label>
  <label for="invert-roll">
    <input id="invert-roll" type="checkbox"> Invert Roll
  </label>
  <label for="invert-yaw">
    <input id="invert-yaw" type="checkbox"> Invert Yaw
  </label>

  <!-- Apply Button -->
  <button id="apply-settings">Apply</button>
</div>

<style>
  #settings-menu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    z-index: 1001;
  }

  #settings-menu.hidden {
    display: none;
  }

  #settings-menu h3 {
    margin-top: 0;
    text-align: center;
  }

  #settings-menu label, #settings-menu select, #settings-menu input, #settings-menu button {
    display: block;
    margin: 10px auto;
    width: 80%;
  }
</style>
let controlScheme = 'keyboard'; // Default control scheme
let sensitivity = 1; // Default sensitivity
let invertPitch = false;
let invertRoll = false;
let invertYaw = false;

// Handle settings application
document.getElementById('apply-settings').addEventListener('click', () => {
  controlScheme = document.getElementById('control-scheme').value;
  sensitivity = parseFloat(document.getElementById('sensitivity').value);
  invertPitch = document.getElementById('invert-pitch').checked;
  invertRoll = document.getElementById('invert-roll').checked;
  invertYaw = document.getElementById('invert-yaw').checked;

  alert(`Settings applied:
    Control Scheme: ${controlScheme}
    Sensitivity: ${sensitivity}
    Invert Pitch: ${invertPitch}
    Invert Roll: ${invertRoll}
    Invert Yaw: ${invertYaw}`);
  
  document.getElementById('settings-menu').classList.add('hidden');
});
// Keyboard Controls
function handleKeyboardInput(event) {
  const pitchFactor = invertPitch ? -1 : 1;
  const rollFactor = invertRoll ? -1 : 1;

  switch (event.code) {
    case 'ArrowUp': pitch = 0.02 * sensitivity * pitchFactor; break;
    case 'ArrowDown': pitch = -0.02 * sensitivity * pitchFactor; break;
    case 'ArrowLeft': roll = 0.02 * sensitivity * rollFactor; break;
    case 'ArrowRight': roll = -0.02 * sensitivity * rollFactor; break;
    case 'KeyW': speed += 0.01 * sensitivity; break;
    case 'KeyS': speed -= 0.01 * sensitivity; break;
  }
}

// Mouse Controls
function handleMouseInput(event) {
  const pitchFactor = invertPitch ? -1 : 1;
  const rollFactor = invertRoll ? -1 : 1;

  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;

  pitch = (centerY - event.clientY) * 0.0001 * sensitivity * pitchFactor;
  roll = (centerX - event.clientX) * 0.0001 * sensitivity * rollFactor;
}

// Gamepad Controls
function handleGamepadInput() {
  const gamepad = navigator.getGamepads()[0];
  if (gamepad) {
    const pitchFactor = invertPitch ? -1 : 1;
    const rollFactor = invertRoll ? -1 : 1;
    const yawFactor = invertYaw ? -1 : 1;

    pitch = gamepad.axes[1] * 0.02 * sensitivity * pitchFactor; // Vertical axis for pitch
    roll = gamepad.axes[0] * 0.02 * sensitivity * rollFactor;  // Horizontal axis for roll
    speed += gamepad.buttons[7].value * 0.01 * sensitivity; // Right trigger for throttle
    speed -= gamepad.buttons[6].value * 0.01 * sensitivity; // Left trigger for brake
  }
}

// Main Input Handler
function handleInput(event) {
  if (controlScheme === 'keyboard') {
    handleKeyboardInput(event);
  } else if (controlScheme === 'mouse') {
    document.addEventListener('mousemove', handleMouseInput);
  } else if (controlScheme === 'gamepad') {
    handleGamepadInput();
  }
}

// Add Event Listeners
document.addEventListener('keydown', handleInput);
document.addEventListener('keyup', (event) => {
  if (['ArrowUp', 'ArrowDown'].includes(event.code)) pitch = 0;
  if (['ArrowLeft', 'ArrowRight'].includes(event.code)) roll = 0;
});
document.getElementById('settings-btn').addEventListener('click', () => {
  const settingsMenu = document.getElementById('settings-menu');
  settingsMenu.classList.toggle('hidden');
});
<!-- Settings Menu -->
<div id="settings-menu" class="hidden">
  <h3>Settings</h3>
  
  <!-- Control Scheme -->
  <label for="control-scheme">Control Scheme:</label>
  <select id="control-scheme">
    <option value="keyboard">Keyboard</option>
    <option value="mouse">Mouse</option>
    <option value="gamepad">Gamepad</option>
  </select>

  <!-- Sensitivity -->
  <label for="sensitivity">Sensitivity:</label>
  <input id="sensitivity" type="range" min="0.1" max="2" step="0.1" value="1">

  <!-- Invert Pitch/Roll/Yaw -->
  <label for="invert-pitch">
    <input id="invert-pitch" type="checkbox"> Invert Pitch
  </label>
  <label for="invert-roll">
    <input id="invert-roll" type="checkbox"> Invert Roll
  </label>
  <label for="invert-yaw">
    <input id="invert-yaw" type="checkbox"> Invert Yaw
  </label>

  <!-- Graphics Settings -->
  <h4>Graphics Settings</h4>
  <label for="graphics-quality">Graphics Quality:</label>
  <select id="graphics-quality">
    <option value="low">Low</option>
    <option value="medium">Medium</option>
    <option value="high">High</option>
    <option value="max">Max</option>
  </select>

  <label for="runway-overlays">
    <input id="runway-overlays" type="checkbox" checked> Enable Runway Overlays
  </label>

  <!-- Apply Button -->
  <button id="apply-settings">Apply</button>
</div>

<style>
  #settings-menu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    z-index: 1001;
  }

  #settings-menu.hidden {
    display: none;
  }

  #settings-menu h3, #settings-menu h4 {
    margin-top: 0;
    text-align: center;
  }

  #settings-menu label, #settings-menu select, #settings-menu input, #settings-menu button {
    display: block;
    margin: 10px auto;
    width: 80%;
  }
</style>
let graphicsQuality = 'high'; // Default graphics quality
let runwayOverlaysEnabled = true; // Default runway overlays state

// Handle settings application
document.getElementById('apply-settings').addEventListener('click', () => {
  // Retrieve control settings
  controlScheme = document.getElementById('control-scheme').value;
  sensitivity = parseFloat(document.getElementById('sensitivity').value);
  invertPitch = document.getElementById('invert-pitch').checked;
  invertRoll = document.getElementById('invert-roll').checked;
  invertYaw = document.getElementById('invert-yaw').checked;

  // Retrieve graphics settings
  graphicsQuality = document.getElementById('graphics-quality').value;
  runwayOverlaysEnabled = document.getElementById('runway-overlays').checked;

  // Apply graphics settings
  applyGraphicsSettings();

  alert(`Settings applied:
    Control Scheme: ${controlScheme}
    Sensitivity: ${sensitivity}
    Invert Pitch: ${invertPitch}
    Invert Roll: ${invertRoll}
    Invert Yaw: ${invertYaw}
    Graphics Quality: ${graphicsQuality}
    Runway Overlays: ${runwayOverlaysEnabled ? 'Enabled' : 'Disabled'}`);
  
  document.getElementById('settings-menu').classList.add('hidden');
});

// Apply graphics settings
function applyGraphicsSettings() {
  switch (graphicsQuality) {
    case 'low':
      renderer.setPixelRatio(0.5); // Lower resolution
      renderer.shadowMap.enabled = false; // Disable shadows
      break;
    case 'medium':
      renderer.setPixelRatio(1); // Normal resolution
      renderer.shadowMap.enabled = false; // Disable shadows
      break;
    case 'high':
      renderer.setPixelRatio(1.5); // Higher resolution
      renderer.shadowMap.enabled = true; // Enable shadows
      break;
    case 'max':
      renderer.setPixelRatio(2); // Maximum resolution
      renderer.shadowMap.enabled = true; // Enable shadows
      break;
  }

  // Toggle runway overlays
  const runwayOverlays = document.querySelectorAll('.runway-overlay');
  runwayOverlays.forEach((overlay) => {
    overlay.style.display = runwayOverlaysEnabled ? 'block' : 'none';
  });
}
// Example: Add runway overlays
function createRunwayOverlay(position) {
  const overlay = document.createElement('div');
  overlay.className = 'runway-overlay';
  overlay.style.position = 'absolute';
  overlay.style.width = '100px';
  overlay.style.height = '20px';
  overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
  overlay.style.border = '1px solid black';
  overlay.style.left = `${position.x}px`;
  overlay.style.top = `${position.y}px`;
  document.body.appendChild(overlay);
}

// Example: Create a runway overlay
createRunwayOverlay({ x: 200, y: 300 });
.runway-overlay {
  display: block;
  position: absolute;
  background-color: rgba(255, 255, 255, 0.5);
  border: 1px solid black;
}
document.getElementById('settings-btn').addEventListener('click', () => {
  const settingsMenu = document.getElementById('settings-menu');
  settingsMenu.classList.toggle('hidden');
});

function createAirplane({ fuselageColor, wingColor, scale, position }) {
  const airplane = new THREE.Group();

  // Fuselage
  const fuselageGeometry = new THREE.CylinderGeometry(0.3, 0.3, 6, 32);
  const fuselageMaterial = new THREE.MeshStandardMaterial({ color: fuselageColor });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2; // Align with x-axis
  airplane.add(fuselage);

  // Wings
  const wingGeometry = new THREE.BoxGeometry(6, 0.2, 1);
  const wingMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0.5, 0);
  airplane.add(wing);

  // Tail
  const tailGeometry = new THREE.BoxGeometry(1, 0.5, 0.2);
  const tailMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(3, 0.5, 0);
  airplane.add(tail);

  // Scale and position
  airplane.scale.set(scale, scale, scale);
  airplane.position.set(position.x, position.y, position.z);

  return airplane;
}
// Add airplanes to the scene
const airplane1 = createAirplane({
  fuselageColor: 0xff0000, // Red
  wingColor: 0x0000ff, // Blue
  scale: 1,
  position: { x: 0, y: 1, z: 0 },
});
scene.add(airplane1);

const airplane2 = createAirplane({
  fuselageColor: 0x00ff00, // Green
  wingColor: 0xffff00, // Yellow
  scale: 0.8,
  position: { x: 10, y: 1, z: -20 },
});
scene.add(airplane2);

const airplane3 = createAirplane({
  fuselageColor: 0x555555, // Gray
  wingColor: 0xffffff, // White
  scale: 1.2,
  position: { x: -15, y: 1, z: 10 },
});
scene.add(airplane3);
function createFighterJet({ fuselageColor, wingColor, position }) {
  const jet = new THREE.Group();

  // Fuselage
  const fuselageGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 32);
  const fuselageMaterial = new THREE.MeshStandardMaterial({ color: fuselageColor });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2;
  jet.add(fuselage);

  // Wings
  const wingGeometry = new THREE.BoxGeometry(4, 0.1, 1);
  const wingMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0.5, 0);
  jet.add(wing);

  // Tail
  const tailGeometry = new THREE.BoxGeometry(1, 0.5, 0.2);
  const tailMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(2.5, 0.5, 0);
  jet.add(tail);

  // Position
  jet.position.set(position.x, position.y, position.z);

  return jet;
}

// Add fighter jet
const fighterJet = createFighterJet({
  fuselageColor: 0x333333, // Dark gray
  wingColor: 0xff4500, // Orange
  position: { x: 20, y: 2, z: -10 },
});
scene.add(fighterJet);
function spawnAirplanes(count) {
  for (let i = 0; i < count; i++) {
    const airplane = createAirplane({
      fuselageColor: Math.random() * 0xffffff, // Random color
      wingColor: Math.random() * 0xffffff,
      scale: Math.random() * 0.5 + 0.5, // Random scale
      position: {
        x: Math.random() * 100 - 50,
        y: Math.random() * 10 + 1,
        z: Math.random() * 100 - 50,
      },
    });
    scene.add(airplane);
  }
}

// Spawn 10 airplanes
spawnAirplanes(10);
function animateAirplanes() {
  scene.children.forEach((child) => {
    if (child.isGroup) {
      child.position.z -= 0.1; // Move forward
      if (child.position.z < -50) {
        child.position.z = 50; // Reset position
      }
    }
  });
}

// Add to animation loop
function animate() {
  requestAnimationFrame(animate);

  animateAirplanes();

  renderer.render(scene, camera);
}

animate();
function createBoeing({ model, fuselageColor, wingColor, engineColor, position }) {
  const airplane = new THREE.Group();

  // Fuselage
  const fuselageLength = model === '737' ? 30 : model === '767' ? 50 : model === '777' ? 60 : 65;
  const fuselageRadius = model === '737' ? 1.5 : model === '767' ? 2 : model === '777' ? 2.5 : 2.8;
  const fuselageGeometry = new THREE.CylinderGeometry(fuselageRadius, fuselageRadius, fuselageLength, 32);
  const fuselageMaterial = new THREE.MeshStandardMaterial({ color: fuselageColor });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2; // Align with x-axis
  airplane.add(fuselage);

  // Wings
  const wingSpan = model === '737' ? 35 : model === '767' ? 50 : model === '777' ? 60 : 65;
  const wingGeometry = new THREE.BoxGeometry(wingSpan, 0.5, 5);
  const wingMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0, 0);
  airplane.add(wing);

  // Engines
  const engineCount = model === '737' ? 2 : model === '767' ? 2 : model === '777' ? 2 : 2;
  const engineRadius = model === '737' ? 1 : model === '767' ? 1.2 : model === '777' ? 1.5 : 1.8;
  const engineGeometry = new THREE.CylinderGeometry(engineRadius, engineRadius, 3, 32);
  const engineMaterial = new THREE.MeshStandardMaterial({ color: engineColor });

  for (let i = 0; i < engineCount; i++) {
    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
    engine.rotation.z = Math.PI / 2; // Align with wings
    engine.position.set(0, -1.5, i === 0 ? 10 : -10); // Position engines symmetrically
    airplane.add(engine);
  }

  // Tail
  const tailGeometry = new THREE.BoxGeometry(3, 8, 1);
  const tailMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(fuselageLength / 2 - 5, 4, 0); // Position at the rear
  airplane.add(tail);

  // Position the airplane
  airplane.position.set(position.x, position.y, position.z);

  return airplane;
}
// Boeing 737
const boeing737 = createBoeing({
  model: '737',
  fuselageColor: 0x888888, // Light gray
  wingColor: 0xffffff, // White
  engineColor: 0x333333, // Dark gray
  position: { x: 0, y: 2, z: 0 },
});
scene.add(boeing737);

// Boeing 767
const boeing767 = createBoeing({
  model: '767',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: 50, y: 2, z: -20 },
});
scene.add(boeing767);

// Boeing 777
const boeing777 = createBoeing({
  model: '777',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: -50, y: 2, z: 20 },
});
scene.add(boeing777);

// Boeing 787
const boeing787 = createBoeing({
  model: '787',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: 100, y: 2, z: -50 },
});
scene.add(boeing787);
function animateEngines() {
  scene.children.forEach((child) => {
    if (child.isGroup) {
      child.children.forEach((part) => {
        if (part.geometry.type === 'CylinderGeometry') {
          part.rotation.x += 0.1; // Rotate engines
        }
      });
    }
  });
}
function animateAirplanes() {
  scene.children.forEach((child) => {
    if (child.isGroup) {
      child.position.z -= 0.1; // Move forward
      if (child.position.z < -100) {
        child.position.z = 100; // Reset position
      }
    }
  });
}
function animate() {
  requestAnimationFrame(animate);

  animateEngines();
  animateAirplanes();

  renderer.render(scene, camera);
}

animate();
function createDetailedBoeing({ model, fuselageTexture, wingTexture, engineTexture, position }) {
  const airplane = new THREE.Group();

  // Fuselage
  const fuselageLength = model === '737' ? 30 : model === '767' ? 50 : model === '777' ? 60 : 65;
  const fuselageRadius = model === '737' ? 1.5 : model === '767' ? 2 : model === '777' ? 2.5 : 2.8;
  const fuselageGeometry = new THREE.CylinderGeometry(fuselageRadius, fuselageRadius, fuselageLength, 64);
  const fuselageMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load(fuselageTexture),
    metalness: 0.3,
    roughness: 0.6,
  });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2; // Align with x-axis
  airplane.add(fuselage);

  // Wings
  const wingSpan = model === '737' ? 35 : model === '767' ? 50 : model === '777' ? 60 : 65;
  const wingGeometry = new THREE.BoxGeometry(wingSpan, 0.5, 5);
  const wingMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load(wingTexture),
    metalness: 0.2,
    roughness: 0.7,
  });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0, 0);
  airplane.add(wing);

  // Winglets
  const wingletGeometry = new THREE.BoxGeometry(0.2, 2, 0.5);
  const wingletMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const leftWinglet = new THREE.Mesh(wingletGeometry, wingletMaterial);
  leftWinglet.position.set(-wingSpan / 2, 1, 2.5);
  leftWinglet.rotation.z = Math.PI / 6;
  airplane.add(leftWinglet);

  const rightWinglet = new THREE.Mesh(wingletGeometry, wingletMaterial);
  rightWinglet.position.set(wingSpan / 2, 1, -2.5);
  rightWinglet.rotation.z = -Math.PI / 6;
  airplane.add(rightWinglet);

  // Engines
  const engineCount = 2;
  const engineRadius = model === '737' ? 1 : model === '767' ? 1.2 : model === '777' ? 1.5 : 1.8;
  const engineGeometry = new THREE.CylinderGeometry(engineRadius, engineRadius, 3, 64);
  const engineMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load(engineTexture),
    metalness: 0.4,
    roughness: 0.5,
  });

  for (let i = 0; i < engineCount; i++) {
    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
    engine.rotation.z = Math.PI / 2; // Align with wings
    engine.position.set(0, -1.5, i === 0 ? 10 : -10); // Position engines symmetrically
    airplane.add(engine);

    // Add rotating fan blades
    const fanGeometry = new THREE.CylinderGeometry(engineRadius * 0.8, engineRadius * 0.8, 0.1, 32);
    const fanMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const fan = new THREE.Mesh(fanGeometry, fanMaterial);
    fan.position.set(0, 0, 1.5); // Front of the engine
    engine.add(fan);

    // Animate fan rotation
    airplane.userData.engines = airplane.userData.engines || [];
    airplane.userData.engines.push(fan);
  }

  // Tail
  const tailGeometry = new THREE.BoxGeometry(3, 8, 1);
  const tailMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(fuselageLength / 2 - 5, 4, 0); // Position at the rear
  airplane.add(tail);

  // Lights
  const lightMaterial = new THREE.MeshStandardMaterial({ emissive: 0xff0000, emissiveIntensity: 1 });
  const navLight = new THREE.SphereGeometry(0.2, 16, 16);
  const leftNavLight = new THREE.Mesh(navLight, lightMaterial);
  leftNavLight.position.set(-wingSpan / 2, 0, 2.5);
  airplane.add(leftNavLight);

  const rightNavLight = new THREE.Mesh(navLight, lightMaterial);
  rightNavLight.position.set(wingSpan / 2, 0, -2.5);
  airplane.add(rightNavLight);

  // Position the airplane
  airplane.position.set(position.x, position.y, position.z);

  return airplane;
}

// Create Boeing Models
const boeing737 = createDetailedBoeing({
  model: '737',
  fuselageTexture: 'textures/737-fuselage.jpg',
  wingTexture: 'textures/737-wing.jpg',
  engineTexture: 'textures/737-engine.jpg',
  position: { x: 0, y: 2, z: 0 },
});
scene.add(boeing737);

const boeing767 = createDetailedBoeing({
  model: '767',
  fuselageTexture: 'textures/767-fuselage.jpg',
  wingTexture: 'textures/767-wing.jpg',
  engineTexture: 'textures/767-engine.jpg',
  position: { x: 50, y: 2, z: -20 },
});
scene.add(boeing767);

const boeing777 = createDetailedBoeing({
  model: '777',
  fuselageTexture: 'textures/777-fuselage.jpg',
  wingTexture: 'textures/777-wing.jpg',
  engineTexture: 'textures/777-engine.jpg',
  position: { x: -50, y: 2, z: 20 },
});
scene.add(boeing777);

const boeing787 = createDetailedBoeing({
  model: '787',
  fuselageTexture: 'textures/787-fuselage.jpg',
  wingTexture: 'textures/787-wing.jpg',
  engineTexture: 'textures/787-engine.jpg',
  position: { x: 100, y: 2, z: -50 },
});
scene.add(boeing787);

// Animate Engines
function animateEngines() {
  [boeing737, boeing767, boeing777, boeing787].forEach((airplane) => {
    airplane.userData.engines.forEach((fan) => {
      fan.rotation.z += 0.2; // Rotate fan blades
    });
  });
}

// Main Animation Loop
function animate() {
  requestAnimationFrame(animate);

  animateEngines();

  renderer.render(scene, camera);
}

animate();
function createDetailedBoeing({ model, fuselageTexture, wingTexture, engineTexture, position }) {
  const airplane = new THREE.Group();

  // Fuselage
  const fuselageLength = model === '737' || model === '737 MAX' ? 30 :
                         model === '767' ? 50 :
                         model === '777' || model === '777X' ? 60 : 65;
  const fuselageRadius = model === '737' || model === '737 MAX' ? 1.5 :
                         model === '767' ? 2 :
                         model === '777' || model === '777X' ? 2.5 : 2.8;
  const fuselageGeometry = new THREE.CylinderGeometry(fuselageRadius, fuselageRadius, fuselageLength, 64);
  const fuselageMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load(fuselageTexture),
    metalness: 0.3,
    roughness: 0.6,
  });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2; // Align with x-axis
  airplane.add(fuselage);

  // Wings
  const wingSpan = model === '737' || model === '737 MAX' ? 35 :
                   model === '767' ? 50 :
                   model === '777' || model === '777X' ? 60 : 65;
  const wingGeometry = new THREE.BoxGeometry(wingSpan, 0.5, 5);
  const wingMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load(wingTexture),
    metalness: 0.2,
    roughness: 0.7,
  });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0, 0);
  airplane.add(wing);

  // Winglets or Foldable Wingtips
  if (model === '737 MAX') {
    // Split winglets for 737 MAX
    const wingletGeometry = new THREE.BoxGeometry(0.2, 2, 0.5);
    const wingletMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });

    const upperWinglet = new THREE.Mesh(wingletGeometry, wingletMaterial);
    upperWinglet.position.set(-wingSpan / 2, 1, 2.5);
    upperWinglet.rotation.z = Math.PI / 6;
    airplane.add(upperWinglet);

    const lowerWinglet = new THREE.Mesh(wingletGeometry, wingletMaterial);
    lowerWinglet.position.set(-wingSpan / 2, -1, 2.5);
    lowerWinglet.rotation.z = -Math.PI / 6;
    airplane.add(lowerWinglet);

    const rightUpperWinglet = upperWinglet.clone();
    rightUpperWinglet.position.set(wingSpan / 2, 1, -2.5);
    rightUpperWinglet.rotation.z = -Math.PI / 6;
    airplane.add(rightUpperWinglet);

    const rightLowerWinglet = lowerWinglet.clone();
    rightLowerWinglet.position.set(wingSpan / 2, -1, -2.5);
    rightLowerWinglet.rotation.z = Math.PI / 6;
    airplane.add(rightLowerWinglet);
  } else if (model === '777X') {
    // Foldable wingtips for 777X
    const wingtipGeometry = new THREE.BoxGeometry(0.5, 5, 1);
    const wingtipMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });

    const leftWingtip = new THREE.Mesh(wingtipGeometry, wingtipMaterial);
    leftWingtip.position.set(-wingSpan / 2, 0, 0);
    leftWingtip.rotation.z = Math.PI / 4; // Folded position
    airplane.add(leftWingtip);

    const rightWingtip = new THREE.Mesh(wingtipGeometry, wingtipMaterial);
    rightWingtip.position.set(wingSpan / 2, 0, 0);
    rightWingtip.rotation.z = -Math.PI / 4; // Folded position
    airplane.add(rightWingtip);
  }

  // Engines
  const engineCount = 2;
  const engineRadius = model === '737' || model === '737 MAX' ? 1 :
                       model === '767' ? 1.2 :
                       model === '777' || model === '777X' ? 1.5 : 1.8;
  const engineGeometry = new THREE.CylinderGeometry(engineRadius, engineRadius, 3, 64);
  const engineMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load(engineTexture),
    metalness: 0.4,
    roughness: 0.5,
  });

  for (let i = 0; i < engineCount; i++) {
    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
    engine.rotation.z = Math.PI / 2; // Align with wings
    engine.position.set(0, -1.5, i === 0 ? 10 : -10); // Position engines symmetrically
    airplane.add(engine);

    // Add rotating fan blades
    const fanGeometry = new THREE.CylinderGeometry(engineRadius * 0.8, engineRadius * 0.8, 0.1, 32);
    const fanMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const fan = new THREE.Mesh(fanGeometry, fanMaterial);
    fan.position.set(0, 0, 1.5); // Front of the engine
    engine.add(fan);

    // Animate fan rotation
    airplane.userData.engines = airplane.userData.engines || [];
    airplane.userData.engines.push(fan);
  }

  // Tail
  const tailGeometry = new THREE.BoxGeometry(3, 8, 1);
  const tailMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(fuselageLength / 2 - 5, 4, 0); // Position at the rear
  airplane.add(tail);

  // Lights
  const lightMaterial = new THREE.MeshStandardMaterial({ emissive: 0xff0000, emissiveIntensity: 1 });
  const navLight = new THREE.SphereGeometry(0.2, 16, 16);
  const leftNavLight = new THREE.Mesh(navLight, lightMaterial);
  leftNavLight.position.set(-wingSpan / 2, 0, 2.5);
  airplane.add(leftNavLight);

  const rightNavLight = new THREE.Mesh(navLight, lightMaterial);
  rightNavLight.position.set(wingSpan / 2, 0, -2.5);
  airplane.add(rightNavLight);

  // Position the airplane
  airplane.position.set(position.x, position.y, position.z);

  return airplane;
}

// Add 737 MAX
const boeing737MAX = createDetailedBoeing({
  model: '737 MAX',
  fuselageTexture: 'textures/737MAX-fuselage.jpg',
  wingTexture: 'textures/737MAX-wing.jpg',
  engineTexture: 'textures/737MAX-engine.jpg',
  position: { x: 150, y: 2, z: -30 },
});
scene.add(boeing737MAX);

// Add 777X
const boeing777X = createDetailedBoeing({
  model: '777X',
  fuselageTexture: 'textures/777X-fuselage.jpg',
  wingTexture: 'textures/777X-wing.jpg',
  engineTexture: 'textures/777X-engine.jpg',
  position: { x: -150, y: 2, z: 30 },
});
scene.add(boeing777X);

// Animate Engines
function animateEngines() {
  [boeing737, boeing767, boeing777, boeing787, boeing737MAX, boeing777X].forEach((airplane) => {
    airplane.userData.engines.forEach((fan) => {
      fan.rotation.z += 0.2; // Rotate fan blades
    });
  });
}

// Main Animation Loop
function animate() {
  requestAnimationFrame(animate);

  animateEngines();

  renderer.render(scene, camera);
}

animate();
function createBoeingModel({ model, fuselageColor, wingColor, engineColor, position }) {
  const airplane = new THREE.Group();

  // Define model-specific dimensions
  const dimensions = {
    '707': { length: 46, radius: 2.5, wingSpan: 44, engines: 4 },
    '717': { length: 37, radius: 2.2, wingSpan: 28, engines: 2 },
    '720': { length: 41, radius: 2.4, wingSpan: 40, engines: 4 },
    '727': { length: 46, radius: 2.5, wingSpan: 33, engines: 3 },
    '757': { length: 47, radius: 2.5, wingSpan: 38, engines: 2 },
    '737-200': { length: 30, radius: 1.5, wingSpan: 28, engines: 2 },
    '737-200 ADVANCED': { length: 30, radius: 1.5, wingSpan: 28, engines: 2 },
    '737-400F': { length: 36, radius: 1.5, wingSpan: 28, engines: 2 },
    '737-500': { length: 31, radius: 1.5, wingSpan: 28, engines: 2 },
    '727-200 SUPER27': { length: 46, radius: 2.5, wingSpan: 33, engines: 3 },
    'BBJ': { length: 33, radius: 1.5, wingSpan: 28, engines: 2 },
    'BBJ MAX 8': { length: 39, radius: 1.5, wingSpan: 35, engines: 2 },
    'BBJ': { length: 33, radius: 1.5, wingSpan: 28, engines: 2 },
    'Boeing Business Jets': { length: 33, radius: 1.5, wingSpan: 28, engines: 2 },
    'Boeing Freighters': { length: 50, radius: 2.5, wingSpan: 50, engines: 2 },
  };

  const { length, radius, wingSpan, engines } = dimensions[model] || {
    length: 40,
    radius: 2,
    wingSpan: 30,
    engines: 2,
  };

  // Fuselage
  const fuselageGeometry = new THREE.CylinderGeometry(radius, radius, length, 64);
  const fuselageMaterial = new THREE.MeshStandardMaterial({ color: fuselageColor });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2; // Align with x-axis
  airplane.add(fuselage);

  // Wings
  const wingGeometry = new THREE.BoxGeometry(wingSpan, 0.5, 5);
  const wingMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0, 0);
  airplane.add(wing);

  // Engines
  const engineGeometry = new THREE.CylinderGeometry(radius * 0.5, radius * 0.5, 3, 32);
  const engineMaterial = new THREE.MeshStandardMaterial({ color: engineColor });

  for (let i = 0; i < engines; i++) {
    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
    engine.rotation.z = Math.PI / 2; // Align with wings
    engine.position.set(
      0,
      -1.5,
      engines === 4
        ? i < 2
          ? 10 + i * 5
          : -10 - (i - 2) * 5
        : i === 0
        ? 10
        : -10
    ); // Position engines symmetrically
    airplane.add(engine);
  }

  // Tail
  const tailGeometry = new THREE.BoxGeometry(3, 8, 1);
  const tailMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(length / 2 - 5, 4, 0); // Position at the rear
  airplane.add(tail);

  // Position the airplane
  airplane.position.set(position.x, position.y, position.z);

  return airplane;
}

// Add Boeing Models
const boeing707 = createBoeingModel({
  model: '707',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: -100, y: 2, z: 0 },
});
scene.add(boeing707);

const boeing717 = createBoeingModel({
  model: '717',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: -50, y: 2, z: 20 },
});
scene.add(boeing717);

const boeing720 = createBoeingModel({
  model: '720',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: 0, y: 2, z: 40 },
});
scene.add(boeing720);

const boeing727 = createBoeingModel({
  model: '727',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: 50, y: 2, z: 60 },
});
scene.add(boeing727);

const boeing757 = createBoeingModel({
  model: '757',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: 100, y: 2, z: 80 },
});
scene.add(boeing757);

const boeingFreighter = createBoeingModel({
  model: 'Boeing Freighters',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: 150, y: 2, z: 100 },
});
scene.add(boeingFreighter);

// Add BBJ Models
const bbj = createBoeingModel({
  model: 'BBJ',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: 200, y: 2, z: 120 },
});
scene.add(bbj);

const bbjMax8 = createBoeingModel({
  model: 'BBJ MAX 8',
  fuselageColor: 0x888888,
  wingColor: 0xffffff,
  engineColor: 0x333333,
  position: { x: 250, y: 2, z: 140 },
});
scene.add(bbjMax8);

// Animation Loop
function animate() {
  requestAnimationFrame(animate);

  renderer.render(scene, camera);
}

animate();
function createHighDetailBoeing({ model, textures, position }) {
  const airplane = new THREE.Group();

  // Load textures
  const textureLoader = new THREE.TextureLoader();
  const fuselageTexture = textureLoader.load(textures.fuselage);
  const wingTexture = textureLoader.load(textures.wing);
  const engineTexture = textureLoader.load(textures.engine);
  const normalMap = textureLoader.load(textures.normalMap);

  // Fuselage
  const fuselageLength = model === '737' ? 30 : model === '767' ? 50 : model === '777' ? 60 : 65;
  const fuselageRadius = model === '737' ? 1.5 : model === '767' ? 2 : model === '777' ? 2.5 : 2.8;
  const fuselageGeometry = new THREE.CylinderGeometry(fuselageRadius, fuselageRadius, fuselageLength, 128);
  const fuselageMaterial = new THREE.MeshPhysicalMaterial({
    map: fuselageTexture,
    normalMap: normalMap,
    metalness: 0.5,
    roughness: 0.3,
    clearcoat: 1.0,
    clearcoatRoughness: 0.1,
  });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2; // Align with x-axis
  airplane.add(fuselage);

  // Wings
  const wingSpan = model === '737' ? 35 : model === '767' ? 50 : model === '777' ? 60 : 65;
  const wingGeometry = new THREE.BoxGeometry(wingSpan, 0.5, 5);
  const wingMaterial = new THREE.MeshPhysicalMaterial({
    map: wingTexture,
    normalMap: normalMap,
    metalness: 0.4,
    roughness: 0.5,
  });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0, 0);
  airplane.add(wing);

  // Engines
  const engineCount = 2;
  const engineRadius = model === '737' ? 1 : model === '767' ? 1.2 : model === '777' ? 1.5 : 1.8;
  const engineGeometry = new THREE.CylinderGeometry(engineRadius, engineRadius, 3, 64);
  const engineMaterial = new THREE.MeshPhysicalMaterial({
    map: engineTexture,
    normalMap: normalMap,
    metalness: 0.6,
    roughness: 0.4,
  });

  for (let i = 0; i < engineCount; i++) {
    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
    engine.rotation.z = Math.PI / 2; // Align with wings
    engine.position.set(0, -1.5, i === 0 ? 10 : -10); // Position engines symmetrically
    airplane.add(engine);

    // Add rotating fan blades
    const fanGeometry = new THREE.CylinderGeometry(engineRadius * 0.8, engineRadius * 0.8, 0.1, 64);
    const fanMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const fan = new THREE.Mesh(fanGeometry, fanMaterial);
    fan.position.set(0, 0, 1.5); // Front of the engine
    engine.add(fan);

    // Animate fan rotation
    airplane.userData.engines = airplane.userData.engines || [];
    airplane.userData.engines.push(fan);
  }

  // Tail
  const tailGeometry = new THREE.BoxGeometry(3, 8, 1);
  const tailMaterial = new THREE.MeshPhysicalMaterial({
    map: wingTexture,
    normalMap: normalMap,
    metalness: 0.4,
    roughness: 0.5,
  });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(fuselageLength / 2 - 5, 4, 0); // Position at the rear
  airplane.add(tail);

  // Lights
  const lightMaterial = new THREE.MeshStandardMaterial({ emissive: 0xff0000, emissiveIntensity: 1 });
  const navLight = new THREE.SphereGeometry(0.2, 16, 16);
  const leftNavLight = new THREE.Mesh(navLight, lightMaterial);
  leftNavLight.position.set(-wingSpan / 2, 0, 2.5);
  airplane.add(leftNavLight);

  const rightNavLight = new THREE.Mesh(navLight, lightMaterial);
  rightNavLight.position.set(wingSpan / 2, 0, -2.5);
  airplane.add(rightNavLight);

  // Position the airplane
  airplane.position.set(position.x, position.y, position.z);

  return airplane;
}

// Add High-Detail Boeing 737
const boeing737HD = createHighDetailBoeing({
  model: '737',
  textures: {
    fuselage: 'textures/737-fuselage-HD.jpg',
    wing: 'textures/737-wing-HD.jpg',
    engine: 'textures/737-engine-HD.jpg',
    normalMap: 'textures/737-normalMap.jpg',
  },
  position: { x: 0, y: 2, z: 0 },
});
scene.add(boeing737HD);

// Animate Engines
function animateEngines() {
  [boeing737HD].forEach((airplane) => {
    airplane.userData.engines.forEach((fan) => {
      fan.rotation.z += 0.2; // Rotate fan blades
    });
  });
}

// Main Animation Loop
function animate() {
  requestAnimationFrame(animate);

  animateEngines();

  renderer.render(scene, camera);
}

animate();
function addControlSurfaces(airplane) {
  const spoilerGeometry = new THREE.BoxGeometry(1, 0.1, 0.5);
  const flapGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.5);
  const controlMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });

  // Spoilers
  const leftSpoiler = new THREE.Mesh(spoilerGeometry, controlMaterial);
  leftSpoiler.position.set(-5, 0.5, 2.5); // Left wing
  leftSpoiler.rotation.x = Math.PI / 6; // Default spoiler angle
  airplane.add(leftSpoiler);

  const rightSpoiler = new THREE.Mesh(spoilerGeometry, controlMaterial);
  rightSpoiler.position.set(5, 0.5, -2.5); // Right wing
  rightSpoiler.rotation.x = Math.PI / 6;
  airplane.add(rightSpoiler);

  // Flaps
  const leftFlap = new THREE.Mesh(flapGeometry, controlMaterial);
  leftFlap.position.set(-5, -0.5, 2.5); // Left wing trailing edge
  leftFlap.rotation.x = -Math.PI / 12; // Default flap angle
  airplane.add(leftFlap);

  const rightFlap = new THREE.Mesh(flapGeometry, controlMaterial);
  rightFlap.position.set(5, -0.5, -2.5); // Right wing trailing edge
  rightFlap.rotation.x = -Math.PI / 12;
  airplane.add(rightFlap);

  // Store control surfaces for animation
  airplane.userData.spoilers = [leftSpoiler, rightSpoiler];
  airplane.userData.flaps = [leftFlap, rightFlap];
}

function addLandingGearControls(airplane) {
  // Add brakes and steering
  airplane.userData.brakes = false;
  airplane.userData.steering = 0; // Yaw rotation for steering
}

function animateControlSurfaces(airplane) {
  // Animate spoilers
  airplane.userData.spoilers.forEach((spoiler) => {
    spoiler.rotation.x = airplane.userData.spoilersActive ? Math.PI / 4 : Math.PI / 6; // Deploy or retract
  });

  // Animate flaps
  airplane.userData.flaps.forEach((flap) => {
    flap.rotation.x = airplane.userData.flapsActive ? -Math.PI / 6 : -Math.PI / 12; // Deploy or retract
  });
}

function animateLandingGear(airplane) {
  // Apply brakes
  if (airplane.userData.brakes) {
    airplane.userData.speed = Math.max(0, airplane.userData.speed - 0.01); // Reduce speed
  }

  // Apply steering
  airplane.rotation.y += airplane.userData.steering; // Rotate airplane for steering
}

// Add control surfaces and landing gear to all airplanes
[boeing737, boeing767, boeing777, boeing787].forEach((airplane) => {
  addControlSurfaces(airplane);
  addLandingGearControls(airplane);
});

// Handle keyboard input for controls
document.addEventListener('keydown', (event) => {
  switch (event.code) {
    case 'KeyB': // Brakes
      boeing737.userData.brakes = true;
      break;
    case 'KeyS': // Spoilers
      boeing737.userData.spoilersActive = true;
      break;
    case 'KeyF': // Flaps
      boeing737.userData.flapsActive = true;
      break;
    case 'ArrowLeft': // Steering left
      boeing737.userData.steering = 0.02;
      break;
    case 'ArrowRight': // Steering right
      boeing737.userData.steering = -0.02;
      break;
  }
});

document.addEventListener('keyup', (event) => {
  switch (event.code) {
    case 'KeyB': // Brakes
      boeing737.userData.brakes = false;
      break;
    case 'KeyS': // Spoilers
      boeing737.userData.spoilersActive = false;
      break;
    case 'KeyF': // Flaps
      boeing737.userData.flapsActive = false;
      break;
    case 'ArrowLeft': // Stop steering
    case 'ArrowRight':
      boeing737.userData.steering = 0;
      break;
  }
});

// Update animation loop
function animate() {
  requestAnimationFrame(animate);

  // Animate control surfaces and landing gear
  [boeing737, boeing767, boeing777, boeing787].forEach((airplane) => {
    animateControlSurfaces(airplane);
    animateLandingGear(airplane);
  });

  renderer.render(scene, camera);
}

animate();
function createAircraft({ model, fuselageColor, wingColor, engineColor, position }) {
  const airplane = new THREE.Group();

  // Define model-specific dimensions
  const dimensions = {
    '777': { length: 60, radius: 2.5, wingSpan: 60, engines: 2 },
    '787': { length: 65, radius: 2.8, wingSpan: 65, engines: 2 },
    '747-8': { length: 76, radius: 3.5, wingSpan: 68, engines: 4 },
    'A220': { length: 38, radius: 2, wingSpan: 35, engines: 2 },
    'A300': { length: 54, radius: 2.5, wingSpan: 44, engines: 2 },
    'A310': { length: 47, radius: 2.5, wingSpan: 44, engines: 2 },
    'A318': { length: 31, radius: 2, wingSpan: 34, engines: 2 },
    'A319': { length: 34, radius: 2, wingSpan: 34, engines: 2 },
    'A320': { length: 37, radius: 2, wingSpan: 34, engines: 2 },
    'A320neo': { length: 37, radius: 2, wingSpan: 35, engines: 2 },
    'A330': { length: 59, radius: 2.5, wingSpan: 60, engines: 2 },
    'A330neo': { length: 63, radius: 2.5, wingSpan: 64, engines: 2 },
    'A340': { length: 63, radius: 2.5, wingSpan: 60, engines: 4 },
    'A350': { length: 66, radius: 2.8, wingSpan: 65, engines: 2 },
    'A380': { length: 73, radius: 3.5, wingSpan: 79, engines: 4 },
    'A400M': { length: 45, radius: 2.5, wingSpan: 42, engines: 4 },
  };

  const { length, radius, wingSpan, engines } = dimensions[model] || {
    length: 40,
    radius: 2,
    wingSpan: 30,
    engines: 2,
  };

  // Fuselage
  const fuselageGeometry = new THREE.CylinderGeometry(radius, radius, length, 64);
  const fuselageMaterial = new THREE.MeshStandardMaterial({ color: fuselageColor });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2; // Align with x-axis
  airplane.add(fuselage);

  // Wings
  const wingGeometry = new THREE.BoxGeometry(wingSpan, 0.5, 5);
  const wingMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0, 0);
  airplane.add(wing);

  // Engines
  const engineGeometry = new THREE.CylinderGeometry(radius * 0.5, radius * 0.5, 3, 32);
  const engineMaterial = new THREE.MeshStandardMaterial({ color: engineColor });

  for (let i = 0; i < engines; i++) {
    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
    engine.rotation.z = Math.PI / 2; // Align with wings
    engine.position.set(
      0,
      -1.5,
      engines === 4
        ? i < 2
          ? 10 + i * 5
          : -10 - (i - 2) * 5
        : i === 0
        ? 10
        : -10
    ); // Position engines symmetrically
    airplane.add(engine);
  }

  // Tail
  const tailGeometry = new THREE.BoxGeometry(3, 8, 1);
  const tailMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(length / 2 - 5, 4, 0); // Position at the rear
  airplane.add(tail);

  // Position the airplane
  airplane.position.set(position.x, position.y, position.z);

  return airplane;
}

// Add Aircraft Models
const aircraftModels = [
  { model: '777', position: { x: 0, y: 2, z: 0 } },
  { model: '787', position: { x: 50, y: 2, z: -20 } },
  { model: '747-8', position: { x: -50, y: 2, z: 20 } },
  { model: 'A220', position: { x: 100, y: 2, z: -50 } },
  { model: 'A300', position: { x: -100, y: 2, z: 50 } },
  { model: 'A310', position: { x: 150, y: 2, z: -70 } },
  { model: 'A318', position: { x: -150, y: 2, z: 70 } },
  { model: 'A319', position: { x: 200, y: 2, z: -90 } },
  { model: 'A320', position: { x: -200, y: 2, z: 90 } },
  { model: 'A320neo', position: { x: 250, y: 2, z: -110 } },
  { model: 'A330', position: { x: -250, y: 2, z: 110 } },
  { model: 'A330neo', position: { x: 300, y: 2, z: -130 } },
  { model: 'A340', position: { x: -300, y: 2, z: 130 } },
  { model: 'A350', position: { x: 350, y: 2, z: -150 } },
  { model: 'A380', position: { x: -350, y: 2, z: 150 } },
  { model: 'A400M', position: { x: 400, y: 2, z: -170 } },
];

aircraftModels.forEach(({ model, position }) => {
  const airplane = createAircraft({
    model,
    fuselageColor: 0x888888,
    wingColor: 0xffffff,
    engineColor: 0x333333,
    position,
  });
  scene.add(airplane);
});

// Animation Loop
function animate() {
  requestAnimationFrame(animate);

  renderer.render(scene, camera);
}

animate();
<!-- Settings Menu -->
<div id="settings-menu" class="hidden">
  <h3>Settings</h3>
  
  <!-- Aircraft List -->
  <label for="aircraft-list">Select Aircraft:</label>
  <select id="aircraft-list">
    <option value="777">Boeing 777</option>
    <option value="787">Boeing 787 Dreamliner</option>
    <option value="747-8">Boeing 747-8</option>
    <option value="A220">Airbus A220</option>
    <option value="A300">Airbus A300</option>
    <option value="A310">Airbus A310</option>
    <option value="A318">Airbus A318</option>
    <option value="A319">Airbus A319</option>
    <option value="A320">Airbus A320</option>
    <option value="A320neo">Airbus A320neo</option>
    <option value="A330">Airbus A330</option>
    <option value="A330neo">Airbus A330neo</option>
    <option value="A340">Airbus A340</option>
    <option value="A350">Airbus A350</option>
    <option value="A380">Airbus A380</option>
    <option value="A400M">Airbus A400M</option>
  </select>

  <!-- Apply Button -->
  <button id="apply-settings">Apply</button>
</div>
#settings-menu select {
  display: block;
  margin: 10px auto;
  width: 80%;
  padding: 5px;
  font-size: 14px;
}
// Store the selected aircraft
let selectedAircraft = '777'; // Default aircraft

// Handle aircraft selection
document.getElementById('aircraft-list').addEventListener('change', (event) => {
  selectedAircraft = event.target.value;
  console.log(`Selected Aircraft: ${selectedAircraft}`);
});

// Apply settings
document.getElementById('apply-settings').addEventListener('click', () => {
  alert(`Settings applied! Selected Aircraft: ${selectedAircraft}`);
  document.getElementById('settings-menu').classList.add('hidden');
});
function createAirport({ name, code, position }) {
  const airport = new THREE.Group();

  // Runway
  const runwayGeometry = new THREE.PlaneGeometry(200, 20);
  const runwayMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
  runway.rotation.x = -Math.PI / 2;
  runway.position.set(0, 0, 0);
  airport.add(runway);

  // Runway markings
  const markingGeometry = new THREE.PlaneGeometry(2, 0.5);
  const markingMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  for (let i = -90; i <= 90; i += 10) {
    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
    marking.rotation.x = -Math.PI / 2;
    marking.position.set(i, 0.01, 0);
    airport.add(marking);
  }

  // Terminal
  const terminalGeometry = new THREE.BoxGeometry(30, 10, 10);
  const terminalMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
  const terminal = new THREE.Mesh(terminalGeometry, terminalMaterial);
  terminal.position.set(-50, 5, -20);
  airport.add(terminal);

  // Control tower
  const towerGeometry = new THREE.CylinderGeometry(2, 2, 20, 32);
  const towerMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
  const tower = new THREE.Mesh(towerGeometry, towerMaterial);
  tower.position.set(-60, 10, -20);
  airport.add(tower);

  // Add airport name and code
  const label = document.createElement('div');
  label.style.position = 'absolute';
  label.style.color = 'white';
  label.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
  label.style.padding = '5px';
  label.style.borderRadius = '5px';
  label.innerHTML = `${name} (${code})`;
  document.body.appendChild(label);

  // Position the airport
  airport.position.set(position.x, position.y, position.z);

  return airport;
}

// List of airports
const airports = [
  { name: 'Warsaw – Frederic Chopin Airport', code: 'EPWA', position: { x: 0, y: 0, z: 0 } },
  { name: 'Washington – Dulles International Airport', code: 'KIAD', position: { x: 500, y: 0, z: 0 } },
  { name: 'Washington – Ronald Reagan National Airport', code: 'KDCA', position: { x: 1000, y: 0, z: 0 } },
  { name: 'Waterford Airport', code: 'EIWF', position: { x: 1500, y: 0, z: 0 } },
  { name: 'Waterloo International Airport', code: 'CYKF', position: { x: 2000, y: 0, z: 0 } },
  { name: 'Waterloo Regional Airport', code: 'KALO', position: { x: 2500, y: 0, z: 0 } },
  { name: 'Watertown International Airport', code: 'KART', position: { x: 3000, y: 0, z: 0 } },
  { name: 'Watertown Regional Airport', code: 'KATY', position: { x: 3500, y: 0, z: 0 } },
  { name: 'Weeze Airport', code: 'EDLV', position: { x: 4000, y: 0, z: 0 } },
  { name: 'Wellington International Airport', code: 'NZWN', position: { x: 4500, y: 0, z: 0 } },
  { name: 'Wenatchee – Pangborn Memorial Airport', code: 'KEAT', position: { x: 5000, y: 0, z: 0 } },
  { name: 'Wenzhou Yongqiang Airport', code: 'ZSWZ', position: { x: 5500, y: 0, z: 0 } },
  { name: 'Westerland – Sylt Airport', code: 'EDXW', position: { x: 6000, y: 0, z: 0 } },
  { name: 'Wewak International Airport', code: 'AYWK', position: { x: 6500, y: 0, z: 0 } },
  { name: 'Whitehorse International Airport', code: 'CYXY', position: { x: 7000, y: 0, z: 0 } },
  { name: 'Wichita Mid-Continent Airport', code: 'KICT', position: { x: 7500, y: 0, z: 0 } },
  { name: 'Wick Aerodrome', code: 'EGPC', position: { x: 8000, y: 0, z: 0 } },
  { name: 'Wilkes-Barre/Scranton International Airport', code: 'KAVP', position: { x: 8500, y: 0, z: 0 } },
  { name: 'Williamsport Regional Airport', code: 'KIPT', position: { x: 9000, y: 0, z: 0 } },
];

// Add airports to the scene
airports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});
// Add new airports to the list
const newAirports = [
  { name: 'Wilmington International Airport', code: 'KILM', position: { x: 9500, y: 0, z: 0 } },
  { name: 'Windhoek – Eros Airport', code: 'FYWE', position: { x: 10000, y: 0, z: 0 } },
  { name: 'Windhoek – Hosea Kutako International Airport', code: 'FYWH', position: { x: 10500, y: 0, z: 0 } },
  { name: 'Windsor International Airport', code: 'CYQG', position: { x: 11000, y: 0, z: 0 } },
  { name: 'Windsor Locks – Bradley International Airport', code: 'KBDL', position: { x: 11500, y: 0, z: 0 } },
  { name: 'Winnipeg James Armstrong Richardson International Airport', code: 'CYWG', position: { x: 12000, y: 0, z: 0 } },
  { name: 'Winston-Salem – Smith Reynolds Airport', code: 'KINT', position: { x: 12500, y: 0, z: 0 } },
  { name: 'Worcester Regional Airport', code: 'KORH', position: { x: 13000, y: 0, z: 0 } },
  { name: 'Wroclaw Nicolaus Copernicus Airport', code: 'EPWR', position: { x: 13500, y: 0, z: 0 } },
  { name: 'Wuhan Tianhe Airport', code: 'ZHHH', position: { x: 14000, y: 0, z: 0 } },
  { name: 'Wuxi Shuofang Airport', code: 'ZSWX', position: { x: 14500, y: 0, z: 0 } },
  { name: 'Xangongo Airport', code: 'FNXA', position: { x: 15000, y: 0, z: 0 } },
  { name: 'Xi’an Xianyang International Airport', code: 'ZLXY', position: { x: 15500, y: 0, z: 0 } },
  { name: 'Xiamen Gaoqi Int’l Airport', code: 'ZSAM', position: { x: 16000, y: 0, z: 0 } },
  { name: 'Xining Caojiabu Airport', code: 'ZLXN', position: { x: 16500, y: 0, z: 0 } },
  { name: 'Xishuangbanna Gasa Airport/Jinghong Airport', code: 'ZPJH', position: { x: 17000, y: 0, z: 0 } },
  { name: 'Yakutsk International Airport', code: 'UEEE', position: { x: 17500, y: 0, z: 0 } },
  { name: 'Yamagata Airport', code: 'RJSC', position: { x: 18000, y: 0, z: 0 } },
  { name: 'Yangon International Airport', code: 'VYYY', position: { x: 18500, y: 0, z: 0 } },
  { name: 'Yangyang International Airport', code: 'RKNY', position: { x: 19000, y: 0, z: 0 } },
  { name: 'Yantai – Laishan International Airport', code: 'ZSYT', position: { x: 19500, y: 0, z: 0 } },
  { name: 'Yaoundé Nsimalen International Airport', code: 'FKYS', position: { x: 20000, y: 0, z: 0 } },
  { name: 'Yap International Airport', code: 'PTYA', position: { x: 20500, y: 0, z: 0 } },
];

// Add new airports to the scene
newAirports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});
// Add new airports to the list
const additionalAirports = [
  { name: 'Yekaterinburg – Koltsovo International Airport', code: 'USSS', position: { x: 9500, y: 0, z: 0 } },
  { name: 'Yellowknife Airport', code: 'CYZF', position: { x: 10000, y: 0, z: 0 } },
  { name: 'Yerevan – Zvartnots Airport', code: 'UDYZ', position: { x: 10500, y: 0, z: 0 } },
  { name: 'Yichang Sanxia Airport', code: 'ZHYC', position: { x: 11000, y: 0, z: 0 } },
  { name: 'Yinchuan Hedong Airport', code: 'ZLIC', position: { x: 11500, y: 0, z: 0 } },
  { name: 'Yogyakarta – Adi Sutjipto International Airport', code: 'WIIJ', position: { x: 12000, y: 0, z: 0 } },
  { name: 'Yola Airport', code: 'DNYO', position: { x: 12500, y: 0, z: 0 } },
  { name: 'Youngstown – Warren Regional Airport', code: 'KYNG', position: { x: 13000, y: 0, z: 0 } },
  { name: 'Yuma International Airport', code: 'KYUM', position: { x: 13500, y: 0, z: 0 } },
  { name: 'Yuzhno-Sakhalinsk Airport', code: 'UHSS', position: { x: 14000, y: 0, z: 0 } },
  { name: 'Zacatecas – General Leobardo C Ruiz International Airport', code: 'MMZC', position: { x: 14500, y: 0, z: 0 } },
  { name: 'Zadar Airport', code: 'LDZD', position: { x: 15000, y: 0, z: 0 } },
  { name: 'Zagreb Airport', code: 'LDZA', position: { x: 15500, y: 0, z: 0 } },
  { name: 'Zahedan International Airport', code: 'OIZH', position: { x: 16000, y: 0, z: 0 } },
  { name: 'Zakinthos – Dionysios Solomos Airport', code: 'LGZA', position: { x: 16500, y: 0, z: 0 } },
  { name: 'Zamboanga International Airport', code: 'RPMZ', position: { x: 17000, y: 0, z: 0 } },
  { name: 'Zanzibar International Airport', code: 'HTZA', position: { x: 17500, y: 0, z: 0 } },
  { name: 'Zaporizhzya International Airport', code: 'UKDE', position: { x: 18000, y: 0, z: 0 } },
  { name: 'Zaragoza Airport', code: 'LEZG', position: { x: 18500, y: 0, z: 0 } },
  { name: 'Zenata-Messali El Hadj Airport', code: 'DAON', position: { x: 19000, y: 0, z: 0 } },
  { name: 'Zhengzhou Xinzheng International Airport', code: 'ZHCC', position: { x: 19500, y: 0, z: 0 } },
  { name: 'Zhuhai Airport', code: 'ZGSD', position: { x: 20000, y: 0, z: 0 } },
  { name: 'Zilina Airport', code: 'LZZI', position: { x: 20500, y: 0, z: 0 } },
  { name: 'Zweibrücken Airport', code: 'EDRZ', position: { x: 21000, y: 0, z: 0 } },
  { name: 'Zürich Airport', code: 'LSZH', position: { x: 21500, y: 0, z: 0 } },
];

// Add new airports to the scene
additionalAirports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});
// Add new airports to the list
const additionalAirports = [
  { name: 'Vancouver International Airport', code: 'CYVR', position: { x: 22000, y: 0, z: 0 } },
  { name: 'Varadero-Juan G Gomez Int’l Airport', code: 'MUVR', position: { x: 22500, y: 0, z: 0 } },
  { name: 'Varanasi Airport', code: 'VIBN', position: { x: 23000, y: 0, z: 0 } },
  { name: 'Varkaus Airport', code: 'EFVR', position: { x: 23500, y: 0, z: 0 } },
  { name: 'Varna International Airport Ltd', code: 'LBWN', position: { x: 24000, y: 0, z: 0 } },
  { name: 'Vava’u International Airport', code: 'NFTV', position: { x: 24500, y: 0, z: 0 } },
  { name: 'Venice – Marco Polo International Airport', code: 'LIPZ', position: { x: 25000, y: 0, z: 0 } },
  { name: 'Ventspils International Airport', code: 'EVVA', position: { x: 25500, y: 0, z: 0 } },
  { name: 'Veracruz – General Heriberto Jara International Airport', code: 'MMVR', position: { x: 26000, y: 0, z: 0 } },
  { name: 'Vero Beach Municipal Airport', code: 'KVRB', position: { x: 26500, y: 0, z: 0 } },
  { name: 'Verona – Villafranca Airport', code: 'LIPX', position: { x: 27000, y: 0, z: 0 } },
  { name: 'Vichy – Charmeil Airport', code: 'LFLV', position: { x: 27500, y: 0, z: 0 } },
  { name: 'Victoria Falls Airport', code: 'FVFA', position: { x: 28000, y: 0, z: 0 } },
  { name: 'Victoria International Airport', code: 'CYYJ', position: { x: 28500, y: 0, z: 0 } },
  { name: 'Viedma – Gobernador Castello Airport', code: 'SAVV', position: { x: 29000, y: 0, z: 0 } },
  { name: 'Vienna International Airport', code: 'LOWW', position: { x: 29500, y: 0, z: 0 } },
  { name: 'Vientiane – Wattay International Airport', code: 'VLVT', position: { x: 30000, y: 0, z: 0 } },
  { name: 'Vigo Airport', code: 'LEVX', position: { x: 30500, y: 0, z: 0 } },
  { name: 'Vigra – Alesund Airport', code: 'ENAL', position: { x: 31000, y: 0, z: 0 } },
  { name: 'Villa Reynolds Airport', code: 'SAOR', position: { x: 31500, y: 0, z: 0 } },
  { name: 'Villahermosa – Carlos Rovirosa Pérez International Airport', code: 'MMVA', position: { x: 32000, y: 0, z: 0 } },
  { name: 'Vilnius International Airport', code: 'EYVI', position: { x: 32500, y: 0, z: 0 } },
  { name: 'Virgin Gorda Airport', code: 'TUPW', position: { x: 33000, y: 0, z: 0 } },
  { name: 'Viru Viru International Airport', code: 'SLVR', position: { x: 33500, y: 0, z: 0 } },
  { name: 'Visby Airport', code: 'ESSV', position: { x: 34000, y: 0, z: 0 } },
  { name: 'Vitoria – Goiabeiras Airport', code: 'SBVT', position: { x: 34500, y: 0, z: 0 } },
  { name: 'Vitoria International Airport', code: 'LEVT', position: { x: 35000, y: 0, z: 0 } },
  { name: 'Vladivostok Airport (JSC Vladivostok Air)', code: 'UHWW', position: { x: 35500, y: 0, z: 0 } },
  { name: 'Vodochody Airport', code: 'LKVO', position: { x: 36000, y: 0, z: 0 } },
  { name: 'Vojens – Skrydstrup Airport', code: 'EKSP', position: { x: 36500, y: 0, z: 0 } },
  { name: 'Volgograd International Airport', code: 'URWW', position: { x: 37000, y: 0, z: 0 } },
  { name: 'Växjö Smaland Airport', code: 'ESMX', position: { x: 37500, y: 0, z: 0 } },
  { name: 'Wabush Airport', code: 'CYWK', position: { x: 38000, y: 0, z: 0 } },
  { name: 'Wakkanai Airport', code: 'RJCW', position: { x: 38500, y: 0, z: 0 } },
  { name: 'Wallis Hihifo Airport', code: 'NLWW', position: { x: 39000, y: 0, z: 0 } },
];

// Add new airports to the scene
additionalAirports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});
// Add new airports to the list
const additionalAirports = [
  { name: 'Tulsa International Airport', code: 'KTUL', position: { x: 22000, y: 0, z: 0 } },
  { name: 'Tunis – Carthage International Airport', code: 'DTTA', position: { x: 22500, y: 0, z: 0 } },
  { name: 'Tupelo Regional Airport', code: 'KTUP', position: { x: 23000, y: 0, z: 0 } },
  { name: 'Turbat International Airport', code: 'OPTU', position: { x: 23500, y: 0, z: 0 } },
  { name: 'Turin International Airport', code: 'LIMF', position: { x: 24000, y: 0, z: 0 } },
  { name: 'Turku Airport', code: 'EFTU', position: { x: 24500, y: 0, z: 0 } },
  { name: 'Tuxtla Gutiérrez – Francisco Sarabia – Angel Albino Corzo Airport', code: 'MMTG', position: { x: 25000, y: 0, z: 0 } },
  { name: 'Tuzla International Airport', code: 'LQTZ', position: { x: 25500, y: 0, z: 0 } },
  { name: 'Tweed New Haven Regional Airport', code: 'KHVN', position: { x: 26000, y: 0, z: 0 } },
  { name: 'Tyler Pounds Regional Airport', code: 'KTYR', position: { x: 26500, y: 0, z: 0 } },
  { name: 'Tyumen – Roschino Airport', code: 'USTR', position: { x: 27000, y: 0, z: 0 } },
  { name: 'Ube – Yamaguchi Ube Airport', code: 'RJDC', position: { x: 27500, y: 0, z: 0 } },
  { name: 'Udon Thani International Airport', code: 'VTUD', position: { x: 28000, y: 0, z: 0 } },
  { name: 'Ufa Airport', code: 'UWUU', position: { x: 28500, y: 0, z: 0 } },
  { name: 'Uherské Hradiste – Kunovice Airport', code: 'LKKU', position: { x: 29000, y: 0, z: 0 } },
  { name: 'Ulan Bator – Chinggis Khaan International Airport', code: 'ZMUB', position: { x: 29500, y: 0, z: 0 } },
  { name: 'Ulan-Ude – Lake Baikal Airport', code: 'UIUU', position: { x: 30000, y: 0, z: 0 } },
  { name: 'Ulyanovsk – Vostochny International Airport', code: 'UWLW', position: { x: 30500, y: 0, z: 0 } },
  { name: 'Umeå Airport', code: 'ESNU', position: { x: 31000, y: 0, z: 0 } },
  { name: 'Upington Airport', code: 'FAUP', position: { x: 31500, y: 0, z: 0 } },
  { name: 'Uppsala Airport', code: 'ESCM', position: { x: 32000, y: 0, z: 0 } },
  { name: 'Uruapan – Licenciado Y Gen Ignacio Lopez Rayon Airport', code: 'MMPN', position: { x: 32500, y: 0, z: 0 } },
  { name: 'Urumqi Diwopu International Airport', code: 'ZWWW', position: { x: 33000, y: 0, z: 0 } },
  { name: 'Utica – Oneida County Airport', code: 'KUCA', position: { x: 33500, y: 0, z: 0 } },
  { name: 'Uzhhorod International Airport', code: 'UKLU', position: { x: 34000, y: 0, z: 0 } },
  { name: 'Vaasa Airport', code: 'EFVA', position: { x: 34500, y: 0, z: 0 } },
  { name: 'Vagar Airport', code: 'EKVG', position: { x: 35000, y: 0, z: 0 } },
  { name: 'Val D’Or Regional Airport', code: 'CYVO', position: { x: 35500, y: 0, z: 0 } },
  { name: 'Valdivia Aerodrome – Pichoy', code: 'SCVD', position: { x: 36000, y: 0, z: 0 } },
  { name: 'Valence – Chabeuil Airport', code: 'LFLU', position: { x: 36500, y: 0, z: 0 } },
  { name: 'Valencia – Arturo Michelena International Airport', code: 'SVVA', position: { x: 37000, y: 0, z: 0 } },
  { name: 'Valencia Airport', code: 'LEVC', position: { x: 37500, y: 0, z: 0 } },
];

// Add new airports to the scene
additionalAirports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});
// Add new airports to the list
const additionalAirports = [
  { name: 'Thiruvananthapuram International Airport', code: 'VOTV', position: { x: 39500, y: 0, z: 0 } },
  { name: 'Thisted Airport', code: 'EKTS', position: { x: 40000, y: 0, z: 0 } },
  { name: 'Thunder Bay International Airports Authority Inc', code: 'CYQT', position: { x: 40500, y: 0, z: 0 } },
  { name: 'Tianjin – Binhai International Airport', code: 'ZBTJ', position: { x: 41000, y: 0, z: 0 } },
  { name: 'Tijuana – General Abelardo L Rodriguez International Airport', code: 'MMTJ', position: { x: 41500, y: 0, z: 0 } },
  { name: 'Timbuktu Airport', code: 'GATB', position: { x: 42000, y: 0, z: 0 } },
  { name: 'Timisoara – Traian Vuia International Airport', code: 'LRTR', position: { x: 42500, y: 0, z: 0 } },
  { name: 'Timmins Victor M Power Airport', code: 'CYTS', position: { x: 43000, y: 0, z: 0 } },
  { name: 'Tinian International Airport', code: 'PGWT', position: { x: 43500, y: 0, z: 0 } },
  { name: 'Tioman Airport', code: 'WMBT', position: { x: 44000, y: 0, z: 0 } },
  { name: 'Tirana International Airport', code: 'LATI', position: { x: 44500, y: 0, z: 0 } },
  { name: 'Tiree Airport', code: 'EGPU', position: { x: 45000, y: 0, z: 0 } },
  { name: 'Tiruchirapalli Airport', code: 'VOTR', position: { x: 45500, y: 0, z: 0 } },
  { name: 'Toamasina Airport', code: 'FMMT', position: { x: 46000, y: 0, z: 0 } },
  { name: 'Tokoname – Chubu Centrair International Airport', code: 'RJGG', position: { x: 46500, y: 0, z: 0 } },
  { name: 'Tokyo Haneda International Airport', code: 'RJTT', position: { x: 47000, y: 0, z: 0 } },
  { name: 'Toledo Express Airport', code: 'KTOL', position: { x: 47500, y: 0, z: 0 } },
  { name: 'Toluca – Licenciado Adolfo Lopez Mateos Int’l Airport', code: 'MMTO', position: { x: 48000, y: 0, z: 0 } },
  { name: 'Toronto City Centre Airport', code: 'CYTZ', position: { x: 48500, y: 0, z: 0 } },
  { name: 'Toronto Pearson International Airport', code: 'CYYZ', position: { x: 49000, y: 0, z: 0 } },
  { name: 'Torreon – Francisco Sarabia International Airport', code: 'MMTC', position: { x: 49500, y: 0, z: 0 } },
  { name: 'Toulon – Hyeres International Airport', code: 'LFTH', position: { x: 50000, y: 0, z: 0 } },
  { name: 'Toulouse – Blagnac Airport', code: 'LFBO', position: { x: 50500, y: 0, z: 0 } },
  { name: 'Townsville Int’l Airport', code: 'YBTL', position: { x: 51000, y: 0, z: 0 } },
  { name: 'Toyama Airport', code: 'RJNT', position: { x: 51500, y: 0, z: 0 } },
  { name: 'Tozeur – Nefta International Airport', code: 'DTTZ', position: { x: 52000, y: 0, z: 0 } },
  { name: 'Transilvania Târgu Mures Airport', code: 'LRTM', position: { x: 52500, y: 0, z: 0 } },
  { name: 'Trapani Birgi Airport', code: 'LICT', position: { x: 53000, y: 0, z: 0 } },
  { name: 'Trenton – Mercer Airport', code: 'KTTN', position: { x: 53500, y: 0, z: 0 } },
  { name: 'Treviso Sant’Angelo Airport', code: 'LIPH', position: { x: 54000, y: 0, z: 0 } },
  { name: 'Trieste – Ronchi dei Legionari Airport', code: 'LIPQ', position: { x: 54500, y: 0, z: 0 } },
  { name: 'Tripoli – Mitiga International Airport', code: 'HLLM', position: { x: 55000, y: 0, z: 0 } },
  { name: 'Tripoli International Airport', code: 'HLLT', position: { x: 55500, y: 0, z: 0 } },
  { name: 'Tromsø – Langnes Airport', code: 'ENTC', position: { x: 56000, y: 0, z: 0 } },
  { name: 'Trondheim – Værnes Airport', code: 'ENVA', position: { x: 56500, y: 0, z: 0 } },
  { name: 'Tucson International Airport', code: 'KTUS', position: { x: 57000, y: 0, z: 0 } },
  { name: 'Tucuman International Airport', code: 'SANT', position: { x: 57500, y: 0, z: 0 } },
  { name: 'Tulcea Airport', code: 'LRTC', position: { x: 58000, y: 0, z: 0 } },
];

// Add new airports to the scene
additionalAirports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});
// Add new airports to the list
const additionalAirports = [
  { name: 'Sidney Municipal Airport', code: 'KSNY', position: { x: 60000, y: 0, z: 0 } },
  { name: 'Siem Reap International Airport', code: 'VDSR', position: { x: 60500, y: 0, z: 0 } },
  { name: 'Simferopol International Airport', code: 'UKFF', position: { x: 61000, y: 0, z: 0 } },
  { name: 'Singapore – Changi Airport Group (Singapore) Pte Ltd', code: 'WSSS', position: { x: 61500, y: 0, z: 0 } },
  { name: 'Singapore – Seletar Airport', code: 'WSSL', position: { x: 62000, y: 0, z: 0 } },
  { name: 'Sint Maarten – Princess Juliana Airport', code: 'TNCM', position: { x: 62500, y: 0, z: 0 } },
  { name: 'Sion Airport', code: 'LSGS', position: { x: 63000, y: 0, z: 0 } },
  { name: 'Sioux Falls Airport', code: 'KFSD', position: { x: 63500, y: 0, z: 0 } },
  { name: 'Sioux Gateway Airport – Colonel Bud Day Field', code: 'KSUX', position: { x: 64000, y: 0, z: 0 } },
  { name: 'Sir Seewoosagur Ramgoolam International Airport', code: 'FIMP', position: { x: 64500, y: 0, z: 0 } },
  { name: 'Skellefteå Airport', code: 'ESNS', position: { x: 65000, y: 0, z: 0 } },
  { name: 'Skiathos Island National Airport', code: 'LGSK', position: { x: 65500, y: 0, z: 0 } },
  { name: 'Skien – Geiteryggen Airport', code: 'ENSN', position: { x: 66000, y: 0, z: 0 } },
  { name: 'Skive Airport', code: 'EKSV', position: { x: 66500, y: 0, z: 0 } },
  { name: 'Skopje Alexander the Great Airport', code: 'LWSK', position: { x: 67000, y: 0, z: 0 } },
  { name: 'Sliac Airport', code: 'LZSL', position: { x: 67500, y: 0, z: 0 } },
  { name: 'Sligo Airport', code: 'EISG', position: { x: 68000, y: 0, z: 0 } },
  { name: 'Sofia International Airport EAD', code: 'LBSF', position: { x: 68500, y: 0, z: 0 } },
  { name: 'Sokoto – Saddik Abubakar III International Airport', code: 'DNSO', position: { x: 69000, y: 0, z: 0 } },
  { name: 'Solwezi Airport', code: 'FLSW', position: { x: 69500, y: 0, z: 0 } },
  { name: 'South Bend International Airport', code: 'KSBN', position: { x: 70000, y: 0, z: 0 } },
  { name: 'South Caicos Airport', code: 'MBSC', position: { x: 70500, y: 0, z: 0 } },
  { name: 'Southampton International Airport', code: 'EGHI', position: { x: 71000, y: 0, z: 0 } },
  { name: 'Southern California Logistics Airport', code: 'KVCV', position: { x: 71500, y: 0, z: 0 } },
  { name: 'Split Airport', code: 'LDSP', position: { x: 72000, y: 0, z: 0 } },
  { name: 'Spokane International Airport', code: 'KGEG', position: { x: 72500, y: 0, z: 0 } },
  { name: 'Springfield – Branson National Airport', code: 'KSGF', position: { x: 73000, y: 0, z: 0 } },
  { name: 'St Catherine International Airport', code: 'HESC', position: { x: 73500, y: 0, z: 0 } },
  { name: 'St Eustatius – F D Roosevelt Airport', code: 'TNCE', position: { x: 74000, y: 0, z: 0 } },
  { name: 'St John’s International Airport', code: 'CYYT', position: { x: 74500, y: 0, z: 0 } },
  { name: 'St Just – Land’s End Airport', code: 'EGHC', position: { x: 75000, y: 0, z: 0 } },
  { name: 'St Moritz – Samedan Airport', code: 'LSZS', position: { x: 75500, y: 0, z: 0 } },
  { name: 'St Nazaire – Montoir Aeroport', code: 'LFRZ', position: { x: 76000, y: 0, z: 0 } },
  { name: 'St Petersburg – Clearwater International Airport', code: 'KPIE', position: { x: 76500, y: 0, z: 0 } },
  { name: 'St Tropez Aeroport du Golfe', code: 'LIMN', position: { x: 77000, y: 0, z: 0 } },
  { name: 'Stanley – Mount Pleasant Airport', code: 'EGYP', position: { x: 77500, y: 0, z: 0 } },
  { name: 'State College – University Park Airport', code: 'KUNV', position: { x: 78000, y: 0, z: 0 } },
  { name: 'Stauning Vestjyllands Airport', code: 'EKVJ', position: { x: 78500, y: 0, z: 0 } },
  { name: 'Stavanger – Sola Airport', code: 'ENZV', position: { x: 79000, y: 0, z: 0 } },
  { name: 'Stavropol – Shpakovskoye Airport', code: 'URMT', position: { x: 79500, y: 0, z: 0 } },
  { name: 'Stephenville Airport', code: 'CYJT', position: { x: 80000, y: 0, z: 0 } },
  { name: 'Stewart International Airport', code: 'KSWF', position: { x: 80500, y: 0, z: 0 } },
  { name: 'Stockholm – Arlanda Airport', code: 'ESSA', position: { x: 81000, y: 0, z: 0 } },
  { name: 'Stockholm – Bromma Airport', code: 'ESSB', position: { x: 81500, y: 0, z: 0 } },
  { name: 'Stockholm – Västerås Airport', code: 'ESOW', position: { x: 82000, y: 0, z: 0 } },
  { name: 'Stockholm Skavsta Airport', code: 'ESKN', position: { x: 82500, y: 0, z: 0 } },
  { name: 'Stockton Metropolitain Airport', code: 'KSCK', position: { x: 83000, y: 0, z: 0 } },
  { name: 'Stord – Sørstokken Airport', code: 'ENSO', position: { x: 83500, y: 0, z: 0 } },
  { name: 'Stornoway Airport', code: 'EGPO', position: { x: 84000, y: 0, z: 0 } },
  { name: 'Strasbourg – International Airport', code: 'LFST', position: { x: 84500, y: 0, z: 0 } },
  { name: 'Stuttgart Airport', code: 'EDDS', position: { x: 85000, y: 0, z: 0 } },
  { name: 'Subang – Sultan Abdul Aziz Shah International Airport', code: 'WMSA', position: { x: 85500, y: 0, z: 0 } },
  { name: 'Subic Bay International Airport', code: 'RPLB', position: { x: 86000, y: 0, z: 0 } },
  { name: 'Sukkur Airport', code: 'OPSK', position: { x: 86500, y: 0, z: 0 } },
  { name: 'Sulaimaniyah International Airport', code: 'ORSU', position: { x: 87000, y: 0, z: 0 } },
  { name: 'Sultan Abdul Halim Airport – Alor Setar', code: 'WMKA', position: { x: 87500, y: 0, z: 0 } },
  { name: 'Sundsvall – Härnösand Airport', code: 'ESNN', position: { x: 88000, y: 0, z: 0 } },
  { name: 'Sunyani Airport', code: 'DGSN', position: { x: 88500, y: 0, z: 0 } },
  { name: 'Surabaya – Juanda International Airport', code: 'WARR', position: { x: 89000, y: 0, z: 0 } },
  { name: 'Surakarta – Adi Sumarmo Wiryokusumo International Airport', code: 'WARQ', position: { x: 89500, y: 0, z: 0 } },
];

// Add new airports to the scene
additionalAirports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});
// Add new airports to the list
const additionalAirports = [
  { name: 'San Fernando International Airport', code: 'SADF', position: { x: 60000, y: 0, z: 0 } },
  { name: 'San Francisco International Airport', code: 'KSFO', position: { x: 60500, y: 0, z: 0 } },
  { name: 'San Jose – Juan Santamaria Airport', code: 'MROC', position: { x: 61000, y: 0, z: 0 } },
  { name: 'San Jose – Norman Y Mineta International Airport', code: 'KSJC', position: { x: 61500, y: 0, z: 0 } },
  { name: 'San José – Tobias Bolanos International Airport', code: 'MRPV', position: { x: 62000, y: 0, z: 0 } },
  { name: 'San José del Cabo – Los Cabos International Airport', code: 'MMSD', position: { x: 62500, y: 0, z: 0 } },
  { name: 'San Juan – Luiz Munoz Marin International Airport', code: 'TJSJ', position: { x: 63000, y: 0, z: 0 } },
  { name: 'San Juan Airport', code: 'SANU', position: { x: 63500, y: 0, z: 0 } },
  { name: 'San Luis Airport', code: 'LESL', position: { x: 64000, y: 0, z: 0 } },
  { name: 'San Luis County Regional Airport', code: 'KSBP', position: { x: 64500, y: 0, z: 0 } },
  { name: 'San Luis Potosi – Ponciano Arriaga International Airport', code: 'MMSP', position: { x: 65000, y: 0, z: 0 } },
  { name: 'San Pedro Sula – La Mesa International Airport', code: 'MHLM', position: { x: 65500, y: 0, z: 0 } },
  { name: 'San Rafael Airport', code: 'SAMR', position: { x: 66000, y: 0, z: 0 } },
  { name: 'San Sebastian – Fuenterrabia Airport', code: 'LESO', position: { x: 66500, y: 0, z: 0 } },
  { name: 'Sana’a International Airport', code: 'OYSN', position: { x: 67000, y: 0, z: 0 } },
  { name: 'Sandakan Airport', code: 'WBKS', position: { x: 67500, y: 0, z: 0 } },
  { name: 'Sandefjord – Torp Airport', code: 'ENTO', position: { x: 68000, y: 0, z: 0 } },
  { name: 'Santa Ana – John Wayne Airport', code: 'KSNA', position: { x: 68500, y: 0, z: 0 } },
  { name: 'Santa Barbara Municipal Airport', code: 'KSBA', position: { x: 69000, y: 0, z: 0 } },
  { name: 'Santa Cruz – El Trompillo Airport', code: 'SLET', position: { x: 69500, y: 0, z: 0 } },
  { name: 'Santa Maria Airport', code: 'LPAZ', position: { x: 70000, y: 0, z: 0 } },
  { name: 'Santa Rosa Airport', code: 'SAZR', position: { x: 70500, y: 0, z: 0 } },
  { name: 'Santander – Parayas Airport', code: 'LEXJ', position: { x: 71000, y: 0, z: 0 } },
  { name: 'Santarém International Airport', code: 'SBSN', position: { x: 71500, y: 0, z: 0 } },
  { name: 'Santiago – Antonio Maceo Airport', code: 'MUCU', position: { x: 72000, y: 0, z: 0 } },
  { name: 'Santiago – Arturo Merino Benitez Airport', code: 'SCEL', position: { x: 72500, y: 0, z: 0 } },
  { name: 'Santiago – Cibao Intl Airport', code: 'MDST', position: { x: 73000, y: 0, z: 0 } },
  { name: 'Santiago – Los Cerillos Airport', code: 'SCTI', position: { x: 73500, y: 0, z: 0 } },
  { name: 'Santiago de Compostela Airport', code: 'LEST', position: { x: 74000, y: 0, z: 0 } },
  { name: 'Santiago del Estero Airport', code: 'SANE', position: { x: 74500, y: 0, z: 0 } },
  { name: 'Santo Domingo – Dr Joaquin Balaguer – La Isabela International Airport', code: 'MDJB', position: { x: 75000, y: 0, z: 0 } },
  { name: 'Santo Domingo – Las Americas Airport JFPG', code: 'MDSD', position: { x: 75500, y: 0, z: 0 } },
  { name: 'Santo Pekoa International Airport', code: 'NVSS', position: { x: 76000, y: 0, z: 0 } },
  { name: 'Sanya Phoenix International Airport', code: 'ZGSY', position: { x: 76500, y: 0, z: 0 } },
  { name: 'São José dos Campos – Professor Urbano Ernesto Stumpf Airport', code: 'SBSJ', position: { x: 77000, y: 0, z: 0 } },
  { name: 'São Paulo – Congonhas International Airport', code: 'SBSP', position: { x: 77500, y: 0, z: 0 } },
  { name: 'São Paulo – Guarulhos International Airport', code: 'SBGR', position: { x: 78000, y: 0, z: 0 } },
  { name: 'São Paulo – Viracopos Airport', code: 'SBKP', position: { x: 78500, y: 0, z: 0 } },
  { name: 'Sao Pedro Airport', code: 'GVSV', position: { x: 79000, y: 0, z: 0 } },
  { name: 'Sao Tome International Airport', code: 'FPST', position: { x: 79500, y: 0, z: 0 } },
  { name: 'São-Luis – Aeroporto Internacional Marechal Cunha Machado', code: 'SBSL', position: { x: 80000, y: 0, z: 0 } },
  { name: 'Sarajevo International Airport', code: 'LQSA', position: { x: 80500, y: 0, z: 0 } },
  { name: 'Saranac Lake – Adirondack Regional Airport', code: 'KSLK', position: { x: 81000, y: 0, z: 0 } },
  { name: 'Sarasota Bradenton International Airport', code: 'KSRQ', position: { x: 81500, y: 0, z: 0 } },
  { name: 'Saratov – Tsentralny Airport', code: 'UWSS', position: { x: 82000, y: 0, z: 0 } },
  { name: 'Sarnia – Chris Hadfield Airport', code: 'CYZR', position: { x: 82500, y: 0, z: 0 } },
  { name: 'Saskatoon John G Diefenbaker International Airport', code: 'CYXE', position: { x: 83000, y: 0, z: 0 } },
  { name: 'Satu Mare Airport', code: 'LRSM', position: { x: 83500, y: 0, z: 0 } },
  { name: 'Sault Ste Marie Airport', code: 'CYAM', position: { x: 84000, y: 0, z: 0 } },
  { name: 'Savannah – Hilton Head International Airport', code: 'KSAV', position: { x: 84500, y: 0, z: 0 } },
  { name: 'Savonlinna Airport', code: 'EFSA', position: { x: 85000, y: 0, z: 0 } },
  { name: 'Schwerin Parchim Airport', code: 'EDOP', position: { x: 85500, y: 0, z: 0 } },
  { name: 'Seattle-Tacoma International Airport', code: 'KSEA', position: { x: 86000, y: 0, z: 0 } },
  { name: 'Seinäjoki Airport', code: 'EFSI', position: { x: 86500, y: 0, z: 0 } },
  { name: 'Selebi Phikwe Airport', code: 'FBSP', position: { x: 87000, y: 0, z: 0 } },
  { name: 'Senai International Airport', code: 'WMKJ', position: { x: 87500, y: 0, z: 0 } },
  { name: 'Sendai Airport', code: 'RJSS', position: { x: 88000, y: 0, z: 0 } },
  { name: 'Seoul – Gimpo International Airport', code: 'RKSS', position: { x: 88500, y: 0, z: 0 } },
  { name: 'Seoul – Incheon International Airport', code: 'RKSI', position: { x: 89000, y: 0, z: 0 } },
  { name: 'Sept-Iles Airport', code: 'CYZV', position: { x: 89500, y: 0, z: 0 } },
  { name: 'Seville – San Pablo Airport', code: 'LEZL', position: { x: 90000, y: 0, z: 0 } },
  { name: 'Seychelles International Airport', code: 'FSIA', position: { x: 90500, y: 0, z: 0 } },
  { name: 'Sfax – Thyna International Airport', code: 'DTTX', position: { x: 91000, y: 0, z: 0 } },
  { name: 'Shaikh Zayed International Airport', code: 'OPRK', position: { x: 91500, y: 0, z: 0 } },
  { name: 'Shanghai – Hongqiao International Airport', code: 'ZSSS', position: { x: 92000, y: 0, z: 0 } },
  { name: 'Shanghai – Pudong International Airport', code: 'ZSPD', position: { x: 92500, y: 0, z: 0 } },
  { name: 'Shannon Airport', code: 'EINN', position: { x: 93000, y: 0, z: 0 } },
  { name: 'Sharjah International Airport', code: 'OMSJ', position: { x: 93500, y: 0, z: 0 } },
  { name: 'Sheberghan Airport', code: 'OASG', position: { x: 94000, y: 0, z: 0 } },
  { name: 'Sheffield City Airport', code: 'EGSY', position: { x: 94500, y: 0, z: 0 } },
  { name: 'Shenyang Taoxian International Airport', code: 'ZYTX', position: { x: 95000, y: 0, z: 0 } },
  { name: 'Shenzhen – Baoan International Airport', code: 'ZGSZ', position: { x: 95500, y: 0, z: 0 } },
  { name: 'Shetland – Scatsta Airport', code: 'EGPM', position: { x: 96000, y: 0, z: 0 } },
  { name: 'Shetland Isles – Lerwick Tingwall Airport', code: 'EGET', position: { x: 96500, y: 0, z: 0 } },
  { name: 'Shetland Isles – Sumburgh Airport', code: 'EGPB', position: { x: 97000, y: 0, z: 0 } },
  { name: 'Shijiazhuang Daguocun International Airport', code: 'ZBSJ', position: { x: 97500, y: 0, z: 0 } },
  { name: 'Shiraz – Shahid Dastghaib International Airport', code: 'OISS', position: { x: 98000, y: 0, z: 0 } },
  { name: 'Shoreham Airport', code: 'EGKA', position: { x: 98500, y: 0, z: 0 } },
  { name: 'Shreveport Regional Airport', code: 'KSHV', position: { x: 99000, y: 0, z: 0 } },
  { name: 'Shymkent Intenational Airport', code: 'UAII', position: { x: 99500, y: 0, z: 0 } },
  { name: 'Sialkot International Airport', code: 'OPST', position: { x: 100000, y: 0, z: 0 } },
  { name: 'Siauliai International Airport', code: 'EYSA', position: { x: 100500, y: 0, z: 0 } },
  { name: 'Sibiu International Airport', code: 'LRSB', position: { x: 101000, y: 0, z: 0 } },
  { name: 'Sibu Airport', code: 'WBGS', position: { x: 101500, y: 0, z: 0 } },
  { name: 'Sidney – Richland Municipal Airport', code: 'KSDY', position: { x: 102000, y: 0, z: 0 } },
];

// Add new airports to the scene
additionalAirports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});
// Add new airports to the list
const additionalAirports = [
  { name: 'Red Lake Airport', code: 'CYRL', position: { x: 90000, y: 0, z: 0 } },
  { name: 'Redmond – Roberts Field Airport', code: 'KRDM', position: { x: 90500, y: 0, z: 0 } },
  { name: 'Reggio Calabria Airport', code: 'LICR', position: { x: 91000, y: 0, z: 0 } },
  { name: 'Regina International Airport', code: 'CYQR', position: { x: 91500, y: 0, z: 0 } },
  { name: 'Reims – Champagne Airport', code: 'LFSR', position: { x: 92000, y: 0, z: 0 } },
  { name: 'Rennes – Saint-Jacques Airport', code: 'LFRN', position: { x: 92500, y: 0, z: 0 } },
  { name: 'Reno-Tahoe International Airport', code: 'KRNO', position: { x: 93000, y: 0, z: 0 } },
  { name: 'Resistencia International Airport', code: 'SARE', position: { x: 93500, y: 0, z: 0 } },
  { name: 'Reus Airport', code: 'LERS', position: { x: 94000, y: 0, z: 0 } },
  { name: 'Reykjavik Airport', code: 'BIRK', position: { x: 94500, y: 0, z: 0 } },
  { name: 'Reynosa – General Lucio Blanco International Airport', code: 'MMRX', position: { x: 95000, y: 0, z: 0 } },
  { name: 'Rhinelander – Oneida County Airport', code: 'KRHI', position: { x: 95500, y: 0, z: 0 } },
  { name: 'Rhodes – Diagoras Airport', code: 'LGRP', position: { x: 96000, y: 0, z: 0 } },
  { name: 'Ribeirão Preto – Leita Lopes Airport', code: 'SBRP', position: { x: 96500, y: 0, z: 0 } },
  { name: 'Richmond International Airport', code: 'KRIC', position: { x: 97000, y: 0, z: 0 } },
  { name: 'Rickenbacker International Airport', code: 'KLCK', position: { x: 97500, y: 0, z: 0 } },
  { name: 'Riga International Airport', code: 'EVRA', position: { x: 98000, y: 0, z: 0 } },
  { name: 'Rijeka – Riviera Kvarner Airport', code: 'LDRI', position: { x: 98500, y: 0, z: 0 } },
  { name: 'Rimini – Miramare Airport', code: 'LIPR', position: { x: 99000, y: 0, z: 0 } },
  { name: 'Rio Branco – Presidente Medici Airport', code: 'SBRB', position: { x: 99500, y: 0, z: 0 } },
  { name: 'Rio Cuarto Airport', code: 'SAOC', position: { x: 100000, y: 0, z: 0 } },
  { name: 'Rio de Janeiro – Santos Dumont Airport', code: 'SBRJ', position: { x: 100500, y: 0, z: 0 } },
  { name: 'Rio de Janeiro-Galeão – Antonio Carlos Jobim International Airport', code: 'SBGL', position: { x: 101000, y: 0, z: 0 } },
  { name: 'Rio Gallegos International Airport', code: 'SAWG', position: { x: 101500, y: 0, z: 0 } },
  { name: 'Rio Grande International Airport', code: 'SAWE', position: { x: 102000, y: 0, z: 0 } },
  { name: 'Riverside – March ARB', code: 'KRIV', position: { x: 102500, y: 0, z: 0 } },
  { name: 'Rivne Airport', code: 'UKLR', position: { x: 103000, y: 0, z: 0 } },
  { name: 'Riyadh – King Khaled International Airport', code: 'OERK', position: { x: 103500, y: 0, z: 0 } },
  { name: 'Roanoke Regional Airport', code: 'KROA', position: { x: 104000, y: 0, z: 0 } },
  { name: 'Roatán – Juan Manuel Galvez International Airport', code: 'MHRO', position: { x: 104500, y: 0, z: 0 } },
];

// Add new airports to the scene
additionalAirports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});
// Function to create an airport
export function createAirport({ name, code, position }) {
  const airport = new THREE.Group();

  // Runway
  const runwayGeometry = new THREE.PlaneGeometry(200, 20);
  const runwayMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
  runway.rotation.x = -Math.PI / 2;
  runway.position.set(0, 0, 0);
  airport.add(runway);

  // Terminal
  const terminalGeometry = new THREE.BoxGeometry(30, 10, 10);
  const terminalMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
  const terminal = new THREE.Mesh(terminalGeometry, terminalMaterial);
  terminal.position.set(-50, 5, -20);
  airport.add(terminal);

  // Control tower
  const towerGeometry = new THREE.CylinderGeometry(2, 2, 20, 32);
  const towerMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
  const tower = new THREE.Mesh(towerGeometry, towerMaterial);
  tower.position.set(-60, 10, -20);
  airport.add(tower);

  // Position the airport
  airport.position.set(position.x, position.y, position.z);

  return airport;
}

// List of airports
export const airports = [
  { name: 'Roanoke Regional Airport', code: 'KROA', position: { x: 104000, y: 0, z: 0 } },
  { name: 'Roatán – Juan Manuel Galvez International Airport', code: 'MHRO', position: { x: 104500, y: 0, z: 0 } },
  // Add more airports here...
];// Function to create an airplane
export function createAirplane({ fuselageColor, wingColor, position }) {
  const airplane = new THREE.Group();

  // Fuselage
  const fuselageGeometry = new THREE.CylinderGeometry(0.3, 0.3, 6, 32);
  const fuselageMaterial = new THREE.MeshStandardMaterial({ color: fuselageColor });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2; // Align with x-axis
  airplane.add(fuselage);

  // Wings
  const wingGeometry = new THREE.BoxGeometry(6, 0.2, 1);
  const wingMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0.5, 0);
  airplane.add(wing);

  // Tail
  const tailGeometry = new THREE.BoxGeometry(1, 0.5, 0.2);
  const tailMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(3, 0.5, 0);
  airplane.add(tail);

  // Position the airplane
  airplane.position.set(position.x, position.y, position.z);

  return airplane;
}import * as THREE from 'three';
import { createAirport, airports } from './airports.js';
import { createAirplane } from './airplanes.js';

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Add airports to the scene
airports.forEach((airportData) => {
  const airport = createAirport(airportData);
  scene.add(airport);
});

// Add an airplane to the scene
const airplane = createAirplane({
  fuselageColor: 0xff0000, // Red
  wingColor: 0x0000ff, // Blue
  position: { x: 0, y: 1, z: 0 },
});
scene.add(airplane);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Camera position
camera.position.z = 100;

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

animate();
export class ATC {
  constructor(scene, runways) {
    this.scene = scene; // Reference to the scene
    this.runways = runways; // List of available runways
    this.queue = []; // Queue of airplanes waiting for ATC instructions
  }

  // Add an airplane to the ATC queue
  addAirplane(airplane) {
    this.queue.push(airplane);
    console.log(`ATC: Airplane added to queue. Current queue size: ${this.queue.length}`);
  }

  // Assign a runway for takeoff or landing
  assignRunway(airplane) {
    if (this.runways.length === 0) {
      console.log('ATC: No available runways.');
      return null;
    }

    const runway = this.runways.shift(); // Assign the first available runway
    console.log(`ATC: Runway ${runway.name} assigned to airplane.`);
    airplane.userData.runway = runway;
    return runway;
  }

  // Clear an airplane for takeoff
  clearForTakeoff(airplane) {
    const runway = this.assignRunway(airplane);
    if (runway) {
      console.log(`ATC: Airplane cleared for takeoff on runway ${runway.name}.`);
      airplane.userData.status = 'takeoff';
    }
  }

  // Clear an airplane for landing
  clearForLanding(airplane) {
    const runway = this.assignRunway(airplane);
    if (runway) {
      console.log(`ATC: Airplane cleared for landing on runway ${runway.name}.`);
      airplane.userData.status = 'landing';
    }
  }

  // Release a runway after use
  releaseRunway(runway) {
    this.runways.push(runway);
    console.log(`ATC: Runway ${runway.name} is now available.`);
  }

  // Update airplane movements
  update() {
    this.queue.forEach((airplane) => {
      if (airplane.userData.status === 'takeoff') {
        this.handleTakeoff(airplane);
      } else if (airplane.userData.status === 'landing') {
        this.handleLanding(airplane);
      }
    });
  }

  // Handle takeoff logic
  handleTakeoff(airplane) {
    const runway = airplane.userData.runway;
    if (!runway) return;

    // Move the airplane along the runway
    airplane.position.x += 0.5;
    if (airplane.position.x > runway.length) {
      console.log('ATC: Airplane has taken off.');
      airplane.userData.status = 'airborne';
      this.releaseRunway(runway);
    }
  }

  // Handle landing logic
  handleLanding(airplane) {
    const runway = airplane.userData.runway;
    if (!runway) return;

    // Move the airplane toward the runway
    airplane.position.x -= 0.5;
    if (airplane.position.x <= runway.position.x) {
      console.log('ATC: Airplane has landed.');
      airplane.userData.status = 'landed';
      this.releaseRunway(runway);
    }
  }
}
export const runways = [
  { name: 'Runway 1', position: { x: 0, y: 0, z: 0 }, length: 200 },
  { name: 'Runway 2', position: { x: 300, y: 0, z: 0 }, length: 200 },
];
import * as THREE from 'three';
import { createAirplane } from './airplanes.js';
import { ATC } from './atc.js';
import { runways } from './runways.js';

// Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Add runways to the scene
runways.forEach((runway) => {
  const runwayGeometry = new THREE.PlaneGeometry(runway.length, 20);
  const runwayMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const runwayMesh = new THREE.Mesh(runwayGeometry, runwayMaterial);
  runwayMesh.rotation.x = -Math.PI / 2;
  runwayMesh.position.set(runway.position.x, runway.position.y, runway.position.z);
  scene.add(runwayMesh);
});

// Initialize ATC
const atc = new ATC(scene, runways);

// Add airplanes to the scene
const airplane1 = createAirplane({
  fuselageColor: 0xff0000,
  wingColor: 0x0000ff,
  position: { x: -100, y: 1, z: 0 },
});
scene.add(airplane1);
atc.addAirplane(airplane1);

const airplane2 = createAirplane({
  fuselageColor: 0x00ff00,
  wingColor: 0xffff00,
  position: { x: -200, y: 1, z: 0 },
});
scene.add(airplane2);
atc.addAirplane(airplane2);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// Camera position
camera.position.z = 500;

// Animation loop
function animate() {
  requestAnimationFrame(animate);

  // Update ATC
  atc.update();

  renderer.render(scene, camera);
}

animate();
// Enhance runway with textures and lights
const runwayTexture = new THREE.TextureLoader().load('textures/runway.jpg');
const runwayMaterial = new THREE.MeshStandardMaterial({ map: runwayTexture });
const runway = new THREE.Mesh(new THREE.PlaneGeometry(200, 20), runwayMaterial);
runway.rotation.x = -Math.PI / 2;
scene.add(runway);

// Add runway lights
for (let i = -90; i <= 90; i += 20) {
  const light = new THREE.Mesh(
    new THREE.SphereGeometry(0.2, 16, 16),
    new THREE.MeshStandardMaterial({ color: 0x00ff00 })
  );
  light.position.set(i, 0.5, -10);
  scene.add(light);
}
// Add animated landing gear
const landingGear = new THREE.Group();
const wheel = new THREE.Mesh(
  new THREE.CylinderGeometry(0.2, 0.2, 0.1, 32),
  new THREE.MeshStandardMaterial({ color: 0x333333 })
);
wheel.rotation.z = Math.PI / 2;
landingGear.add(wheel);
airplane.add(landingGear);

// Animate landing gear
function animateLandingGear() {
  landingGear.position.y = gearDeployed ? -0.5 : 0.5;
}
// Create a flight path
const curve = new THREE.CatmullRomCurve3([
  new THREE.Vector3(0, 0, 0),
  new THREE.Vector3(50, 20, -50),
  new THREE.Vector3(100, 0, -100),
]);
const points = curve.getPoints(50);
const geometry = new THREE.BufferGeometry().setFromPoints(points);
const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
const flightPath = new THREE.Line(geometry, material);
scene.add(flightPath);
// Add rain effect
const rainGeometry = new THREE.BufferGeometry();
const rainCount = 1000;
const rainPositions = new Float32Array(rainCount * 3);
for (let i = 0; i < rainCount; i++) {
  rainPositions[i * 3] = Math.random() * 100 - 50;
  rainPositions[i * 3 + 1] = Math.random() * 50;
  rainPositions[i * 3 + 2] = Math.random() * 100 - 50;
}
rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
const rainMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1 });
const rain = new THREE.Points(rainGeometry, rainMaterial);
scene.add(rain);
// ATC system
class ATC {
  constructor(runways) {
    this.runways = runways;
    this.queue = [];
  }

  assignRunway(airplane) {
    const runway = this.runways.shift();
    airplane.userData.runway = runway;
    return runway;
  }

  update() {
    this.queue.forEach((airplane) => {
      if (airplane.userData.status === 'takeoff') {
        airplane.position.x += 1; // Move airplane along the runway
      }
    });
  }
}
// Example WebSocket connection
const socket = new WebSocket('ws://localhost:8080');
socket.onmessage = (event) => {
  const data = JSON.parse(event.data);
  airplane.position.set(data.x, data.y, data.z);
};
// Add terrain
const terrainGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
const terrainMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });
const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
terrain.rotation.x = -Math.PI / 2;
scene.add(terrain);
// Add LOD for an object
const lod = new THREE.LOD();
const highDetail = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
const lowDetail = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
lod.addLevel(highDetail, 0);
lod.addLevel(lowDetail, 50);
scene.add(lod);
// Add refueling station
const refuelingStation = new THREE.Mesh(
  new THREE.BoxGeometry(5, 5, 5),
  new THREE.MeshStandardMaterial({ color: 0x888888 })
);
refuelingStation.position.set(10, 0, 10);
scene.add(refuelingStation);
// Mission system
class Mission {
  constructor(description, reward) {
    this.description = description;
    this.reward = reward;
  }

  complete() {
    console.log(`Mission complete! Reward: ${this.reward}`);
  }
}

const mission = new Mission('Deliver cargo to Airport B', 100);
mission.complete();
// Function to fetch flight plans from SimBrief
async function fetchFlightPlan(simBriefId) {
  const response = await fetch(`https://www.simbrief.com/api/xml.fetcher.php?userid=${simBriefId}`);
  const text = await response.text();
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(text, "text/xml");

  // Extract relevant data
  const origin = xmlDoc.querySelector("origin").textContent;
  const destination = xmlDoc.querySelector("destination").textContent;
  const waypoints = Array.from(xmlDoc.querySelectorAll("waypoint")).map((wp) => ({
    name: wp.querySelector("ident").textContent,
    lat: parseFloat(wp.querySelector("lat").textContent),
    lon: parseFloat(wp.querySelector("lon").textContent),
  }));

  return { origin, destination, waypoints };
}

// Example usage
fetchFlightPlan("yourSimBriefUserId").then((flightPlan) => {
  console.log("Flight Plan:", flightPlan);
  // Use the flight plan to create a flight path in your simulator
});
class ATCManager {
  constructor(airports) {
    this.airports = airports.map((airport) => ({
      ...airport,
      queue: [],
    }));
  }

  assignRunway(airportCode, airplane) {
    const airport = this.airports.find((a) => a.code === airportCode);
    if (!airport) return console.error("Airport not found!");

    const runway = airport.runways.shift();
    if (!runway) return console.error("No available runways!");

    airplane.userData.runway = runway;
    airport.queue.push(airplane);
    console.log(`ATC: Assigned runway ${runway.name} at ${airport.name}`);
  }

  update() {
    this.airports.forEach((airport) => {
      airport.queue.forEach((airplane) => {
        if (airplane.userData.status === "takeoff") {
          airplane.position.x += 1; // Move airplane along the runway
        }
      });
    });
  }
}

// Initialize ATC for all airports
const atcManager = new ATCManager(airports);
// Server-side (Node.js with Socket.IO)
const io = require("socket.io")(3000);

io.on("connection", (socket) => {
  console.log("User connected:", socket.id);

  socket.on("chatMessage", (message) => {
    console.log("Message received:", message);
    io.emit("chatMessage", message); // Broadcast to all users
  });
});

// Client-side
const socket = io("http://localhost:3000");

document.getElementById("sendButton").addEventListener("click", () => {
  const message = document.getElementById("chatInput").value;
  socket.emit("chatMessage", message);
});

socket.on("chatMessage", (message) => {
  const chatBox = document.getElementById("chatBox");
  chatBox.innerHTML += `<p>${message}</p>`;
});
class RefuelingSystem {
  constructor(tanker, receiver) {
    this.tanker = tanker;
    this.receiver = receiver;
    this.isRefueling = false;
  }

  startRefueling() {
    const distance = this.tanker.position.distanceTo(this.receiver.position);
    if (distance < 10) {
      this.isRefueling = true;
      console.log("Refueling started!");
    } else {
      console.log("Too far for refueling!");
    }
  }

  update() {
    if (this.isRefueling) {
      this.receiver.userData.fuel += 0.1; // Add fuel to the receiver
      console.log("Refueling in progress...");
    }
  }
}

// Example usage
const refuelingSystem = new RefuelingSystem(tankerAirplane, receiverAirplane);
refuelingSystem.startRefueling();
class WeaponSystem {
  constructor(airplane) {
    this.airplane = airplane;
    this.missiles = [];
    this.bombs = [];
    this.flares = [];
  }

  fireMissile(target) {
    const missile = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 2, 32),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    missile.position.copy(this.airplane.position);
    missile.userData.target = target;
    this.missiles.push(missile);
    scene.add(missile);
  }

  dropBomb() {
    const bomb = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 16, 16),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    bomb.position.copy(this.airplane.position);
    this.bombs.push(bomb);
    scene.add(bomb);
  }

  deployFlares() {
    for (let i = 0; i < 5; i++) {
      const flare = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        new THREE.MeshStandardMaterial({ color: 0xffff00 })
      );
      flare.position.copy(this.airplane.position);
      flare.position.x += Math.random() * 2 - 1;
      flare.position.y += Math.random() * 2 - 1;
      this.flares.push(flare);
      scene.add(flare);
    }
  }

  update() {
    this.missiles.forEach((missile) => {
      const target = missile.userData.target;
      missile.position.lerp(target.position, 0.05); // Move toward the target
    });

    this.bombs.forEach((bomb) => {
      bomb.position.y -= 0.1; // Drop the bomb
    });

    this.flares.forEach((flare) => {
      flare.material.opacity -= 0.01; // Fade out the flares
      if (flare.material.opacity <= 0) {
        scene.remove(flare);
      }
    });
  }
}

// Example usage
const weaponSystem = new WeaponSystem(fighterJet);
weaponSystem.fireMissile(enemyTarget);
weaponSystem.dropBomb();
weaponSystem.deployFlares();
// HTML for SimBrief Integration
const simBriefUI = `
  <div id="simbrief-ui">
    <h3>SimBrief Flight Plan</h3>
    <textarea id="flight-plan-input" placeholder="Paste your flight plan here..."></textarea>
    <button id="load-flight-plan">Load Flight Plan</button>
    <button id="delete-flight-plan">Delete Flight Plan</button>
    <div id="flight-plan-display"></div>
  </div>
`;
document.body.insertAdjacentHTML('beforeend', simBriefUI);

// CSS for SimBrief UI
const simBriefStyle = `
  #simbrief-ui {
    position: fixed;
    top: 10%;
    left: 10%;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 10px;
    z-index: 1000;
  }
  #simbrief-ui textarea {
    width: 100%;
    height: 100px;
    margin-bottom: 10px;
  }
  #simbrief-ui button {
    margin-right: 10px;
  }
`;
const styleTag = document.createElement('style');
styleTag.innerHTML = simBriefStyle;
document.head.appendChild(styleTag);

// JavaScript for SimBrief Integration
document.getElementById('load-flight-plan').addEventListener('click', () => {
  const flightPlan = document.getElementById('flight-plan-input').value;
  if (flightPlan) {
    document.getElementById('flight-plan-display').innerText = `Loaded Flight Plan:\n${flightPlan}`;
  } else {
    alert('Please paste a flight plan!');
  }
});

document.getElementById('delete-flight-plan').addEventListener('click', () => {
  document.getElementById('flight-plan-input').value = '';
  document.getElementById('flight-plan-display').innerText = '';
  alert('Flight plan deleted!');
});
class ATCManager {
  constructor(airports) {
    this.airports = airports.map((airport) => ({
      ...airport,
      queue: [],
    }));
  }

  assignRunway(airportCode, airplane) {
    const airport = this.airports.find((a) => a.code === airportCode);
    if (!airport) return console.error("Airport not found!");

    const runway = airport.runways.shift();
    if (!runway) return console.error("No available runways!");

    airplane.userData.runway = runway;
    airport.queue.push(airplane);
    console.log(`ATC: Assigned runway ${runway.name} at ${airport.name}`);
  }

  update() {
    this.airports.forEach((airport) => {
      airport.queue.forEach((airplane) => {
        if (airplane.userData.status === "takeoff") {
          airplane.position.x += 1; // Move airplane along the runway
        }
      });
    });
  }
}

// Initialize ATC for all airports
const atcManager = new ATCManager(airports);
// Server-side (Node.js with Socket.IO)
const io = require("socket.io")(3000);

io.on("connection", (socket) => {
  console.log("User connected:", socket.id);

  socket.on("createChannel", (channelName) => {
    socket.join(channelName);
    console.log(`User joined channel: ${channelName}`);
  });

  socket.on("chatMessage", ({ channel, message }) => {
    io.to(channel).emit("chatMessage", message); // Broadcast to the channel
  });
});

// Client-side
const socket = io("http://localhost:3000");

document.getElementById("createChannelButton").addEventListener("click", () => {
  const channelName = prompt("Enter channel name:");
  socket.emit("createChannel", channelName);
});

document.getElementById("sendButton").addEventListener("click", () => {
  const message = document.getElementById("chatInput").value;
  const channel = "default"; // Replace with the current channel
  socket.emit("chatMessage", { channel, message });
});

socket.on("chatMessage", (message) => {
  const chatBox = document.getElementById("chatBox");
  chatBox.innerHTML += `<p>${message}</p>`;
});
class RefuelingSystem {
  constructor(tanker, receiver) {
    this.tanker = tanker;
    this.receiver = receiver;
    this.isRefueling = false;
  }

  startRefueling() {
    const distance = this.tanker.position.distanceTo(this.receiver.position);
    if (distance < 10) {
      this.isRefueling = true;
      console.log("Refueling started!");
    } else {
      console.log("Too far for refueling!");
    }
  }

  update() {
    if (this.isRefueling) {
      this.receiver.userData.fuel += 0.1; // Add fuel to the receiver
      console.log("Refueling in progress...");
    }
  }
}

// Example usage
const refuelingSystem = new RefuelingSystem(tankerAirplane, receiverAirplane);
refuelingSystem.startRefueling();
class WeaponSystem {
  constructor(airplane) {
    this.airplane = airplane;
    this.missiles = [];
    this.bombs = [];
    this.flares = [];
  }

  fireMissile(target) {
    const missile = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 2, 32),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    missile.position.copy(this.airplane.position);
    missile.userData.target = target;
    this.missiles.push(missile);
    scene.add(missile);

    // Play missile launch sound
    const audio = new Audio('sounds/missile-launch.mp3');
    audio.play();
  }

  dropBomb() {
    const bomb = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 16, 16),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    bomb.position.copy(this.airplane.position);
    this.bombs.push(bomb);
    scene.add(bomb);

    // Play bomb drop sound
    const audio = new Audio('sounds/bomb-drop.mp3');
    audio.play();
  }

  deployFlares() {
    for (let i = 0; i < 5; i++) {
      const flare = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        new THREE.MeshStandardMaterial({ color: 0xffff00 })
      );
      flare.position.copy(this.airplane.position);
      flare.position.x += Math.random() * 2 - 1;
      flare.position.y += Math.random() * 2 - 1;
      this.flares.push(flare);
      scene.add(flare);
    }

    // Play flare deployment sound
    const audio = new Audio('sounds/flare-deploy.mp3');
    audio.play();
  }

  update() {
    this.missiles.forEach((missile) => {
      const target = missile.userData.target;
      missile.position.lerp(target.position, 0.05); // Move toward the target

      // Collision detection
      if (missile.position.distanceTo(target.position) < 1) {
        console.log("Target hit!");
        scene.remove(missile);
        this.missiles = this.missiles.filter((m) => m !== missile);

        // Explosion effect
        const explosion = new THREE.Mesh(
          new THREE.SphereGeometry(2, 32, 32),
          new THREE.MeshStandardMaterial({ color: 0xff4500 })
        );
        explosion.position.copy(target.position);
        scene.add(explosion);

        // Play explosion sound
        const audio = new Audio('sounds/explosion.mp3');
        audio.play();

        setTimeout(() => scene.remove(explosion), 1000); // Remove explosion after 1 second
      }
    });
  }
}

// Example usage
const weaponSystem = new WeaponSystem(fighterJet);
weaponSystem.fireMissile(enemyTarget);
weaponSystem.dropBomb();
weaponSystem.deployFlares();
function playPilotChatter(code) {
  const audio = new Audio(`sounds/${code}.mp3`);
  audio.play();
}

// Example usage
playPilotChatter('fox-2'); // Plays "Fox 2" audio
class FoxCodeSystem {
  constructor() {
    this.audioFiles = {
      'fox-1': 'sounds/fox-1.mp3',
      'fox-2': 'sounds/fox-2.mp3',
      'fox-3': 'sounds/fox-3.mp3',
      'fox-4': 'sounds/fox-4.mp3',
    };
  }

  playFoxCode(code) {
    if (this.audioFiles[code]) {
      const audio = new Audio(this.audioFiles[code]);
      audio.play();
      console.log(`Fox Code: ${code.toUpperCase()} called.`);
    } else {
      console.error(`Invalid Fox Code: ${code}`);
    }
  }
}

// Example usage
const foxCodeSystem = new FoxCodeSystem();
foxCodeSystem.playFoxCode('fox-2'); // Plays "Fox-2" audio
class WeaponSystem {
  constructor(airplane, foxCodeSystem) {
    this.airplane = airplane;
    this.foxCodeSystem = foxCodeSystem;
    this.missiles = [];
    this.bombs = [];
    this.flares = [];
  }

  fireMissile(target, type) {
    const missile = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 2, 32),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    missile.position.copy(this.airplane.position);
    missile.userData.target = target;
    this.missiles.push(missile);
    scene.add(missile);

    // Trigger the appropriate Fox code
    if (type === 'fox-1') {
      this.foxCodeSystem.playFoxCode('fox-1');
    } else if (type === 'fox-2') {
      this.foxCodeSystem.playFoxCode('fox-2');
    } else if (type === 'fox-3') {
      this.foxCodeSystem.playFoxCode('fox-3');
    }
  }

  fireGuns() {
    // Trigger Fox-4 for guns
    this.foxCodeSystem.playFoxCode('fox-4');
    console.log('Firing guns!');
  }
}
const io = require('socket.io')(3000);

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Handle Fox code broadcast
  socket.on('foxCode', (data) => {
    console.log(`Fox Code: ${data.code} from ${data.player}`);
    io.emit('foxCode', data); // Broadcast to all players
  });
});
// Connect to the server
const socket = io('http://localhost:3000');

// Handle Fox code broadcast
socket.on('foxCode', (data) => {
  console.log(`Fox Code: ${data.code} from ${data.player}`);
  const audio = new Audio(`sounds/${data.code}.mp3`);
  audio.play();
});

// Trigger Fox code and broadcast to other players
function triggerFoxCode(code, playerName) {
  socket.emit('foxCode', { code, player: playerName });
  console.log(`Fox Code: ${code} triggered by ${playerName}`);
}

// Example usage
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyF') {
    triggerFoxCode('fox-2', 'Player1'); // Example: Player1 fires a Fox-2 missile
  }
});
function playPilotChatter(chatterType) {
  const audioFiles = {
    'missile-launch': 'sounds/missile-launch.mp3',
    'target-hit': 'sounds/target-hit.mp3',
    'fox-2': 'sounds/fox-2.mp3',
  };

  if (audioFiles[chatterType]) {
    const audio = new Audio(audioFiles[chatterType]);
    audio.play();
    console.log(`Pilot Chatter: ${chatterType}`);
  } else {
    console.error(`Invalid chatter type: ${chatterType}`);
  }
}

// Example usage
playPilotChatter('missile-launch'); // Plays missile launch audio
// Initialize systems
const foxCodeSystem = new FoxCodeSystem();
const weaponSystem = new WeaponSystem(fighterJet, foxCodeSystem);

// Fire a Fox-2 missile
weaponSystem.fireMissile(enemyTarget, 'fox-2');

// Fire guns (Fox-4)
weaponSystem.fireGuns();

// Broadcast Fox code to other players
triggerFoxCode('fox-2', 'Player1');

// Play pilot chatter
playPilotChatter('missile-launch');
// Server-side (Node.js with Socket.IO)
const io = require('socket.io')(3000);

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Handle Fox code broadcast
  socket.on('foxCode', (data) => {
    console.log(`Fox Code: ${data.code} from ${data.player}`);
    io.emit('foxCode', data); // Broadcast to all players globally
  });
});
// Client-side
const socket = io('http://localhost:3000');

// Handle Fox code broadcast
socket.on('foxCode', (data) => {
  console.log(`Fox Code: ${data.code} from ${data.player}`);
  const audio = new Audio(`sounds/${data.code}.mp3`);
  audio.play();
});

// Trigger Fox code and broadcast to other players
function triggerFoxCode(code, playerName) {
  socket.emit('foxCode', { code, player: playerName });
  console.log(`Fox Code: ${code} triggered by ${playerName}`);
}

// Example usage
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyF') {
    triggerFoxCode('fox-2', 'Player1'); // Example: Player1 fires a Fox-2 missile
  }
});
// HTML for Chatter Upload
const chatterUI = `
  <div id="chatter-ui">
    <h3>Upload Custom Chatter</h3>
    <label for="chatter-type">Chatter Type:</label>
    <select id="chatter-type">
      <option value="fox-1">Fox-1</option>
      <option value="fox-2">Fox-2</option>
      <option value="fox-3">Fox-3</option>
      <option value="fox-4">Fox-4</option>
    </select>
    <input type="file" id="chatter-file" accept="audio/*">
    <button id="upload-chatter">Upload</button>
  </div>
`;
document.body.insertAdjacentHTML('beforeend', chatterUI);

// JavaScript for Chatter Upload
const customChatter = {};

document.getElementById('upload-chatter').addEventListener('click', () => {
  const chatterType = document.getElementById('chatter-type').value;
  const fileInput = document.getElementById('chatter-file');
  const file = fileInput.files[0];

  if (file) {
    const reader = new FileReader();
    reader.onload = (event) => {
      customChatter[chatterType] = event.target.result; // Store the audio file as a data URL
      alert(`Custom chatter for ${chatterType} uploaded successfully!`);
    };
    reader.readAsDataURL(file);
  } else {
    alert('Please select a file to upload.');
  }
});

// Play Custom Chatter
function playCustomChatter(chatterType) {
  if (customChatter[chatterType]) {
    const audio = new Audio(customChatter[chatterType]);
    audio.play();
    console.log(`Playing custom chatter: ${chatterType}`);
  } else {
    console.error(`No custom chatter uploaded for: ${chatterType}`);
  }
}

// Example usage
playCustomChatter('fox-2'); // Plays custom chatter for Fox-2
class WeaponSystem {
  constructor(airplane, foxCodeSystem) {
    this.airplane = airplane;
    this.foxCodeSystem = foxCodeSystem;
    this.missiles = [];
    this.bombs = [];
    this.flares = [];
  }

  fireMissile(target, type) {
    // Trigger the Fox code with a delay
    setTimeout(() => {
      if (type === 'fox-1') {
        this.foxCodeSystem.playFoxCode('fox-1');
      } else if (type === 'fox-2') {
        this.foxCodeSystem.playFoxCode('fox-2');
      } else if (type === 'fox-3') {
        this.foxCodeSystem.playFoxCode('fox-3');
      }
    }, 1000); // 1-second delay for realism

    // Launch the missile after the Fox code
    setTimeout(() => {
      const missile = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 2, 32),
        new THREE.MeshStandardMaterial({ color: 0xff0000 })
      );
      missile.position.copy(this.airplane.position);
      missile.userData.target = target;
      this.missiles.push(missile);
      scene.add(missile);
      console.log('Missile launched!');
    }, 2000); // 2-second delay for missile launch
  }

  fireGuns() {
    // Trigger Fox-4 with a delay
    setTimeout(() => {
      this.foxCodeSystem.playFoxCode('fox-4');
      console.log('Firing guns!');
    }, 500); // 0.5-second delay for realism
  }
}
// Initialize systems
const foxCodeSystem = new FoxCodeSystem();
const weaponSystem = new WeaponSystem(fighterJet, foxCodeSystem);

// Fire a Fox-2 missile with realistic timing
weaponSystem.fireMissile(enemyTarget, 'fox-2');

// Fire guns (Fox-4) with a delay
weaponSystem.fireGuns();

// Broadcast Fox code to other players
triggerFoxCode('fox-2', 'Player1');

// Play custom chatter
playCustomChatter('fox-2');
const io = require('socket.io')(3000);

const dogfightChannels = {}; // Store dogfight-specific channels

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Join a dogfight channel
  socket.on('joinDogfight', (dogfightId) => {
    socket.join(dogfightId);
    dogfightChannels[dogfightId] = dogfightChannels[dogfightId] || [];
    dogfightChannels[dogfightId].push(socket.id);
    console.log(`User ${socket.id} joined dogfight ${dogfightId}`);
  });

  // Broadcast Fox code to a specific dogfight channel
  socket.on('foxCode', ({ dogfightId, code, player }) => {
    console.log(`Fox Code: ${code} from ${player} in dogfight ${dogfightId}`);
    io.to(dogfightId).emit('foxCode', { code, player });
  });
});
const socket = io('http://localhost:3000');

// Join a dogfight channel
function joinDogfight(dogfightId) {
  socket.emit('joinDogfight', dogfightId);
  console.log(`Joined dogfight: ${dogfightId}`);
}

// Handle Fox code broadcast
socket.on('foxCode', (data) => {
  console.log(`Fox Code: ${data.code} from ${data.player}`);
  const audio = new Audio(`sounds/${data.code}.mp3`);
  audio.play();
});

// Trigger Fox code and broadcast to the dogfight channel
function triggerFoxCode(dogfightId, code, playerName) {
  socket.emit('foxCode', { dogfightId, code, player: playerName });
  console.log(`Fox Code: ${code} triggered by ${playerName} in dogfight ${dogfightId}`);
}

// Example usage
joinDogfight('dogfight-123'); // Join a specific dogfight
triggerFoxCode('dogfight-123', 'fox-2', 'Player1'); // Broadcast Fox-2 to the dogfight
// HTML for Chatter Upload
const chatterUI = `
  <div id="chatter-ui">
    <h3>Upload Custom Chatter</h3>
    <label for="chatter-type">Chatter Type:</label>
    <select id="chatter-type">
      <option value="fox-1">Fox-1</option>
      <option value="fox-2">Fox-2</option>
      <option value="fox-3">Fox-3</option>
      <option value="fox-4">Fox-4</option>
    </select>
    <input type="file" id="chatter-file" accept="audio/*">
    <button id="upload-chatter">Upload</button>
  </div>
`;
document.body.insertAdjacentHTML('beforeend', chatterUI);

// JavaScript for Chatter Upload
document.getElementById('upload-chatter').addEventListener('click', () => {
  const chatterType = document.getElementById('chatter-type').value;
  const fileInput = document.getElementById('chatter-file');
  const file = fileInput.files[0];

  if (file) {
    const formData = new FormData();
    formData.append('chatterType', chatterType);
    formData.append('file', file);

    fetch('http://localhost:3000/uploadChatter', {
      method: 'POST',
      body: formData,
    })
      .then((response) => response.json())
      .then((data) => {
        if (data.success) {
          alert('Chatter uploaded successfully and is pending approval!');
        } else {
          alert('Failed to upload chatter.');
        }
      });
  } else {
    alert('Please select a file to upload.');
  }
});
const express = require('express');
const multer = require('multer');
const app = express();
const upload = multer({ dest: 'uploads/' });

app.post('/uploadChatter', upload.single('file'), (req, res) => {
  const { chatterType } = req.body;
  const file = req.file;

  // Save file for moderation
  console.log(`Received chatter file for ${chatterType}: ${file.originalname}`);
  res.json({ success: true });
});

app.listen(3000, () => console.log('Server running on port 3000'));
class WeaponSystem {
  constructor(airplane, foxCodeSystem) {
    this.airplane = airplane;
    this.foxCodeSystem = foxCodeSystem;
    this.missiles = [];
    this.bombs = [];
    this.flares = [];
    this.ammo = { missiles: 4, bombs: 2, flares: 5 }; // Ammo limits
  }

  fireMissile(target, type) {
    if (this.ammo.missiles <= 0) {
      console.log('Out of missiles! Return to base to rearm.');
      return;
    }

    // Trigger the Fox code with a delay
    setTimeout(() => {
      this.foxCodeSystem.playFoxCode(type);
    }, 1000); // 1-second delay for realism

    // Launch the missile after the Fox code
    setTimeout(() => {
      const missile = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 2, 32),
        new THREE.MeshStandardMaterial({ color: 0xff0000 })
      );
      missile.position.copy(this.airplane.position);
      missile.userData.target = target;
      this.missiles.push(missile);
      scene.add(missile);
      console.log('Missile launched!');
      this.ammo.missiles--; // Decrease ammo count
    }, 2000); // 2-second delay for missile launch
  }

  dropBomb() {
    if (this.ammo.bombs <= 0) {
      console.log('Out of bombs! Return to base to rearm.');
      return;
    }

    setTimeout(() => {
      const bomb = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 16, 16),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
      );
      bomb.position.copy(this.airplane.position);
      this.bombs.push(bomb);
      scene.add(bomb);
      console.log('Bomb dropped!');
      this.ammo.bombs--; // Decrease ammo count
    }, 1000); // 1-second delay for bomb drop
  }

  deployFlares() {
    if (this.ammo.flares <= 0) {
      console.log('Out of flares!');
      return;
    }

    for (let i = 0; i < 5; i++) {
      const flare = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 16),
        new THREE.MeshStandardMaterial({ color: 0xffff00 })
      );
      flare.position.copy(this.airplane.position);
      flare.position.x += Math.random() * 2 - 1;
      flare.position.y += Math.random() * 2 - 1;
      this.flares.push(flare);
      scene.add(flare);
    }
    console.log('Flares deployed!');
    this.ammo.flares--; // Decrease ammo count
  }

  rearm() {
    this.ammo = { missiles: 4, bombs: 2, flares: 5 }; // Reset ammo
    console.log('Ammo rearmed!');
  }
}

// Example usage
const weaponSystem = new WeaponSystem(fighterJet, foxCodeSystem);
weaponSystem.fireMissile(enemyTarget, 'fox-2');
weaponSystem.dropBomb();
weaponSystem.deployFlares();
weaponSystem.rearm(); // Rearm when landed
const io = require('socket.io')(3000);

const dogfightChannels = {}; // Store dogfight-specific channels

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Join a dogfight channel
  socket.on('joinDogfight', (dogfightId) => {
    socket.join(dogfightId);
    dogfightChannels[dogfightId] = dogfightChannels[dogfightId] || [];
    dogfightChannels[dogfightId].push(socket.id);
    console.log(`User ${socket.id} joined dogfight ${dogfightId}`);
  });

  // Broadcast Fox code to a specific dogfight channel
  socket.on('foxCode', ({ dogfightId, code, player }) => {
    console.log(`Fox Code: ${code} from ${player} in dogfight ${dogfightId}`);
    io.to(dogfightId).emit('foxCode', { code, player });
  });

  // Broadcast voice chat to a specific dogfight channel
  socket.on('voiceChat', ({ dogfightId, audioData }) => {
    io.to(dogfightId).emit('voiceChat', { audioData });
  });
});
const socket = io('http://localhost:3000');

// Join a dogfight channel
function joinDogfight(dogfightId) {
  socket.emit('joinDogfight', dogfightId);
  console.log(`Joined dogfight: ${dogfightId}`);
}

// Handle Fox code broadcast
socket.on('foxCode', (data) => {
  console.log(`Fox Code: ${data.code} from ${data.player}`);
  const audio = new Audio(`sounds/${data.code}.mp3`);
  audio.play();
});

// Handle voice chat broadcast
socket.on('voiceChat', ({ audioData }) => {
  const audio = new Audio(audioData);
  audio.play();
});

// Trigger Fox code and broadcast to the dogfight channel
function triggerFoxCode(dogfightId, code, playerName) {
  socket.emit('foxCode', { dogfightId, code, player: playerName });
  console.log(`Fox Code: ${code} triggered by ${playerName} in dogfight ${dogfightId}`);
}

// Example usage
joinDogfight('dogfight-123'); // Join a specific dogfight
triggerFoxCode('dogfight-123', 'fox-2', 'Player1'); // Broadcast Fox-2 to the dogfight
// HTML for Chatter Upload
const chatterUI = `
  <div id="chatter-ui">
    <h3>Upload Custom Chatter</h3>
    <label for="chatter-type">Chatter Type:</label>
    <select id="chatter-type">
      <option value="fox-1">Fox-1</option>
      <option value="fox-2">Fox-2</option>
      <option value="fox-3">Fox-3</option>
      <option value="fox-4">Fox-4</option>
    </select>
    <input type="file" id="chatter-file" accept="audio/*">
    <button id="upload-chatter">Upload</button>
  </div>
`;
document.body.insertAdjacentHTML('beforeend', chatterUI);

// JavaScript for Chatter Upload
document.getElementById('upload-chatter').addEventListener('click', () => {
  const chatterType = document.getElementById('chatter-type').value;
  const fileInput = document.getElementById('chatter-file');
  const file = fileInput.files[0];

  if (file) {
    const formData = new FormData();
    formData.append('chatterType', chatterType);
    formData.append('file', file);

    fetch('http://localhost:3000/uploadChatter', {
      method: 'POST',
      body: formData,
    })
      .then((response) => response.json())
      .then((data) => {
        if (data.success) {
          alert('Chatter uploaded successfully and is pending approval!');
        } else {
          alert('Failed to upload chatter.');
        }
      });
  } else {
    alert('Please select a file to upload.');
  }
});
const express = require('express');
const multer = require('multer');
const app = express();
const upload = multer({ dest: 'uploads/' });

app.post('/uploadChatter', upload.single('file'), (req, res) => {
  const { chatterType } = req.body;
  const file = req.file;

  // Save file for moderation
  console.log(`Received chatter file for ${chatterType}: ${file.originalname}`);
  res.json({ success: true });
});

app.listen(3000, () => console.log('Server running on port 3000'));
class WeaponSystem {
  constructor(airplane, foxCodeSystem) {
    this.airplane = airplane;
    this.foxCodeSystem = foxCodeSystem;
    this.missiles = [];
    this.bombs = [];
    this.flares = [];
    this.ammo = { missiles: 4, bombs: 2, flares: 5 }; // Ammo limits
    this.isRearming = false;
  }

  fireMissile(target, type) {
    if (this.ammo.missiles <= 0) {
      console.log('Out of missiles! Return to base to rearm.');
      return;
    }

    // Trigger the Fox code with a delay
    setTimeout(() => {
      this.foxCodeSystem.playFoxCode(type);
    }, 1000); // 1-second delay for realism

    // Launch the missile after the Fox code
    setTimeout(() => {
      const missile = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 2, 32),
        new THREE.MeshStandardMaterial({ color: 0xff0000 })
      );
      missile.position.copy(this.airplane.position);
      missile.userData.target = target;
      this.missiles.push(missile);
      scene.add(missile);
      console.log('Missile launched!');
      this.ammo.missiles--; // Decrease ammo count
    }, 2000); // 2-second delay for missile launch
  }

  rearm() {
    if (this.isRearming) {
      console.log('Already rearming!');
      return;
    }

    console.log('Rearming started...');
    this.isRearming = true;

    setTimeout(() => {
      this.ammo = { missiles: 4, bombs: 2, flares: 5 }; // Reset ammo
      this.isRearming = false;
      console.log('Rearming complete!');
    }, 60000); // 1-minute delay for rearming
  }
}

// Example usage
const weaponSystem = new WeaponSystem(fighterJet, foxCodeSystem);
weaponSystem.fireMissile(enemyTarget, 'fox-2');
weaponSystem.rearm(); // Rearm when landed
const io = require('socket.io')(3000);

const channels = {}; // Store channels and their members

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Create a new channel
  socket.on('createChannel', (channelName) => {
    if (!channels[channelName]) {
      channels[channelName] = [];
      console.log(`Channel created: ${channelName}`);
    }
    socket.emit('channelCreated', channelName);
  });

  // Join a channel
  socket.on('joinChannel', (channelName) => {
    if (channels[channelName]) {
      channels[channelName].push(socket.id);
      socket.join(channelName);
      console.log(`User ${socket.id} joined channel: ${channelName}`);
      io.to(channelName).emit('userJoined', socket.id);
    } else {
      socket.emit('error', 'Channel does not exist.');
    }
  });

  // Leave a channel
  socket.on('leaveChannel', (channelName) => {
    if (channels[channelName]) {
      channels[channelName] = channels[channelName].filter((id) => id !== socket.id);
      socket.leave(channelName);
      console.log(`User ${socket.id} left channel: ${channelName}`);
      io.to(channelName).emit('userLeft', socket.id);
    }
  });

  // Handle voice data
  socket.on('voiceData', ({ channelName, audioData }) => {
    if (channels[channelName]) {
      socket.to(channelName).emit('voiceData', { sender: socket.id, audioData });
    }
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    for (const channelName in channels) {
      channels[channelName] = channels[channelName].filter((id) => id !== socket.id);
      io.to(channelName).emit('userLeft', socket.id);
    }
    console.log('User disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Create a new channel
function createChannel(channelName) {
  socket.emit('createChannel', channelName);
}

// Join a channel
function joinChannel(channelName) {
  socket.emit('joinChannel', channelName);
}

// Leave a channel
function leaveChannel(channelName) {
  socket.emit('leaveChannel', channelName);
}

// Handle channel creation
socket.on('channelCreated', (channelName) => {
  console.log(`Channel created: ${channelName}`);
});

// Handle user joining
socket.on('userJoined', (userId) => {
  console.log(`User joined: ${userId}`);
});

// Handle user leaving
socket.on('userLeft', (userId) => {
  console.log(`User left: ${userId}`);
});

// Handle voice data
socket.on('voiceData', ({ sender, audioData }) => {
  const audio = new Audio(audioData);
  audio.play();
});

// Capture and send voice data
async function startVoiceChat(channelName) {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const audioContext = new AudioContext();
  const source = audioContext.createMediaStreamSource(stream);
  const processor = audioContext.createScriptProcessor(1024, 1, 1);

  processor.onaudioprocess = (event) => {
    const audioData = event.inputBuffer.getChannelData(0);
    socket.emit('voiceData', { channelName, audioData });
  };

  source.connect(processor);
  processor.connect(audioContext.destination);
}
<div id="channel-ui">
  <h3>Channels</h3>
  <input id="channel-name" placeholder="Enter channel name">
  <button id="create-channel">Create Channel</button>
  <button id="join-channel">Join Channel</button>
  <button id="leave-channel">Leave Channel</button>
  <button id="start-voice">Start Voice Chat</button>
  <div id="channel-list"></div>
</div>
#channel-ui {
  position: fixed;
  top: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px;
  border-radius: 10px;
  z-index: 1000;
}

#channel-ui input {
  width: 100%;
  margin-bottom: 10px;
}

#channel-ui button {
  margin-right: 10px;
}
document.getElementById('create-channel').addEventListener('click', () => {
  const channelName = document.getElementById('channel-name').value;
  createChannel(channelName);
});

document.getElementById('join-channel').addEventListener('click', () => {
  const channelName = document.getElementById('channel-name').value;
  joinChannel(channelName);
});

document.getElementById('leave-channel').addEventListener('click', () => {
  const channelName = document.getElementById('channel-name').value;
  leaveChannel(channelName);
});

document.getElementById('start-voice').addEventListener('click', () => {
  const channelName = document.getElementById('channel-name').value;
  startVoiceChat(channelName);
});
const io = require('socket.io')(3000);

const channels = {}; // Store channels and their members
const channelOwners = {}; // Store the owner of each channel

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  // Create a new channel
  socket.on('createChannel', (channelName) => {
    if (!channels[channelName]) {
      channels[channelName] = [];
      channelOwners[channelName] = socket.id; // Set the creator as the owner
      console.log(`Channel created: ${channelName}`);
    }
    socket.emit('channelCreated', channelName);
  });

  // Join a channel
  socket.on('joinChannel', (channelName) => {
    if (channels[channelName]) {
      channels[channelName].push(socket.id);
      socket.join(channelName);
      console.log(`User ${socket.id} joined channel: ${channelName}`);
      io.to(channelName).emit('userJoined', { userId: socket.id, channelName });
    } else {
      socket.emit('error', 'Channel does not exist.');
    }
  });

  // Leave a channel
  socket.on('leaveChannel', (channelName) => {
    if (channels[channelName]) {
      channels[channelName] = channels[channelName].filter((id) => id !== socket.id);
      socket.leave(channelName);
      console.log(`User ${socket.id} left channel: ${channelName}`);
      io.to(channelName).emit('userLeft', { userId: socket.id, channelName });
    }
  });

  // Kick a user (only by the channel owner)
  socket.on('kickUser', ({ channelName, userId }) => {
    if (channelOwners[channelName] === socket.id) {
      io.to(userId).emit('kicked', channelName);
      channels[channelName] = channels[channelName].filter((id) => id !== userId);
      io.to(channelName).emit('userKicked', { userId, channelName });
      console.log(`User ${userId} was kicked from channel: ${channelName}`);
    } else {
      socket.emit('error', 'Only the channel owner can kick users.');
    }
  });

  // Ban a user (only by the channel owner)
  socket.on('banUser', ({ channelName, userId }) => {
    if (channelOwners[channelName] === socket.id) {
      io.to(userId).emit('banned', channelName);
      channels[channelName] = channels[channelName].filter((id) => id !== userId);
      io.to(channelName).emit('userBanned', { userId, channelName });
      console.log(`User ${userId} was banned from channel: ${channelName}`);
    } else {
      socket.emit('error', 'Only the channel owner can ban users.');
    }
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    for (const channelName in channels) {
      channels[channelName] = channels[channelName].filter((id) => id !== socket.id);
      io.to(channelName).emit('userLeft', { userId: socket.id, channelName });
    }
    console.log('User disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Create a new channel
function createChannel(channelName) {
  socket.emit('createChannel', channelName);
}

// Join a channel
function joinChannel(channelName) {
  socket.emit('joinChannel', channelName);
}

// Leave a channel
function leaveChannel(channelName) {
  socket.emit('leaveChannel', channelName);
}

// Kick a user (only by the channel owner)
function kickUser(channelName, userId) {
  socket.emit('kickUser', { channelName, userId });
}

// Ban a user (only by the channel owner)
function banUser(channelName, userId) {
  socket.emit('banUser', { channelName, userId });
}

// Handle channel creation
socket.on('channelCreated', (channelName) => {
  console.log(`Channel created: ${channelName}`);
});

// Handle user joining
socket.on('userJoined', ({ userId, channelName }) => {
  console.log(`User ${userId} joined channel: ${channelName}`);
});

// Handle user leaving
socket.on('userLeft', ({ userId, channelName }) => {
  console.log(`User ${userId} left channel: ${channelName}`);
});

// Handle being kicked
socket.on('kicked', (channelName) => {
  console.log(`You were kicked from channel: ${channelName}`);
});

// Handle being banned
socket.on('banned', (channelName) => {
  console.log(`You were banned from channel: ${channelName}`);
});
// Adjust volume for a specific user
function setUserVolume(userId, volume) {
  const audioElement = document.getElementById(`audio-${userId}`);
  if (audioElement) {
    audioElement.volume = volume;
  }
}

// Push-to-talk functionality
let isTalking = false;

document.addEventListener('keydown', (event) => {
  if (event.code === 'Space') { // Spacebar for push-to-talk
    isTalking = true;
    startVoiceChat(currentChannel); // Start transmitting voice
  }
});

document.addEventListener('keyup', (event) => {
  if (event.code === 'Space') {
    isTalking = false;
    stopVoiceChat(); // Stop transmitting voice
  }
});

function startVoiceChat(channelName) {
  if (!isTalking) return;
  console.log(`Starting voice chat in channel: ${channelName}`);
  // Capture and send voice data (similar to the previous implementation)
}

function stopVoiceChat() {
  console.log('Stopping voice chat');
  // Stop transmitting voice data
}
<div id="channel-ui">
  <h3>Channels</h3>
  <input id="channel-name" placeholder="Enter channel name">
  <button id="create-channel">Create Channel</button>
  <button id="join-channel">Join Channel</button>
  <button id="leave-channel">Leave Channel</button>
  <button id="start-voice">Start Voice Chat</button>
  <div id="channel-list"></div>
  <div id="user-list"></div>
</div>
#user-list {
  margin-top: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 10px;
  border-radius: 5px;
}

.user-speaking {
  color: green;
  font-weight: bold;
}
// Update user list in the UI
function updateUserList(channelName, users) {
  const userList = document.getElementById('user-list');
  userList.innerHTML = `<h4>Users in ${channelName}:</h4>`;
  users.forEach((userId) => {
    const userElement = document.createElement('div');
    userElement.id = `user-${userId}`;
    userElement.textContent = userId;
    userList.appendChild(userElement);
  });
}

// Show speaking indicator
function setUserSpeaking(userId, isSpeaking) {
  const userElement = document.getElementById(`user-${userId}`);
  if (userElement) {
    userElement.classList.toggle('user-speaking', isSpeaking);
  }
}

// Example usage
socket.on('userJoined', ({ userId, channelName }) => {
  updateUserList(channelName, channels[channelName]);
});

socket.on('userLeft', ({ userId, channelName }) => {
  updateUserList(channelName, channels[channelName]);
});

socket.on('voiceData', ({ sender }) => {
  setUserSpeaking(sender, true);
  setTimeout(() => setUserSpeaking(sender, false), 1000); // Reset after 1 second
});
// Adjust volume for a specific user
function setUserVolume(userId, volume) {
  const audioElement = document.getElementById(`audio-${userId}`);
  if (audioElement) {
    audioElement.volume = volume;
    console.log(`Volume for user ${userId} set to ${volume}`);
  }
}

// Example: Add a volume slider for each user
function addVolumeControl(userId) {
  const userList = document.getElementById('user-list');
  const userElement = document.createElement('div');
  userElement.id = `user-${userId}`;
  userElement.innerHTML = `
    <span>User: ${userId}</span>
    <input type="range" min="0" max="1" step="0.1" value="1" 
           onchange="setUserVolume('${userId}', this.value)">
  `;
  userList.appendChild(userElement);
}

// Example usage
socket.on('userJoined', (userId) => {
  addVolumeControl(userId);
});
let isTalking = false; // For push-to-talk
let isMuted = true; // For push-to-toggle

// Push-to-Talk: Hold a key to talk
document.addEventListener('keydown', (event) => {
  if (event.code === 'Space' && !isTalking) { // Spacebar for push-to-talk
    isTalking = true;
    startVoiceChat(currentChannel);
    console.log('Push-to-Talk: Talking...');
  }
});

document.addEventListener('keyup', (event) => {
  if (event.code === 'Space' && isTalking) {
    isTalking = false;
    stopVoiceChat();
    console.log('Push-to-Talk: Muted...');
  }
});

// Push-to-Toggle: Press a key to toggle between talking and muting
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyT') { // 'T' key for push-to-toggle
    isMuted = !isMuted;
    if (!isMuted) {
      startVoiceChat(currentChannel);
      console.log('Push-to-Toggle: Talking...');
    } else {
      stopVoiceChat();
      console.log('Push-to-Toggle: Muted...');
    }
  }
});

// Start voice chat
async function startVoiceChat(channelName) {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const audioContext = new AudioContext();
  const source = audioContext.createMediaStreamSource(stream);
  const processor = audioContext.createScriptProcessor(1024, 1, 1);

  processor.onaudioprocess = (event) => {
    const audioData = event.inputBuffer.getChannelData(0);
    socket.emit('voiceData', { channelName, audioData });
  };

  source.connect(processor);
  processor.connect(audioContext.destination);
}

// Stop voice chat
function stopVoiceChat() {
  // Disconnect the audio stream or stop sending data
  console.log('Voice chat stopped.');
}
<div id="voice-chat-ui">
  <h3>Voice Chat</h3>
  <label for="mode-select">Mode:</label>
  <select id="mode-select">
    <option value="push-to-talk">Push-to-Talk</option>
    <option value="push-to-toggle">Push-to-Toggle</option>
  </select>
  <div id="user-list"></div>
</div>
#voice-chat-ui {
  position: fixed;
  bottom: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px;
  border-radius: 10px;
  z-index: 1000;
}

#voice-chat-ui select {
  margin-bottom: 10px;
}

#user-list {
  margin-top: 10px;
}
// Handle mode selection
document.getElementById('mode-select').addEventListener('change', (event) => {
  const mode = event.target.value;
  if (mode === 'push-to-talk') {
    console.log('Mode set to Push-to-Talk');
    isMuted = true; // Ensure push-to-toggle is off
  } else if (mode === 'push-to-toggle') {
    console.log('Mode set to Push-to-Toggle');
    isTalking = false; // Ensure push-to-talk is off
  }
});
// Initialize voice chat
joinChannel('dogfight-123'); // Join a specific channel

// Add volume control for a user
addVolumeControl('Player1');

// Handle push-to-talk and push-to-toggle
document.addEventListener('keydown', (event) => {
  if (event.code === 'Space') {
    startVoiceChat('dogfight-123'); // Push-to-Talk
  } else if (event.code === 'KeyT') {
    isMuted = !isMuted; // Push-to-Toggle
    if (!isMuted) startVoiceChat('dogfight-123');
    else stopVoiceChat();
  }
});
function createFighterJet({ model, fuselageColor, wingColor, engineColor, position }) {
  const jet = new THREE.Group();

  // Define model-specific dimensions
  const dimensions = {
    'FA-18F': { length: 18.31, wingspan: 13.62, engines: 2 },
    'SU-30': { length: 21.94, wingspan: 14.7, engines: 2 },
    'F-16': { length: 15.06, wingspan: 9.96, engines: 1 },
    'F-15': { length: 19.43, wingspan: 13.05, engines: 2 },
    'F-14': { length: 19.1, wingspan: 19.55, engines: 2 },
    'F-35B': { length: 15.7, wingspan: 10.7, engines: 1 },
    'F-22': { length: 18.9, wingspan: 13.56, engines: 2 },
  };

  const { length, wingspan, engines } = dimensions[model] || { length: 15, wingspan: 10, engines: 1 };

  // Fuselage
  const fuselageGeometry = new THREE.CylinderGeometry(0.5, 0.5, length, 32);
  const fuselageMaterial = new THREE.MeshStandardMaterial({ color: fuselageColor });
  const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
  fuselage.rotation.z = Math.PI / 2; // Align with x-axis
  jet.add(fuselage);

  // Wings
  const wingGeometry = new THREE.BoxGeometry(wingspan, 0.2, 2);
  const wingMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const wing = new THREE.Mesh(wingGeometry, wingMaterial);
  wing.position.set(0, 0, 0);
  jet.add(wing);

  // Engines
  const engineGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 32);
  const engineMaterial = new THREE.MeshStandardMaterial({ color: engineColor });

  for (let i = 0; i < engines; i++) {
    const engine = new THREE.Mesh(engineGeometry, engineMaterial);
    engine.rotation.z = Math.PI / 2; // Align with fuselage
    engine.position.set(-length / 2 + 1, -0.5, i === 0 ? -1 : 1); // Position engines symmetrically
    jet.add(engine);
  }

  // Tail
  const tailGeometry = new THREE.BoxGeometry(1, 2, 0.5);
  const tailMaterial = new THREE.MeshStandardMaterial({ color: wingColor });
  const tail = new THREE.Mesh(tailGeometry, tailMaterial);
  tail.position.set(length / 2 - 2, 1, 0); // Position at the rear
  jet.add(tail);

  // Position the jet
  jet.position.set(position.x, position.y, position.z);

  return jet;
}
// Add FA-18F
const fa18f = createFighterJet({
  model: 'FA-18F',
  fuselageColor: 0x333333,
  wingColor: 0x555555,
  engineColor: 0x222222,
  position: { x: 0, y: 2, z: 0 },
});
scene.add(fa18f);

// Add SU-30
const su30 = createFighterJet({
  model: 'SU-30',
  fuselageColor: 0x444444,
  wingColor: 0x666666,
  engineColor: 0x333333,
  position: { x: 20, y: 2, z: -10 },
});
scene.add(su30);

// Add F-16
const f16 = createFighterJet({
  model: 'F-16',
  fuselageColor: 0x777777,
  wingColor: 0x999999,
  engineColor: 0x555555,
  position: { x: -20, y: 2, z: 10 },
});
scene.add(f16);

// Add F-15
const f15 = createFighterJet({
  model: 'F-15',
  fuselageColor: 0x888888,
  wingColor: 0xaaaaaa,
  engineColor: 0x666666,
  position: { x: 40, y: 2, z: -20 },
});
scene.add(f15);

// Add F-14
const f14 = createFighterJet({
  model: 'F-14',
  fuselageColor: 0x999999,
  wingColor: 0xbbbbbb,
  engineColor: 0x777777,
  position: { x: -40, y: 2, z: 20 },
});
scene.add(f14);

// Add F-35B
const f35b = createFighterJet({
  model: 'F-35B',
  fuselageColor: 0xaaaaaa,
  wingColor: 0xcccccc,
  engineColor: 0x888888,
  position: { x: 60, y: 2, z: -30 },
});
scene.add(f35b);

// Add F-22
const f22 = createFighterJet({
  model: 'F-22',
  fuselageColor: 0xbbbbbb,
  wingColor: 0xdddddd,
  engineColor: 0x999999,
  position: { x: -60, y: 2, z: 30 },
});
scene.add(f22);
function addAfterburners(jet, enginePositions) {
  const afterburnerGeometry = new THREE.SphereGeometry(0.2, 16, 16);
  const afterburnerMaterial = new THREE.MeshStandardMaterial({
    emissive: 0xff4500,
    emissiveIntensity: 1,
  });

  enginePositions.forEach((pos) => {
    const afterburner = new THREE.Mesh(afterburnerGeometry, afterburnerMaterial);
    afterburner.position.set(pos.x, pos.y, pos.z);
    jet.add(afterburner);
  });
}

// Example: Add afterburners to FA-18F
addAfterburners(fa18f, [
  { x: -9, y: -0.5, z: -1 },
  { x: -9, y: -0.5, z: 1 },
]);
function animateJets() {
  [fa18f, su30, f16, f15, f14, f35b, f22].forEach((jet) => {
    jet.position.x += 0.1; // Move forward
    jet.rotation.y += 0.01; // Slight rotation
  });
}

// Add to animation loop
function animate() {
  requestAnimationFrame(animate);

  animateJets();

  renderer.render(scene, camera);
}

animate();
class WeaponSystem {
  constructor(jet) {
    this.jet = jet;
    this.missiles = [];
    this.bombs = [];
    this.guns = [];
  }

  fireMissile(target) {
    const missile = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 2, 32),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    missile.position.copy(this.jet.position);
    missile.userData.target = target;
    this.missiles.push(missile);
    scene.add(missile);

    // Play missile launch sound
    const audio = new Audio('sounds/missile-launch.mp3');
    audio.play();
  }

  dropBomb() {
    const bomb = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 16, 16),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    bomb.position.copy(this.jet.position);
    this.bombs.push(bomb);
    scene.add(bomb);

    // Play bomb drop sound
    const audio = new Audio('sounds/bomb-drop.mp3');
    audio.play();
  }

  fireGuns() {
    console.log('Firing guns!');
    // Play gunfire sound
    const audio = new Audio('sounds/gunfire.mp3');
    audio.play();
  }

  update() {
    this.missiles.forEach((missile) => {
      const target = missile.userData.target;
      missile.position.lerp(target.position, 0.05); // Move toward the target

      // Collision detection
      if (missile.position.distanceTo(target.position) < 1) {
        console.log('Target hit!');
        scene.remove(missile);
        this.missiles = this.missiles.filter((m) => m !== missile);

        // Explosion effect
        const explosion = new THREE.Mesh(
          new THREE.SphereGeometry(2, 32, 32),
          new THREE.MeshStandardMaterial({ color: 0xff4500 })
        );
        explosion.position.copy(target.position);
        scene.add(explosion);

        // Play explosion sound
        const audio = new Audio('sounds/explosion.mp3');
        audio.play();

        setTimeout(() => scene.remove(explosion), 1000); // Remove explosion after 1 second
      }
    });

    this.bombs.forEach((bomb) => {
      bomb.position.y -= 0.1; // Drop the bomb
    });
  }
}

// Example usage
const weaponSystem = new WeaponSystem(fa18f);
weaponSystem.fireMissile(enemyTarget);
weaponSystem.dropBomb();
weaponSystem.fireGuns();
class AIJet {
  constructor(jet, target) {
    this.jet = jet;
    this.target = target;
    this.speed = 0.5;
  }

  update() {
    // Move toward the target
    const direction = new THREE.Vector3().subVectors(this.target.position, this.jet.position).normalize();
    this.jet.position.addScaledVector(direction, this.speed);

    // Rotate to face the target
    this.jet.lookAt(this.target.position);

    // Fire weapons randomly
    if (Math.random() < 0.01) {
      const weaponSystem = new WeaponSystem(this.jet);
      weaponSystem.fireMissile(this.target);
    }
  }
}

// Example usage
const aiJet = new AIJet(su30, fa18f);
function animateAIJets() {
  aiJet.update();
}
function applyJetTextures(jet, textures) {
  const textureLoader = new THREE.TextureLoader();

  // Apply fuselage texture
  const fuselageMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load(textures.fuselage),
  });
  jet.children[0].material = fuselageMaterial;

  // Apply wing texture
  const wingMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load(textures.wing),
  });
  jet.children[1].material = wingMaterial;

  // Apply engine texture
  const engineMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load(textures.engine),
  });
  jet.children.slice(2).forEach((engine) => {
    engine.material = engineMaterial;
  });
}

// Example usage
applyJetTextures(fa18f, {
  fuselage: 'textures/fa18f-fuselage.jpg',
  wing: 'textures/fa18f-wing.jpg',
  engine: 'textures/fa18f-engine.jpg',
});
function setupCockpitView(jet) {
  const cockpitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  cockpitCamera.position.set(0, 1, -2); // Position inside the cockpit
  jet.add(cockpitCamera);

  return cockpitCamera;
}

// Example usage
const cockpitCamera = setupCockpitView(fa18f);

// Switch to cockpit view
function switchToCockpitView() {
  camera = cockpitCamera;
}

// Switch back to external view
function switchToExternalView() {
  camera = externalCamera;
}

// Add event listeners for switching views
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    switchToCockpitView();
  } else if (event.code === 'KeyE') {
    switchToExternalView();
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Update AI jets
  animateAIJets();

  // Update weapon systems
  weaponSystem.update();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
class WeaponSystem {
  constructor(jet) {
    this.jet = jet;
    this.missiles = [];
    this.rockets = [];
    this.clusterBombs = [];
  }

  fireGuidedMissile(target) {
    const missile = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 2, 32),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    missile.position.copy(this.jet.position);
    missile.userData.target = target;
    this.missiles.push(missile);
    scene.add(missile);

    // Add smoke trail
    const trail = new THREE.Mesh(
      new THREE.CylinderGeometry(0.05, 0.05, 1, 16),
      new THREE.MeshStandardMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.5 })
    );
    trail.position.copy(missile.position);
    scene.add(trail);

    // Play missile launch sound
    const audio = new Audio('sounds/missile-launch.mp3');
    audio.play();
  }

  fireUnguidedRocket() {
    const rocket = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 1.5, 32),
      new THREE.MeshStandardMaterial({ color: 0xff4500 })
    );
    rocket.position.copy(this.jet.position);
    rocket.rotation.x = Math.PI / 2; // Point forward
    this.rockets.push(rocket);
    scene.add(rocket);

    // Play rocket launch sound
    const audio = new Audio('sounds/rocket-launch.mp3');
    audio.play();
  }

  dropClusterBomb() {
    const bomb = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 16, 16),
      new THREE.MeshStandardMaterial({ color: 0x333333 })
    );
    bomb.position.copy(this.jet.position);
    this.clusterBombs.push(bomb);
    scene.add(bomb);

    // Play bomb drop sound
    const audio = new Audio('sounds/bomb-drop.mp3');
    audio.play();

    // Simulate cluster explosion
    setTimeout(() => {
      for (let i = 0; i < 10; i++) {
        const fragment = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 8),
          new THREE.MeshStandardMaterial({ color: 0xff4500 })
        );
        fragment.position.copy(bomb.position);
        fragment.position.x += Math.random() * 2 - 1;
        fragment.position.y += Math.random() * 2 - 1;
        fragment.position.z += Math.random() * 2 - 1;
        scene.add(fragment);

        setTimeout(() => scene.remove(fragment), 1000); // Remove fragments after 1 second
      }
      scene.remove(bomb);
    }, 2000); // Delay for cluster explosion
  }

  update() {
    this.missiles.forEach((missile) => {
      const target = missile.userData.target;
      missile.position.lerp(target.position, 0.05); // Move toward the target
    });

    this.rockets.forEach((rocket) => {
      rocket.position.z -= 0.5; // Move forward
    });

    this.clusterBombs.forEach((bomb) => {
      bomb.position.y -= 0.1; // Drop the bomb
    });
  }
}

// Example usage
const weaponSystem = new WeaponSystem(fa18f);
weaponSystem.fireGuidedMissile(enemyTarget);
weaponSystem.fireUnguidedRocket();
weaponSystem.dropClusterBomb();
class AIJet {
  constructor(jet, target, team) {
    this.jet = jet;
    this.target = target;
    this.team = team; // Team identifier
    this.speed = 0.5;
    this.evasiveCooldown = 0;
  }

  update() {
    // Move toward the target
    const direction = new THREE.Vector3().subVectors(this.target.position, this.jet.position).normalize();
    this.jet.position.addScaledVector(direction, this.speed);

    // Rotate to face the target
    this.jet.lookAt(this.target.position);

    // Perform evasive maneuvers
    if (this.evasiveCooldown <= 0 && Math.random() < 0.1) {
      this.performEvasiveManeuver();
      this.evasiveCooldown = 100; // Cooldown for evasive maneuvers
    } else {
      this.evasiveCooldown--;
    }

    // Fire weapons randomly
    if (Math.random() < 0.01) {
      const weaponSystem = new WeaponSystem(this.jet);
      weaponSystem.fireGuidedMissile(this.target);
    }
  }

  performEvasiveManeuver() {
    const roll = Math.random() < 0.5 ? 1 : -1; // Random roll direction
    this.jet.rotation.z += roll * Math.PI / 4; // Perform a barrel roll
    console.log('AI performing evasive maneuver!');
  }
}

// Example usage
const aiJet1 = new AIJet(su30, fa18f, 'red');
const aiJet2 = new AIJet(f16, f15, 'blue');

function animateAIJets() {
  aiJet1.update();
  aiJet2.update();
}
function applyJetTextures(jet, textures) {
  const textureLoader = new THREE.TextureLoader();

  // Apply fuselage texture
  const fuselageMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load(textures.fuselage),
    normalMap: textureLoader.load(textures.normalMap),
  });
  jet.children[0].material = fuselageMaterial;

  // Apply wing texture
  const wingMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load(textures.wing),
  });
  jet.children[1].material = wingMaterial;

  // Apply engine texture
  const engineMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load(textures.engine),
    emissive: 0xff4500,
    emissiveIntensity: 0.5,
  });
  jet.children.slice(2).forEach((engine) => {
    engine.material = engineMaterial;
  });
}

// Example usage
applyJetTextures(fa18f, {
  fuselage: 'textures/fa18f-fuselage.jpg',
  wing: 'textures/fa18f-wing.jpg',
  engine: 'textures/fa18f-engine.jpg',
  normalMap: 'textures/fa18f-normal.jpg',
});
function setupCockpitView(jet) {
  const cockpitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  cockpitCamera.position.set(0, 1, -2); // Position inside the cockpit
  jet.add(cockpitCamera);

  // Add interactive controls
  const hud = document.createElement('div');
  hud.id = 'cockpit-hud';
  hud.style.position = 'absolute';
  hud.style.top = '10px';
  hud.style.left = '10px';
  hud.style.color = 'white';
  hud.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  hud.style.padding = '10px';
  hud.innerHTML = `
    <p>Throttle: <span id="throttle">50%</span></p>
    <p>Altitude: <span id="altitude">1000m</span></p>
    <p>Weapon: <span id="weapon">Missile</span></p>
  `;
  document.body.appendChild(hud);

  return cockpitCamera;
}

// Example usage
const cockpitCamera = setupCockpitView(fa18f);

// Update HUD
function updateHUD(throttle, altitude, weapon) {
  document.getElementById('throttle').innerText = `${throttle}%`;
  document.getElementById('altitude').innerText = `${altitude}m`;
  document.getElementById('weapon').innerText = weapon;
}

// Switch to cockpit view
function switchToCockpitView() {
  camera = cockpitCamera;
}

// Switch back to external view
function switchToExternalView() {
  camera = externalCamera;
}

// Add event listeners for switching views
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    switchToCockpitView();
  } else if (event.code === 'KeyE') {
    switchToExternalView();
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Update AI jets
  animateAIJets();

  // Update weapon systems
  weaponSystem.update();

  // Update HUD
  updateHUD(75, 1200, 'Missile');

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function convertLatLonToXYZ(lat, lon, radius = 6371) {
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lon + 180) * (Math.PI / 180);

  const x = -(radius * Math.sin(phi) * Math.cos(theta));
  const z = radius * Math.sin(phi) * Math.sin(theta);
  const y = radius * Math.cos(phi);

  return new THREE.Vector3(x, y, z);
}

// Example: Add an airport at a specific latitude and longitude
const airportPosition = convertLatLonToXYZ(40.7128, -74.0060); // New York City
const airport = createAirport({ name: 'JFK Airport', code: 'KJFK', position: airportPosition });
scene.add(airport);
const loadedObjects = new Map();

function loadObjectsInView(playerPosition, radius = 500) {
  airports.forEach((airport) => {
    const distance = playerPosition.distanceTo(airport.position);
    if (distance < radius && !loadedObjects.has(airport.code)) {
      const airportObject = createAirport(airport);
      scene.add(airportObject);
      loadedObjects.set(airport.code, airportObject);
    } else if (distance >= radius && loadedObjects.has(airport.code)) {
      scene.remove(loadedObjects.get(airport.code));
      loadedObjects.delete(airport.code);
    }
  });
}

// Example: Update objects in view
function updateWorld(playerPosition) {
  loadObjectsInView(playerPosition);
}

// Call this in the animation loop
updateWorld(player.position);
function createLODObject(highDetail, lowDetail, position) {
  const lod = new THREE.LOD();

  lod.addLevel(highDetail, 0); // High detail for close range
  lod.addLevel(lowDetail, 500); // Low detail for far range

  lod.position.copy(position);
  return lod;
}

// Example: Create an airport with LOD
const highDetailAirport = createAirport({ name: 'High Detail Airport', code: 'HD', position: new THREE.Vector3(0, 0, 0) });
const lowDetailAirport = new THREE.Mesh(
  new THREE.BoxGeometry(10, 2, 10),
  new THREE.MeshStandardMaterial({ color: 0x888888 })
);
const airportLOD = createLODObject(highDetailAirport, lowDetailAirport, new THREE.Vector3(0, 0, 0));
scene.add(airportLOD);
const earthRadius = 6371; // Earth's radius in kilometers
const earthGeometry = new THREE.SphereGeometry(earthRadius, 64, 64);
const earthMaterial = new THREE.MeshStandardMaterial({
  map: new THREE.TextureLoader().load('textures/earth-diffuse.jpg'),
  bumpMap: new THREE.TextureLoader().load('textures/earth-bump.jpg'),
  bumpScale: 0.1,
});
const earth = new THREE.Mesh(earthGeometry, earthMaterial);
scene.add(earth);
class WeaponSystem {
  constructor(jet) {
    this.jet = jet;
    this.missiles = [];
  }

  fireMissile(target) {
    const missile = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.1, 2, 32),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    missile.position.copy(this.jet.position);
    missile.userData.target = target;
    this.missiles.push(missile);
    scene.add(missile);
  }

  update() {
    this.missiles.forEach((missile) => {
      const target = missile.userData.target;
      missile.position.lerp(target.position, 0.05); // Move toward the target
    });
  }
}
class AIJet {
  constructor(jet, target) {
    this.jet = jet;
    this.target = target;
  }

  update() {
    const direction = new THREE.Vector3().subVectors(this.target.position, this.jet.position).normalize();
    this.jet.position.addScaledVector(direction, 0.5);
    this.jet.lookAt(this.target.position);
  }
}

// Example usage
const aiJet = new AIJet(su30, fa18f);
function animateAIJets() {
  aiJet.update();
}
function setupCockpitView(jet) {
  const cockpitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  cockpitCamera.position.set(0, 1, -2); // Position inside the cockpit
  jet.add(cockpitCamera);

  const hud = document.createElement('div');
  hud.id = 'cockpit-hud';
  hud.style.position = 'absolute';
  hud.style.top = '10px';
  hud.style.left = '10px';
  hud.style.color = 'white';
  hud.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  hud.style.padding = '10px';
  hud.innerHTML = `
    <p>Throttle: <span id="throttle">50%</span></p>
    <p>Altitude: <span id="altitude">1000m</span></p>
    <p>Weapon: <span id="weapon">Missile</span></p>
  `;
  document.body.appendChild(hud);

  return cockpitCamera;
}
const io = require('socket.io')(3000);

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);

  socket.on('playerMove', (data) => {
    socket.broadcast.emit('playerMove', data); // Broadcast movement to other players
  });
});
const socket = io('http://localhost:3000');

// Send player movement
function sendPlayerMovement(position) {
  socket.emit('playerMove', { position });
}

// Receive other players' movements
socket.on('playerMove', (data) => {
  console.log('Player moved:', data.position);
});
function animate() {
  requestAnimationFrame(animate);

  // Update AI jets
  animateAIJets();

  // Update weapon systems
  weaponSystem.update();

  // Update world objects
  updateWorld(player.position);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
// Load satellite imagery and elevation data
const terrainGeometry = new THREE.PlaneGeometry(1000, 1000, 256, 256);
const terrainMaterial = new THREE.MeshStandardMaterial({
  map: new THREE.TextureLoader().load('textures/satellite-imagery.jpg'),
  displacementMap: new THREE.TextureLoader().load('textures/elevation-map.png'),
  displacementScale: 50, // Adjust elevation scale
});
const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
terrain.rotation.x = -Math.PI / 2; // Align with the ground
scene.add(terrain);
const io = require('socket.io')(3000);

const players = {}; // Store player data

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Add new player
  players[socket.id] = { position: { x: 0, y: 0, z: 0 }, rotation: { x: 0, y: 0, z: 0 } };

  // Broadcast player movement
  socket.on('playerMove', (data) => {
    players[socket.id] = data;
    socket.broadcast.emit('playerMove', { id: socket.id, data });
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    delete players[socket.id];
    io.emit('playerDisconnected', socket.id);
    console.log('Player disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Send player movement
function sendPlayerMovement(position, rotation) {
  socket.emit('playerMove', { position, rotation });
}

// Receive other players' movements
socket.on('playerMove', ({ id, data }) => {
  if (!players[id]) {
    players[id] = createFighterJet({ model: 'F-16', position: data.position });
    scene.add(players[id]);
  }
  players[id].position.set(data.position.x, data.position.y, data.position.z);
  players[id].rotation.set(data.rotation.x, data.rotation.y, data.rotation.z);
});

// Handle player disconnection
socket.on('playerDisconnected', (id) => {
  if (players[id]) {
    scene.remove(players[id]);
    delete players[id];
  }
});
function setupCockpitView(jet) {
  const cockpitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  cockpitCamera.position.set(0, 1, -2); // Position inside the cockpit
  jet.add(cockpitCamera);

  // Add HUD
  const hud = document.createElement('div');
  hud.id = 'cockpit-hud';
  hud.style.position = 'absolute';
  hud.style.top = '10px';
  hud.style.left = '10px';
  hud.style.color = 'white';
  hud.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  hud.style.padding = '10px';
  hud.innerHTML = `
    <p>Throttle: <span id="throttle">50%</span></p>
    <p>Altitude: <span id="altitude">1000m</span></p>
    <p>Weapon: <span id="weapon">Missile</span></p>
  `;
  document.body.appendChild(hud);

  // Add clickable controls
  const controlPanel = document.createElement('div');
  controlPanel.id = 'control-panel';
  controlPanel.style.position = 'absolute';
  controlPanel.style.bottom = '10px';
  controlPanel.style.left = '10px';
  controlPanel.style.color = 'white';
  controlPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  controlPanel.style.padding = '10px';
  controlPanel.innerHTML = `
    <button id="increase-throttle">Increase Throttle</button>
    <button id="decrease-throttle">Decrease Throttle</button>
    <button id="fire-weapon">Fire Weapon</button>
  `;
  document.body.appendChild(controlPanel);

  // Add event listeners for controls
  document.getElementById('increase-throttle').addEventListener('click', () => {
    throttle = Math.min(throttle + 10, 100);
    updateHUD(throttle, altitude, weapon);
  });

  document.getElementById('decrease-throttle').addEventListener('click', () => {
    throttle = Math.max(throttle - 10, 0);
    updateHUD(throttle, altitude, weapon);
  });

  document.getElementById('fire-weapon').addEventListener('click', () => {
    weaponSystem.fireMissile(enemyTarget);
  });

  return cockpitCamera;
}

// Example usage
const cockpitCamera = setupCockpitView(fa18f);
function createRain() {
  const rainGeometry = new THREE.BufferGeometry();
  const rainCount = 1000;
  const rainPositions = new Float32Array(rainCount * 3);
  for (let i = 0; i < rainCount; i++) {
    rainPositions[i * 3] = Math.random() * 100 - 50;
    rainPositions[i * 3 + 1] = Math.random() * 50;
    rainPositions[i * 3 + 2] = Math.random() * 100 - 50;
  }
  rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
  const rainMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1 });
  const rain = new THREE.Points(rainGeometry, rainMaterial);
  scene.add(rain);

  return rain;
}

// Update rain position
function animateRain(rain) {
  rain.geometry.attributes.position.array.forEach((_, i) => {
    if (i % 3 === 1) {
      rain.geometry.attributes.position.array[i] -= 0.5; // Move downward
      if (rain.geometry.attributes.position.array[i] < 0) {
        rain.geometry.attributes.position.array[i] = 50; // Reset position
      }
    }
  });
  rain.geometry.attributes.position.needsUpdate = true;
}

// Example usage
const rain = createRain();
function createSnow() {
  const snowGeometry = new THREE.BufferGeometry();
  const snowCount = 1000;
  const snowPositions = new Float32Array(snowCount * 3);
  for (let i = 0; i < snowCount; i++) {
    snowPositions[i * 3] = Math.random() * 100 - 50;
    snowPositions[i * 3 + 1] = Math.random() * 50;
    snowPositions[i * 3 + 2] = Math.random() * 100 - 50;
  }
  snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
  const snowMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2 });
  const snow = new THREE.Points(snowGeometry, snowMaterial);
  scene.add(snow);

  return snow;
}

// Update snow position
function animateSnow(snow) {
  snow.geometry.attributes.position.array.forEach((_, i) => {
    if (i % 3 === 1) {
      snow.geometry.attributes.position.array[i] -= 0.2; // Move downward
      if (snow.geometry.attributes.position.array[i] < 0) {
        snow.geometry.attributes.position.array[i] = 50; // Reset position
      }
    }
  });
  snow.geometry.attributes.position.needsUpdate = true;
}

// Example usage
const snow = createSnow();
function applyWindEffect(object, windDirection) {
  object.position.x += windDirection.x * 0.1;
  object.position.z += windDirection.z * 0.1;
}

// Example usage
const windDirection = new THREE.Vector3(1, 0, 0); // Wind blowing along the x-axis
applyWindEffect(fa18f, windDirection);
function animate() {
  requestAnimationFrame(animate);

  // Update AI jets
  animateAIJets();

  // Update weapon systems
  weaponSystem.update();

  // Update rain and snow
  animateRain(rain);
  animateSnow(snow);

  // Update HUD
  updateHUD(throttle, altitude, weapon);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function createTerrainLOD() {
  const lod = new THREE.LOD();

  // High-detail terrain (close range)
  const highDetailGeometry = new THREE.PlaneGeometry(1000, 1000, 256, 256);
  const highDetailMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load('textures/high-detail-terrain.jpg'),
    displacementMap: new THREE.TextureLoader().load('textures/high-detail-elevation.png'),
    displacementScale: 50,
  });
  const highDetailTerrain = new THREE.Mesh(highDetailGeometry, highDetailMaterial);
  highDetailTerrain.rotation.x = -Math.PI / 2;

  // Low-detail terrain (far range)
  const lowDetailGeometry = new THREE.PlaneGeometry(1000, 1000, 64, 64);
  const lowDetailMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load('textures/low-detail-terrain.jpg'),
  });
  const lowDetailTerrain = new THREE.Mesh(lowDetailGeometry, lowDetailMaterial);
  lowDetailTerrain.rotation.x = -Math.PI / 2;

  lod.addLevel(highDetailTerrain, 0); // High detail for close range
  lod.addLevel(lowDetailTerrain, 500); // Low detail for far range

  return lod;
}

// Add terrain to the scene
const terrainLOD = createTerrainLOD();
scene.add(terrainLOD);
const io = require('socket.io')(3000);

const players = {}; // Store player data
const teams = { red: [], blue: [] }; // Store team assignments

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Assign player to a team
  const team = teams.red.length <= teams.blue.length ? 'red' : 'blue';
  teams[team].push(socket.id);
  players[socket.id] = { team, position: { x: 0, y: 0, z: 0 } };

  socket.emit('teamAssigned', team);

  // Broadcast player movement
  socket.on('playerMove', (data) => {
    players[socket.id].position = data.position;
    socket.broadcast.emit('playerMove', { id: socket.id, data });
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    teams[players[socket.id].team] = teams[players[socket.id].team].filter((id) => id !== socket.id);
    delete players[socket.id];
    io.emit('playerDisconnected', socket.id);
    console.log('Player disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Handle team assignment
socket.on('teamAssigned', (team) => {
  console.log(`Assigned to team: ${team}`);
});

// Send player movement
function sendPlayerMovement(position) {
  socket.emit('playerMove', { position });
}

// Receive other players' movements
socket.on('playerMove', ({ id, data }) => {
  if (!players[id]) {
    players[id] = createFighterJet({ model: 'F-16', position: data.position });
    scene.add(players[id]);
  }
  players[id].position.set(data.position.x, data.position.y, data.position.z);
});

// Handle player disconnection
socket.on('playerDisconnected', (id) => {
  if (players[id]) {
    scene.remove(players[id]);
    delete players[id];
  }
});
function setupCockpitView(jet) {
  const cockpitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  cockpitCamera.position.set(0, 1, -2); // Position inside the cockpit
  jet.add(cockpitCamera);

  // Add HUD
  const hud = document.createElement('div');
  hud.id = 'cockpit-hud';
  hud.style.position = 'absolute';
  hud.style.top = '10px';
  hud.style.left = '10px';
  hud.style.color = 'white';
  hud.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  hud.style.padding = '10px';
  hud.innerHTML = `
    <p>Throttle: <span id="throttle">50%</span></p>
    <p>Altitude: <span id="altitude">1000m</span></p>
    <p>Weapon: <span id="weapon">Missile</span></p>
  `;
  document.body.appendChild(hud);

  // Add clickable controls
  const controlPanel = document.createElement('div');
  controlPanel.id = 'control-panel';
  controlPanel.style.position = 'absolute';
  controlPanel.style.bottom = '10px';
  controlPanel.style.left = '10px';
  controlPanel.style.color = 'white';
  controlPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  controlPanel.style.padding = '10px';
  controlPanel.innerHTML = `
    <button id="increase-throttle">Increase Throttle</button>
    <button id="decrease-throttle">Decrease Throttle</button>
    <button id="fire-weapon">Fire Weapon</button>
  `;
  document.body.appendChild(controlPanel);

  // Add event listeners for controls
  document.getElementById('increase-throttle').addEventListener('click', () => {
    throttle = Math.min(throttle + 10, 100);
    updateHUD(throttle, altitude, weapon);
  });

  document.getElementById('decrease-throttle').addEventListener('click', () => {
    throttle = Math.max(throttle - 10, 0);
    updateHUD(throttle, altitude, weapon);
  });

  document.getElementById('fire-weapon').addEventListener('click', () => {
    weaponSystem.fireMissile(enemyTarget);
  });

  return cockpitCamera;
}

// Example usage
const cockpitCamera = setupCockpitView(fa18f);
function createWeatherSystem() {
  const weather = { type: 'clear', intensity: 0 };

  function setWeather(type, intensity) {
    weather.type = type;
    weather.intensity = intensity;

    if (type === 'rain') {
      rain.visible = true;
      snow.visible = false;
    } else if (type === 'snow') {
      rain.visible = false;
      snow.visible = true;
    } else {
      rain.visible = false;
      snow.visible = false;
    }
  }

  function applyTurbulence(airplane) {
    if (weather.type !== 'clear') {
      airplane.position.x += (Math.random() - 0.5) * weather.intensity;
      airplane.position.y += (Math.random() - 0.5) * weather.intensity;
    }
  }

  return { setWeather, applyTurbulence };
}

// Example usage
const weatherSystem = createWeatherSystem();
weatherSystem.setWeather('rain', 0.5); // Set to rain with moderate intensity

function animate() {
  requestAnimationFrame(animate);

  // Apply turbulence
  weatherSystem.applyTurbulence(fa18f);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function animate() {
  requestAnimationFrame(animate);

  // Update AI jets
  animateAIJets();

  // Update weapon systems
  weaponSystem.update();

  // Update weather effects
  animateRain(rain);
  animateSnow(snow);

  // Apply turbulence
  weatherSystem.applyTurbulence(fa18f);

  // Update HUD
  updateHUD(throttle, altitude, weapon);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function createTerrainLOD() {
  const lod = new THREE.LOD();

  // High-detail terrain (close range)
  const highDetailGeometry = new THREE.PlaneGeometry(1000, 1000, 512, 512);
  const highDetailMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load('textures/high-detail-terrain.jpg'),
    displacementMap: new THREE.TextureLoader().load('textures/high-detail-elevation.png'),
    displacementScale: 50,
  });
  const highDetailTerrain = new THREE.Mesh(highDetailGeometry, highDetailMaterial);
  highDetailTerrain.rotation.x = -Math.PI / 2;

  // Medium-detail terrain (mid-range)
  const mediumDetailGeometry = new THREE.PlaneGeometry(1000, 1000, 256, 256);
  const mediumDetailMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load('textures/medium-detail-terrain.jpg'),
  });
  const mediumDetailTerrain = new THREE.Mesh(mediumDetailGeometry, mediumDetailMaterial);
  mediumDetailTerrain.rotation.x = -Math.PI / 2;

  // Low-detail terrain (far range)
  const lowDetailGeometry = new THREE.PlaneGeometry(1000, 1000, 64, 64);
  const lowDetailMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load('textures/low-detail-terrain.jpg'),
  });
  const lowDetailTerrain = new THREE.Mesh(lowDetailGeometry, lowDetailMaterial);
  lowDetailTerrain.rotation.x = -Math.PI / 2;

  lod.addLevel(highDetailTerrain, 0); // High detail for close range
  lod.addLevel(mediumDetailTerrain, 500); // Medium detail for mid-range
  lod.addLevel(lowDetailTerrain, 1000); // Low detail for far range

  return lod;
}

// Add terrain to the scene
const terrainLOD = createTerrainLOD();
scene.add(terrainLOD);
const io = require('socket.io')(3000);

const players = {}; // Store player data
const teams = { red: [], blue: [] }; // Store team assignments
const scores = { red: 0, blue: 0 }; // Team scores

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Assign player to a team
  const team = teams.red.length <= teams.blue.length ? 'red' : 'blue';
  teams[team].push(socket.id);
  players[socket.id] = { team, position: { x: 0, y: 0, z: 0 } };

  socket.emit('teamAssigned', team);

  // Handle mission completion
  socket.on('missionComplete', (team) => {
    scores[team]++;
    io.emit('updateScores', scores);
    console.log(`Team ${team} completed a mission!`);
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    teams[players[socket.id].team] = teams[players[socket.id].team].filter((id) => id !== socket.id);
    delete players[socket.id];
    io.emit('playerDisconnected', socket.id);
    console.log('Player disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Handle team assignment
socket.on('teamAssigned', (team) => {
  console.log(`Assigned to team: ${team}`);
});

// Handle score updates
socket.on('updateScores', (scores) => {
  console.log(`Scores updated: Red - ${scores.red}, Blue - ${scores.blue}`);
});

// Complete a mission
function completeMission(team) {
  socket.emit('missionComplete', team);
}
function setupCockpitView(jet) {
  const cockpitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  cockpitCamera.position.set(0, 1, -2); // Position inside the cockpit
  jet.add(cockpitCamera);

  // Add HUD
  const hud = document.createElement('div');
  hud.id = 'cockpit-hud';
  hud.style.position = 'absolute';
  hud.style.top = '10px';
  hud.style.left = '10px';
  hud.style.color = 'white';
  hud.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  hud.style.padding = '10px';
  hud.innerHTML = `
    <p>Throttle: <span id="throttle">50%</span></p>
    <p>Altitude: <span id="altitude">1000m</span></p>
    <p>Weapon: <span id="weapon">Missile</span></p>
  `;
  document.body.appendChild(hud);

  // Add clickable buttons
  const controlPanel = document.createElement('div');
  controlPanel.id = 'control-panel';
  controlPanel.style.position = 'absolute';
  controlPanel.style.bottom = '10px';
  controlPanel.style.left = '10px';
  controlPanel.style.color = 'white';
  controlPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  controlPanel.style.padding = '10px';
  controlPanel.innerHTML = `
    <button id="increase-throttle">Increase Throttle</button>
    <button id="decrease-throttle">Decrease Throttle</button>
    <button id="fire-weapon">Fire Weapon</button>
  `;
  document.body.appendChild(controlPanel);

  // Add event listeners for controls
  document.getElementById('increase-throttle').addEventListener('click', () => {
    throttle = Math.min(throttle + 10, 100);
    updateHUD(throttle, altitude, weapon);
  });

  document.getElementById('decrease-throttle').addEventListener('click', () => {
    throttle = Math.max(throttle - 10, 0);
    updateHUD(throttle, altitude, weapon);
  });

  document.getElementById('fire-weapon').addEventListener('click', () => {
    weaponSystem.fireMissile(enemyTarget);
  });

  return cockpitCamera;
}

// Example usage
const cockpitCamera = setupCockpitView(fa18f);
function createWeatherSystem() {
  const weather = { type: 'clear', intensity: 0 };

  function setWeather(type, intensity) {
    weather.type = type;
    weather.intensity = intensity;

    if (type === 'fog') {
      scene.fog = new THREE.Fog(0xaaaaaa, 10, 100);
    } else {
      scene.fog = null;
    }

    if (type === 'lightning') {
      const lightning = new THREE.PointLight(0xffffff, intensity, 500);
      lightning.position.set(Math.random() * 100 - 50, 50, Math.random() * 100 - 50);
      scene.add(lightning);
      setTimeout(() => scene.remove(lightning), 100); // Flash duration
    }
  }

  function applyWindEffect(object, windDirection) {
    object.position.x += windDirection.x * 0.1;
    object.position.z += windDirection.z * 0.1;
  }

  return { setWeather, applyWindEffect };
}

// Example usage
const weatherSystem = createWeatherSystem();
weatherSystem.setWeather('lightning', 1); // Add lightning
weatherSystem.setWeather('fog', 0.5); // Add fog
function animate() {
  requestAnimationFrame(animate);

  // Update AI jets
  animateAIJets();

  // Update weapon systems
  weaponSystem.update();

  // Update weather effects
  weatherSystem.applyWindEffect(fa18f, new THREE.Vector3(1, 0, 0)); // Apply wind

  // Update HUD
  updateHUD(throttle, altitude, weapon);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function createTerrainLOD() {
  const lod = new THREE.LOD();

  // High-detail terrain (close range)
  const highDetailGeometry = new THREE.PlaneGeometry(1000, 1000, 512, 512);
  const highDetailMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load('textures/high-detail-terrain.jpg'),
    displacementMap: new THREE.TextureLoader().load('textures/high-detail-elevation.png'),
    displacementScale: 50,
  });
  const highDetailTerrain = new THREE.Mesh(highDetailGeometry, highDetailMaterial);
  highDetailTerrain.rotation.x = -Math.PI / 2;

  // Medium-detail terrain (mid-range)
  const mediumDetailGeometry = new THREE.PlaneGeometry(1000, 1000, 256, 256);
  const mediumDetailMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load('textures/medium-detail-terrain.jpg'),
  });
  const mediumDetailTerrain = new THREE.Mesh(mediumDetailGeometry, mediumDetailMaterial);
  mediumDetailTerrain.rotation.x = -Math.PI / 2;

  // Low-detail terrain (far range)
  const lowDetailGeometry = new THREE.PlaneGeometry(1000, 1000, 64, 64);
  const lowDetailMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load('textures/low-detail-terrain.jpg'),
  });
  const lowDetailTerrain = new THREE.Mesh(lowDetailGeometry, lowDetailMaterial);
  lowDetailTerrain.rotation.x = -Math.PI / 2;

  lod.addLevel(highDetailTerrain, 0); // High detail for close range
  lod.addLevel(mediumDetailTerrain, 500); // Medium detail for mid-range
  lod.addLevel(lowDetailTerrain, 1000); // Low detail for far range

  return lod;
}

// Add terrain to the scene
const terrainLOD = createTerrainLOD();
scene.add(terrainLOD);
const io = require('socket.io')(3000);

const players = {}; // Store player data
const teams = { red: [], blue: [] }; // Store team assignments
const scores = { red: 0, blue: 0 }; // Team scores

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Assign player to a team
  const team = teams.red.length <= teams.blue.length ? 'red' : 'blue';
  teams[team].push(socket.id);
  players[socket.id] = { team, position: { x: 0, y: 0, z: 0 } };

  socket.emit('teamAssigned', team);

  // Handle mission completion
  socket.on('missionComplete', (team) => {
    scores[team]++;
    io.emit('updateScores', scores);
    console.log(`Team ${team} completed a mission!`);
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    teams[players[socket.id].team] = teams[players[socket.id].team].filter((id) => id !== socket.id);
    delete players[socket.id];
    io.emit('playerDisconnected', socket.id);
    console.log('Player disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Handle team assignment
socket.on('teamAssigned', (team) => {
  console.log(`Assigned to team: ${team}`);
});

// Handle score updates
socket.on('updateScores', (scores) => {
  console.log(`Scores updated: Red - ${scores.red}, Blue - ${scores.blue}`);
});

// Complete a mission
function completeMission(team) {
  socket.emit('missionComplete', team);
}
function setupCockpitView(jet) {
  const cockpitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  cockpitCamera.position.set(0, 1, -2); // Position inside the cockpit
  jet.add(cockpitCamera);

  // Add HUD
  const hud = document.createElement('div');
  hud.id = 'cockpit-hud';
  hud.style.position = 'absolute';
  hud.style.top = '10px';
  hud.style.left = '10px';
  hud.style.color = 'white';
  hud.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  hud.style.padding = '10px';
  hud.innerHTML = `
    <p>Throttle: <span id="throttle">50%</span></p>
    <p>Altitude: <span id="altitude">1000m</span></p>
    <p>Weapon: <span id="weapon">Missile</span></p>
  `;
  document.body.appendChild(hud);

  // Add clickable buttons
  const controlPanel = document.createElement('div');
  controlPanel.id = 'control-panel';
  controlPanel.style.position = 'absolute';
  controlPanel.style.bottom = '10px';
  controlPanel.style.left = '10px';
  controlPanel.style.color = 'white';
  controlPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  controlPanel.style.padding = '10px';
  controlPanel.innerHTML = `
    <button id="increase-throttle">Increase Throttle</button>
    <button id="decrease-throttle">Decrease Throttle</button>
    <button id="fire-weapon">Fire Weapon</button>
  `;
  document.body.appendChild(controlPanel);

  // Add event listeners for controls
  document.getElementById('increase-throttle').addEventListener('click', () => {
    throttle = Math.min(throttle + 10, 100);
    updateHUD(throttle, altitude, weapon);
  });

  document.getElementById('decrease-throttle').addEventListener('click', () => {
    throttle = Math.max(throttle - 10, 0);
    updateHUD(throttle, altitude, weapon);
  });

  document.getElementById('fire-weapon').addEventListener('click', () => {
    weaponSystem.fireMissile(enemyTarget);
  });

  return cockpitCamera;
}

// Example usage
const cockpitCamera = setupCockpitView(fa18f);
function createWeatherSystem() {
  const weather = { type: 'clear', intensity: 0 };

  function setWeather(type, intensity) {
    weather.type = type;
    weather.intensity = intensity;

    if (type === 'fog') {
      scene.fog = new THREE.Fog(0xaaaaaa, 10, 100);
    } else {
      scene.fog = null;
    }

    if (type === 'lightning') {
      const lightning = new THREE.PointLight(0xffffff, intensity, 500);
      lightning.position.set(Math.random() * 100 - 50, 50, Math.random() * 100 - 50);
      scene.add(lightning);
      setTimeout(() => scene.remove(lightning), 100); // Flash duration
    }
  }

  function applyTurbulence(airplane) {
    if (weather.type !== 'clear') {
      airplane.position.x += (Math.random() - 0.5) * weather.intensity;
      airplane.position.y += (Math.random() - 0.5) * weather.intensity;
    }
  }

  return { setWeather, applyTurbulence };
}

// Example usage
const weatherSystem = createWeatherSystem();
weatherSystem.setWeather('lightning', 1); // Add lightning
weatherSystem.setWeather('fog', 0.5); // Add fog
const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
const water = new THREE.Water(waterGeometry, {
  color: 0x001e0f,
  scale: 4,
  flowDirection: new THREE.Vector2(1, 1),
  textureWidth: 1024,
  textureHeight: 1024,
});
water.rotation.x = -Math.PI / 2;
scene.add(water);
function createAircraftCarrier() {
  const carrier = new THREE.Group();

  // Deck
  const deckGeometry = new THREE.BoxGeometry(200, 5, 50);
  const deckMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const deck = new THREE.Mesh(deckGeometry, deckMaterial);
  carrier.add(deck);

  // Control tower
  const towerGeometry = new THREE.BoxGeometry(20, 30, 10);
  const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const tower = new THREE.Mesh(towerGeometry, towerMaterial);
  tower.position.set(-80, 15, 0);
  carrier.add(tower);

  return carrier;
}

// Add aircraft carrier to the scene
const aircraftCarrier = createAircraftCarrier();
scene.add(aircraftCarrier);
function applyLivery(jet, liveryTexture) {
  const textureLoader = new THREE.TextureLoader();
  const liveryMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load(liveryTexture),
  });
  jet.children.forEach((part) => {
    part.material = liveryMaterial;
  });
}

// Example usage
applyLivery(fa18f, 'textures/fa18f-livery1.jpg');
window.addEventListener('gamepadconnected', (event) => {
  console.log('Gamepad connected:', event.gamepad);
});

function updateControllerInput() {
  const gamepads = navigator.getGamepads();
  if (gamepads[0]) {
    const axes = gamepads[0].axes;
    const buttons = gamepads[0].buttons;

    // Example: Use axes for pitch and roll
    airplane.rotation.x = axes[1] * 0.1; // Pitch
    airplane.rotation.z = axes[0] * 0.1; // Roll
  }
  requestAnimationFrame(updateControllerInput);
}

updateControllerInput();
function createBuilding(width, height, depth, color) {
  const geometry = new THREE.BoxGeometry(width, height, depth);
  const material = new THREE.MeshStandardMaterial({ color });
  const building = new THREE.Mesh(geometry, material);
  return building;
}

// Example: Add ATC tower
const atcTower = createBuilding(10, 50, 10, 0xaaaaaa);
atcTower.position.set(0, 25, 0);
scene.add(atcTower);
let cameraMode = '3rd-person';

function switchCameraMode() {
  if (cameraMode === '3rd-person') {
    camera.position.set(0, 2, -10); // 1st-person
    cameraMode = '1st-person';
  } else if (cameraMode === '1st-person') {
    camera.position.set(0, 10, 30); // 3rd-person
    cameraMode = '3rd-person';
  }
}

// Add event listener for switching camera modes
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyV') {
    switchCameraMode();
  }
});
function createAircraftCarrier() {
  const carrier = new THREE.Group();

  // Deck
  const deckGeometry = new THREE.BoxGeometry(200, 5, 50);
  const deckMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const deck = new THREE.Mesh(deckGeometry, deckMaterial);
  carrier.add(deck);

  // Runway
  const runwayGeometry = new THREE.PlaneGeometry(180, 20);
  const runwayMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
  const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
  runway.rotation.x = -Math.PI / 2;
  runway.position.set(0, 2.5, 0);
  carrier.add(runway);

  // Arresting wires
  for (let i = -40; i <= 40; i += 20) {
    const wireGeometry = new THREE.CylinderGeometry(0.1, 0.1, 20, 32);
    const wireMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
    const wire = new THREE.Mesh(wireGeometry, wireMaterial);
    wire.rotation.z = Math.PI / 2;
    wire.position.set(i, 2.6, 0);
    carrier.add(wire);
  }

  // Control tower
  const towerGeometry = new THREE.BoxGeometry(20, 30, 10);
  const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const tower = new THREE.Mesh(towerGeometry, towerMaterial);
  tower.position.set(-80, 15, 0);
  carrier.add(tower);

  return carrier;
}

// Add aircraft carrier to the scene
const aircraftCarrier = createAircraftCarrier();
scene.add(aircraftCarrier);
function addTailHook(airplane) {
  const hookGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 32);
  const hookMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const tailHook = new THREE.Mesh(hookGeometry, hookMaterial);
  tailHook.rotation.z = Math.PI / 2;
  tailHook.position.set(-3, -0.5, 0); // Position at the rear of the aircraft
  airplane.add(tailHook);

  airplane.userData.tailHook = tailHook;
}

// Example: Add tail hook to an aircraft
addTailHook(fa18f);
function detectLanding(airplane, carrier) {
  const runway = carrier.children.find((child) => child.geometry instanceof THREE.PlaneGeometry);

  // Check if the airplane is above the runway
  const distance = airplane.position.distanceTo(runway.position);
  const isAligned =
    Math.abs(airplane.position.x - runway.position.x) < 10 &&
    Math.abs(airplane.position.z - runway.position.z) < 5;

  if (distance < 10 && isAligned) {
    console.log('Landing detected!');
    initiateLanding(airplane, carrier);
  }
}

function initiateLanding(airplane, carrier) {
  const tailHook = airplane.userData.tailHook;

  // Check if the tail hook catches an arresting wire
  const wires = carrier.children.filter((child) => child.geometry instanceof THREE.CylinderGeometry);
  wires.forEach((wire) => {
    const distance = tailHook.position.distanceTo(wire.position);
    if (distance < 1) {
      console.log('Tail hook caught an arresting wire!');
      airplane.userData.isLanded = true;
      airplane.position.y = carrier.position.y + 2.5; // Align with the deck
      airplane.userData.speed = 0; // Stop the aircraft
    }
  });
}
function initiateTakeoff(airplane, carrier) {
  const runway = carrier.children.find((child) => child.geometry instanceof THREE.PlaneGeometry);

  // Align the aircraft with the runway
  airplane.position.set(runway.position.x, carrier.position.y + 2.5, runway.position.z);
  airplane.rotation.set(0, 0, 0);

  // Simulate catapult launch
  let takeoffSpeed = 0;
  const takeoffInterval = setInterval(() => {
    takeoffSpeed += 0.5;
    airplane.position.x += takeoffSpeed;

    // Takeoff complete
    if (takeoffSpeed > 10) {
      console.log('Takeoff complete!');
      clearInterval(takeoffInterval);
    }
  }, 100);
}

// Example: Trigger takeoff
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyT') {
    initiateTakeoff(fa18f, aircraftCarrier);
  }
});
function animateTailHook(airplane, isDeployed) {
  const tailHook = airplane.userData.tailHook;
  tailHook.rotation.x = isDeployed ? Math.PI / 4 : 0; // Deploy or retract the tail hook
}

// Example: Deploy the tail hook
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyH') {
    animateTailHook(fa18f, true); // Deploy
  } else if (event.code === 'KeyR') {
    animateTailHook(fa18f, false); // Retract
  }
});
function applyPhysics(airplane) {
  if (!airplane.userData.isLanded) {
    airplane.position.y -= 0.1; // Simulate gravity
  }
}

// Call this in the animation loop
function animate() {
  requestAnimationFrame(animate);

  // Apply physics
  applyPhysics(fa18f);

  // Detect landing
  detectLanding(fa18f, aircraftCarrier);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const io = require('socket.io')(3000);

const carrierState = {
  position: { x: 0, y: 0, z: 0 },
  heading: 0, // Carrier's rotation
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send the current carrier state to the new player
  socket.emit('carrierState', carrierState);

  // Update carrier state
  socket.on('updateCarrier', (state) => {
    carrierState.position = state.position;
    carrierState.heading = state.heading;
    socket.broadcast.emit('carrierState', carrierState); // Broadcast to all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Receive carrier state updates
socket.on('carrierState', (state) => {
  aircraftCarrier.position.set(state.position.x, state.position.y, state.position.z);
  aircraftCarrier.rotation.y = state.heading;
});

// Send carrier updates (e.g., if the player is controlling the carrier)
function updateCarrierState(position, heading) {
  socket.emit('updateCarrier', { position, heading });
}

// Example: Update carrier position and heading
setInterval(() => {
  const position = { x: aircraftCarrier.position.x, y: aircraftCarrier.position.y, z: aircraftCarrier.position.z };
  const heading = aircraftCarrier.rotation.y;
  updateCarrierState(position, heading);
}, 100); // Send updates every 100ms
const aircraftStates = {}; // Store the state of each aircraft

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Update aircraft state
  socket.on('updateAircraft', (state) => {
    aircraftStates[socket.id] = state;
    socket.broadcast.emit('aircraftState', { id: socket.id, state }); // Broadcast to all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    delete aircraftStates[socket.id];
    io.emit('aircraftDisconnected', socket.id); // Notify other players
    console.log('Player disconnected:', socket.id);
  });
});
// Receive aircraft state updates
socket.on('aircraftState', ({ id, state }) => {
  if (!players[id]) {
    players[id] = createFighterJet({ model: 'F-18', position: state.position });
    scene.add(players[id]);
  }
  players[id].position.set(state.position.x, state.position.y, state.position.z);
  players[id].rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
});

// Notify server of aircraft state
function updateAircraftState(position, rotation) {
  socket.emit('updateAircraft', { position, rotation });
}

// Example: Update aircraft state during animation
function animate() {
  requestAnimationFrame(animate);

  // Update local aircraft state
  const position = { x: fa18f.position.x, y: fa18f.position.y, z: fa18f.position.z };
  const rotation = { x: fa18f.rotation.x, y: fa18f.rotation.y, z: fa18f.rotation.z };
  updateAircraftState(position, rotation);

  renderer.render(scene, camera);
}

animate();
function createContrail() {
  const contrailGeometry = new THREE.CylinderGeometry(0.1, 0.1, 5, 32);
  const contrailMaterial = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.5,
  });
  const contrail = new THREE.Mesh(contrailGeometry, contrailMaterial);
  contrail.rotation.x = Math.PI / 2; // Align with the aircraft's direction
  return contrail;
}

function updateContrails(aircraft) {
  const contrail = createContrail();
  contrail.position.copy(aircraft.position);
  contrail.position.y -= 0.5; // Offset below the aircraft
  scene.add(contrail);

  // Fade out and remove contrail
  setTimeout(() => {
    contrail.material.opacity -= 0.1;
    if (contrail.material.opacity <= 0) {
      scene.remove(contrail);
    }
  }, 100);
}

// Example: Add contrails to an aircraft
setInterval(() => {
  updateContrails(fa18f);
}, 100); // Add contrails every 100ms
// Send contrail data to the server
function sendContrailData(position) {
  socket.emit('contrail', { position });
}

// Receive contrail data from other players
socket.on('contrail', ({ position }) => {
  const contrail = createContrail();
  contrail.position.set(position.x, position.y, position.z);
  scene.add(contrail);
});
function animate() {
  requestAnimationFrame(animate);

  // Update carrier position
  const carrierPosition = { x: aircraftCarrier.position.x, y: aircraftCarrier.position.y, z: aircraftCarrier.position.z };
  const carrierHeading = aircraftCarrier.rotation.y;
  updateCarrierState(carrierPosition, carrierHeading);

  // Update aircraft state
  const aircraftPosition = { x: fa18f.position.x, y: fa18f.position.y, z: fa18f.position.z };
  const aircraftRotation = { x: fa18f.rotation.x, y: fa18f.rotation.y, z: fa18f.rotation.z };
  updateAircraftState(aircraftPosition, aircraftRotation);

  // Add contrails
  updateContrails(fa18f);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function createContrail() {
  const contrailGeometry = new THREE.CylinderGeometry(0.1, 0.1, 5, 32);
  const contrailMaterial = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.8,
  });
  const contrail = new THREE.Mesh(contrailGeometry, contrailMaterial);
  contrail.rotation.x = Math.PI / 2; // Align with the aircraft's direction
  return contrail;
}

function updateContrails(aircraft) {
  const contrail = createContrail();
  contrail.position.copy(aircraft.position);
  contrail.position.y -= 0.5; // Offset below the aircraft
  scene.add(contrail);

  // Add turbulence effect
  contrail.position.x += (Math.random() - 0.5) * 0.2;
  contrail.position.z += (Math.random() - 0.5) * 0.2;

  // Fade out and remove contrail
  const fadeInterval = setInterval(() => {
    contrail.material.opacity -= 0.05;
    if (contrail.material.opacity <= 0) {
      scene.remove(contrail);
      clearInterval(fadeInterval);
    }
  }, 100);
}

// Example: Add contrails to an aircraft
setInterval(() => {
  updateContrails(fa18f);
}, 100); // Add contrails every 100ms
const io = require('socket.io')(3000);

const carrierState = {
  position: { x: 0, y: 0, z: 0 },
  heading: 0, // Carrier's rotation
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send the current carrier state to the new player
  socket.emit('carrierState', carrierState);

  // Update carrier state
  socket.on('updateCarrier', (state) => {
    carrierState.position = state.position;
    carrierState.heading = state.heading;
    socket.broadcast.emit('carrierState', carrierState); // Broadcast to all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Receive carrier state updates
socket.on('carrierState', (state) => {
  aircraftCarrier.position.set(state.position.x, state.position.y, state.position.z);
  aircraftCarrier.rotation.y = state.heading;
});

// Send carrier updates (e.g., if the player is controlling the carrier)
function updateCarrierState(position, heading) {
  socket.emit('updateCarrier', { position, heading });
}

// Example: Update carrier position and heading
setInterval(() => {
  const position = { x: aircraftCarrier.position.x, y: aircraftCarrier.position.y, z: aircraftCarrier.position.z };
  const heading = aircraftCarrier.rotation.y;
  updateCarrierState(position, heading);
}, 100); // Send updates every 100ms
const players = {}; // Store player aircraft

socket.on('aircraftState', ({ id, state }) => {
  if (!players[id]) {
    players[id] = createFighterJet({ model: 'F-18', position: state.position });
    scene.add(players[id]);
  }

  // Smooth interpolation for position and rotation
  const player = players[id];
  player.position.lerp(new THREE.Vector3(state.position.x, state.position.y, state.position.z), 0.1);
  player.rotation.set(
    THREE.MathUtils.lerp(player.rotation.x, state.rotation.x, 0.1),
    THREE.MathUtils.lerp(player.rotation.y, state.rotation.y, 0.1),
    THREE.MathUtils.lerp(player.rotation.z, state.rotation.z, 0.1)
  );
});

// Notify server of aircraft state
function updateAircraftState(position, rotation) {
  socket.emit('updateAircraft', { position, rotation });
}

// Example: Update aircraft state during animation
function animate() {
  requestAnimationFrame(animate);

  const position = { x: fa18f.position.x, y: fa18f.position.y, z: fa18f.position.z };
  const rotation = { x: fa18f.rotation.x, y: fa18f.rotation.y, z: fa18f.rotation.z };
  updateAircraftState(position, rotation);

  renderer.render(scene, camera);
}

animate();
const weatherState = { type: 'clear', intensity: 0 };

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send current weather state to the new player
  socket.emit('weatherState', weatherState);

  // Update weather state
  socket.on('updateWeather', (state) => {
    weatherState.type = state.type;
    weatherState.intensity = state.intensity;
    socket.broadcast.emit('weatherState', weatherState); // Broadcast to all other players
  });
});
socket.on('weatherState', (state) => {
  weatherSystem.setWeather(state.type, state.intensity);
});

// Update weather state
function updateWeatherState(type, intensity) {
  socket.emit('updateWeather', { type, intensity });
}

// Example: Change weather to rain
updateWeatherState('rain', 0.5);
function createCloudLayer() {
  const cloudGeometry = new THREE.SphereGeometry(50, 32, 32);
  const cloudMaterial = new THREE.MeshStandardMaterial({
    map: new THREE.TextureLoader().load('textures/cloud.png'),
    transparent: true,
    opacity: 0.8,
  });

  const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
  cloud.position.set(0, 100, 0); // Position the cloud layer above the ground
  return cloud;
}

// Add multiple cloud layers
for (let i = 0; i < 5; i++) {
  const cloud = createCloudLayer();
  cloud.position.y += i * 50; // Stack cloud layers
  scene.add(cloud);
}
function animate() {
  requestAnimationFrame(animate);

  // Update carrier position
  const carrierPosition = { x: aircraftCarrier.position.x, y: aircraftCarrier.position.y, z: aircraftCarrier.position.z };
  const carrierHeading = aircraftCarrier.rotation.y;
  updateCarrierState(carrierPosition, carrierHeading);

  // Update aircraft state
  const aircraftPosition = { x: fa18f.position.x, y: fa18f.position.y, z: fa18f.position.z };
  const aircraftRotation = { x: fa18f.rotation.x, y: fa18f.rotation.y, z: fa18f.rotation.z };
  updateAircraftState(aircraftPosition, aircraftRotation);

  // Add contrails
  updateContrails(fa18f);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function addElevator(carrier) {
  const elevatorGeometry = new THREE.BoxGeometry(10, 1, 10);
  const elevatorMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const elevator = new THREE.Mesh(elevatorGeometry, elevatorMaterial);
  elevator.position.set(-50, 0, 0); // Position the elevator on the carrier
  carrier.add(elevator);

  // Add elevator animation
  elevator.userData.isMoving = false;
  elevator.userData.direction = 1; // 1 for up, -1 for down
  elevator.userData.speed = 0.1;

  elevator.userData.move = function () {
    if (this.isMoving) {
      this.position.y += this.direction * this.speed;
      if (this.position.y > 5) {
        this.direction = -1; // Reverse direction (down)
      } else if (this.position.y < 0) {
        this.direction = 1; // Reverse direction (up)
        this.isMoving = false; // Stop the elevator
      }
    }
  };

  return elevator;
}

// Add elevator to the carrier
const elevator = addElevator(aircraftCarrier);

// Trigger elevator movement
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyE') {
    elevator.userData.isMoving = true;
  }
});

// Update elevator in the animation loop
function animateElevator() {
  elevator.userData.move();
}
function addCatapult(carrier) {
  const catapultGeometry = new THREE.BoxGeometry(2, 0.5, 20);
  const catapultMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
  const catapult = new THREE.Mesh(catapultGeometry, catapultMaterial);
  catapult.position.set(0, 2.5, 0); // Position the catapult on the flight deck
  carrier.add(catapult);

  // Add catapult animation
  catapult.userData.isLaunching = false;
  catapult.userData.speed = 0.5;

  catapult.userData.launch = function (airplane) {
    if (this.isLaunching) {
      airplane.position.x += this.speed;
      if (airplane.position.x > 50) {
        this.isLaunching = false; // Stop the launch
        console.log('Takeoff complete!');
      }
    }
  };

  return catapult;
}

// Add catapult to the carrier
const catapult = addCatapult(aircraftCarrier);

// Trigger catapult launch
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    catapult.userData.isLaunching = true;
  }
});

// Update catapult in the animation loop
function animateCatapult() {
  catapult.userData.launch(fa18f);
}
function animate() {
  requestAnimationFrame(animate);

  // Update elevator
  animateElevator();

  // Update catapult
  animateCatapult();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function addLaunchEffects(airplane) {
  const smokeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
  const smokeMaterial = new THREE.MeshStandardMaterial({
    color: 0xaaaaaa,
    transparent: true,
    opacity: 0.5,
  });

  const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
  smoke.position.copy(airplane.position);
  scene.add(smoke);

  // Animate smoke
  const smokeInterval = setInterval(() => {
    smoke.scale.multiplyScalar(1.1); // Expand smoke
    smoke.material.opacity -= 0.05; // Fade out
    if (smoke.material.opacity <= 0) {
      scene.remove(smoke);
      clearInterval(smokeInterval);
    }
  }, 100);
}

// Trigger launch effects during catapult launch
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    addLaunchEffects(fa18f);
  }
});
function addDeckLights(carrier) {
  for (let i = -90; i <= 90; i += 20) {
    const light = new THREE.PointLight(0x00ff00, 1, 10);
    light.position.set(i, 3, -20); // Position lights along the deck
    carrier.add(light);
  }
}

// Add deck lights to the carrier
addDeckLights(aircraftCarrier);
function animate() {
  requestAnimationFrame(animate);

  // Update elevator
  animateElevator();

  // Update catapult
  animateCatapult();

  // Render the scene
  renderer.render(scene, camera);
}

// Add visual effects and lights
addDeckLights(aircraftCarrier);

animate();
const io = require('socket.io')(3000);

const carrierState = {
  elevators: [{ position: 0, isMoving: false, direction: 1 }], // Elevator states
  catapults: [{ isLaunching: false }], // Catapult states
  lights: true, // Deck lights on/off
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send the current carrier state to the new player
  socket.emit('carrierState', carrierState);

  // Update elevator state
  socket.on('updateElevator', (elevatorIndex, state) => {
    carrierState.elevators[elevatorIndex] = state;
    socket.broadcast.emit('updateElevator', elevatorIndex, state); // Broadcast to all other players
  });

  // Update catapult state
  socket.on('updateCatapult', (catapultIndex, state) => {
    carrierState.catapults[catapultIndex] = state;
    socket.broadcast.emit('updateCatapult', catapultIndex, state); // Broadcast to all other players
  });

  // Update deck lights
  socket.on('updateLights', (state) => {
    carrierState.lights = state;
    socket.broadcast.emit('updateLights', state); // Broadcast to all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Receive carrier state updates
socket.on('carrierState', (state) => {
  // Update elevators
  state.elevators.forEach((elevatorState, index) => {
    const elevator = elevators[index];
    elevator.position.y = elevatorState.position;
    elevator.userData.isMoving = elevatorState.isMoving;
    elevator.userData.direction = elevatorState.direction;
  });

  // Update catapults
  state.catapults.forEach((catapultState, index) => {
    const catapult = catapults[index];
    catapult.userData.isLaunching = catapultState.isLaunching;
  });

  // Update deck lights
  setDeckLights(state.lights);
});

// Update elevator state
function updateElevatorState(elevatorIndex, state) {
  socket.emit('updateElevator', elevatorIndex, state);
}

// Update catapult state
function updateCatapultState(catapultIndex, state) {
  socket.emit('updateCatapult', catapultIndex, state);
}

// Update deck lights
function updateDeckLights(state) {
  socket.emit('updateLights', state);
}

// Example: Trigger elevator movement
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyE') {
    const elevator = elevators[0];
    elevator.userData.isMoving = true;
    updateElevatorState(0, {
      position: elevator.position.y,
      isMoving: elevator.userData.isMoving,
      direction: elevator.userData.direction,
    });
  }
});

// Example: Trigger catapult launch
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    const catapult = catapults[0];
    catapult.userData.isLaunching = true;
    updateCatapultState(0, { isLaunching: catapult.userData.isLaunching });
  }
});

// Example: Toggle deck lights
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyL') {
    const lightsOn = !carrierLightsOn;
    setDeckLights(lightsOn);
    updateDeckLights(lightsOn);
  }
});
function animateElevators() {
  elevators.forEach((elevator) => {
    if (elevator.userData.isMoving) {
      elevator.position.y += elevator.userData.direction * elevator.userData.speed;
      if (elevator.position.y > 5) {
        elevator.userData.direction = -1; // Reverse direction (down)
      } else if (elevator.position.y < 0) {
        elevator.userData.direction = 1; // Reverse direction (up)
        elevator.userData.isMoving = false; // Stop the elevator
      }
    }
  });
}
function animateCatapults() {
  catapults.forEach((catapult) => {
    if (catapult.userData.isLaunching) {
      fa18f.position.x += catapult.userData.speed;
      if (fa18f.position.x > 50) {
        catapult.userData.isLaunching = false; // Stop the launch
        console.log('Takeoff complete!');
      }
    }
  });
}
let carrierLightsOn = true;

function setDeckLights(state) {
  carrierLightsOn = state;
  deckLights.forEach((light) => {
    light.visible = carrierLightsOn;
  });
}

// Add deck lights to the carrier
const deckLights = [];
for (let i = -90; i <= 90; i += 20) {
  const light = new THREE.PointLight(0x00ff00, 1, 10);
  light.position.set(i, 3, -20); // Position lights along the deck
  aircraftCarrier.add(light);
  deckLights.push(light);
}
function animate() {
  requestAnimationFrame(animate);

  // Update elevators
  animateElevators();

  // Update catapults
  animateCatapults();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const io = require('socket.io')(3000);

const carrierState = {
  elevators: [{ position: 0, isMoving: false, direction: 1, controlledBy: null }], // Elevator states
  catapults: [{ isLaunching: false, controlledBy: null }], // Catapult states
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send the current carrier state to the new player
  socket.emit('carrierState', carrierState);

  // Update elevator state
  socket.on('updateElevator', (elevatorIndex, state) => {
    carrierState.elevators[elevatorIndex] = { ...carrierState.elevators[elevatorIndex], ...state };
    socket.broadcast.emit('updateElevator', elevatorIndex, state); // Broadcast to all other players
  });

  // Update catapult state
  socket.on('updateCatapult', (catapultIndex, state) => {
    carrierState.catapults[catapultIndex] = { ...carrierState.catapults[catapultIndex], ...state };
    socket.broadcast.emit('updateCatapult', catapultIndex, state); // Broadcast to all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);

    // Release control of elevators and catapults
    carrierState.elevators.forEach((elevator) => {
      if (elevator.controlledBy === socket.id) {
        elevator.controlledBy = null;
        elevator.isMoving = false;
      }
    });
    carrierState.catapults.forEach((catapult) => {
      if (catapult.controlledBy === socket.id) {
        catapult.controlledBy = null;
        catapult.isLaunching = false;
      }
    });

    io.emit('carrierState', carrierState); // Notify all players of the updated state
  });
});
const socket = io('http://localhost:3000');

// Receive carrier state updates
socket.on('carrierState', (state) => {
  state.elevators.forEach((elevatorState, index) => {
    const elevator = elevators[index];
    elevator.position.y = elevatorState.position;
    elevator.userData.isMoving = elevatorState.isMoving;
    elevator.userData.direction = elevatorState.direction;
    elevator.userData.controlledBy = elevatorState.controlledBy;
  });

  state.catapults.forEach((catapultState, index) => {
    const catapult = catapults[index];
    catapult.userData.isLaunching = catapultState.isLaunching;
    catapult.userData.controlledBy = catapultState.controlledBy;
  });
});

// Request control of an elevator
function controlElevator(elevatorIndex) {
  const elevator = elevators[elevatorIndex];
  if (!elevator.userData.controlledBy) {
    elevator.userData.controlledBy = socket.id;
    socket.emit('updateElevator', elevatorIndex, { controlledBy: socket.id });
    console.log(`You are now controlling elevator ${elevatorIndex}`);
  } else {
    console.log(`Elevator ${elevatorIndex} is already controlled by another player.`);
  }
}

// Request control of a catapult
function controlCatapult(catapultIndex) {
  const catapult = catapults[catapultIndex];
  if (!catapult.userData.controlledBy) {
    catapult.userData.controlledBy = socket.id;
    socket.emit('updateCatapult', catapultIndex, { controlledBy: socket.id });
    console.log(`You are now controlling catapult ${catapultIndex}`);
  } else {
    console.log(`Catapult ${catapultIndex} is already controlled by another player.`);
  }
}

// Example: Trigger elevator movement
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyE') {
    controlElevator(0); // Request control of elevator 0
    elevators[0].userData.isMoving = true;
    socket.emit('updateElevator', 0, { isMoving: true });
  }
});

// Example: Trigger catapult launch
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    controlCatapult(0); // Request control of catapult 0
    catapults[0].userData.isLaunching = true;
    socket.emit('updateCatapult', 0, { isLaunching: true });
  }
});
function createDeckCrewMember(position) {
  const crewGeometry = new THREE.BoxGeometry(1, 2, 1);
  const crewMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff }); // Blue for deck crew
  const crewMember = new THREE.Mesh(crewGeometry, crewMaterial);
  crewMember.position.set(position.x, position.y, position.z);

  // Add waving animation
  crewMember.userData.isWaving = false;
  crewMember.userData.wave = function () {
    if (this.isWaving) {
      this.rotation.z += 0.1; // Simulate waving motion
      if (this.rotation.z > 0.5 || this.rotation.z < -0.5) {
        this.rotation.z = 0; // Reset rotation
        this.isWaving = false; // Stop waving
      }
    }
  };

  return crewMember;
}

// Add deck crew to the carrier
const deckCrew = [];
for (let i = -50; i <= 50; i += 20) {
  const crewMember = createDeckCrewMember({ x: i, y: 2.5, z: -10 });
  aircraftCarrier.add(crewMember);
  deckCrew.push(crewMember);
}

// Trigger waving animation
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyW') {
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isWaving = true;
    });
  }
});

// Update deck crew animations in the animation loop
function animateDeckCrew() {
  deckCrew.forEach((crewMember) => {
    crewMember.userData.wave();
  });
}
function animate() {
  requestAnimationFrame(animate);

  // Update elevators
  animateElevators();

  // Update catapults
  animateCatapults();

  // Update deck crew
  animateDeckCrew();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function createDeckCrewMember(position, color) {
  const crewGeometry = new THREE.BoxGeometry(1, 2, 1);
  const crewMaterial = new THREE.MeshStandardMaterial({ color });
  const crewMember = new THREE.Mesh(crewGeometry, crewMaterial);
  crewMember.position.set(position.x, position.y, position.z);

  // Add signaling animation
  crewMember.userData.isSignaling = false;
  crewMember.userData.signal = function () {
    if (this.isSignaling) {
      this.rotation.z += 0.1; // Simulate signaling motion
      if (this.rotation.z > 0.5 || this.rotation.z < -0.5) {
        this.rotation.z = 0; // Reset rotation
        this.isSignaling = false; // Stop signaling
      }
    }
  };

  return crewMember;
}

// Add deck crew to the carrier
const deckCrew = [];
for (let i = -50; i <= 50; i += 20) {
  const crewMember = createDeckCrewMember({ x: i, y: 2.5, z: -10 }, 0x0000ff); // Blue for deck crew
  aircraftCarrier.add(crewMember);
  deckCrew.push(crewMember);
}

// Trigger signaling animation
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyS') {
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isSignaling = true;
    });
  }
});

// Update deck crew animations in the animation loop
function animateDeckCrew() {
  deckCrew.forEach((crewMember) => {
    crewMember.userData.signal();
  });
}
const io = require('socket.io')(3000);

const carrierState = {
  elevators: [{ position: 0, isMoving: false, direction: 1, controlledBy: null }],
  catapults: [{ isLaunching: false, controlledBy: null }],
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send the current carrier state to the new player
  socket.emit('carrierState', carrierState);

  // Request control of an elevator
  socket.on('requestElevatorControl', (elevatorIndex) => {
    const elevator = carrierState.elevators[elevatorIndex];
    if (!elevator.controlledBy) {
      elevator.controlledBy = socket.id;
      io.emit('updateElevator', elevatorIndex, elevator); // Notify all players
    } else {
      socket.emit('controlDenied', 'Elevator is already controlled by another player.');
    }
  });

  // Request control of a catapult
  socket.on('requestCatapultControl', (catapultIndex) => {
    const catapult = carrierState.catapults[catapultIndex];
    if (!catapult.controlledBy) {
      catapult.controlledBy = socket.id;
      io.emit('updateCatapult', catapultIndex, catapult); // Notify all players
    } else {
      socket.emit('controlDenied', 'Catapult is already controlled by another player.');
    }
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    carrierState.elevators.forEach((elevator) => {
      if (elevator.controlledBy === socket.id) {
        elevator.controlledBy = null;
      }
    });
    carrierState.catapults.forEach((catapult) => {
      if (catapult.controlledBy === socket.id) {
        catapult.controlledBy = null;
      }
    });
    io.emit('carrierState', carrierState); // Notify all players
    console.log('Player disconnected:', socket.id);
  });
});
// Request control of an elevator
function requestElevatorControl(elevatorIndex) {
  socket.emit('requestElevatorControl', elevatorIndex);
}

// Request control of a catapult
function requestCatapultControl(catapultIndex) {
  socket.emit('requestCatapultControl', catapultIndex);
}

// Handle control denial
socket.on('controlDenied', (message) => {
  console.log(message);
});

// Example: Trigger elevator movement
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyE') {
    requestElevatorControl(0); // Request control of elevator 0
  }
});

// Example: Trigger catapult launch
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    requestCatapultControl(0); // Request control of catapult 0
  }
});
function addLaunchEffects(airplane) {
  const smokeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
  const smokeMaterial = new THREE.MeshStandardMaterial({
    color: 0xaaaaaa,
    transparent: true,
    opacity: 0.5,
  });

  const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
  smoke.position.copy(airplane.position);
  scene.add(smoke);

  // Animate smoke
  const smokeInterval = setInterval(() => {
    smoke.scale.multiplyScalar(1.1); // Expand smoke
    smoke.material.opacity -= 0.05; // Fade out
    if (smoke.material.opacity <= 0) {
      scene.remove(smoke);
      clearInterval(smokeInterval);
    }
  }, 100);

  // Add sparks
  for (let i = 0; i < 10; i++) {
    const sparkGeometry = new THREE.SphereGeometry(0.1, 8, 8);
    const sparkMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500 });
    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
    spark.position.copy(airplane.position);
    spark.position.x += Math.random() * 2 - 1;
    spark.position.y += Math.random() * 2 - 1;
    spark.position.z += Math.random() * 2 - 1;
    scene.add(spark);

    setTimeout(() => scene.remove(spark), 500); // Remove sparks after 0.5 seconds
  }
}

// Trigger launch effects during catapult launch
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    addLaunchEffects(fa18f);
  }
});
function updateDeckCrewAI(airplane) {
  deckCrew.forEach((crewMember) => {
    const distance = crewMember.position.distanceTo(airplane.position);
    if (distance < 20) {
      crewMember.userData.isSignaling = true; // Signal when the aircraft is nearby
    } else {
      crewMember.userData.isSignaling = false;
    }
  });
}

// Call this in the animation loop
function animateDeckCrewAI() {
  updateDeckCrewAI(fa18f);
}
function animate() {
  requestAnimationFrame(animate);

  // Update elevators
  animateElevators();

  // Update catapults
  animateCatapults();

  // Update deck crew animations
  animateDeckCrew();

  // Update deck crew AI
  animateDeckCrewAI();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function createDeckCrewMember(position, color) {
  const crewGeometry = new THREE.BoxGeometry(1, 2, 1);
  const crewMaterial = new THREE.MeshStandardMaterial({ color });
  const crewMember = new THREE.Mesh(crewGeometry, crewMaterial);
  crewMember.position.set(position.x, position.y, position.z);

  // Add guiding animation
  crewMember.userData.isGuiding = false;
  crewMember.userData.guide = function () {
    if (this.userData.isGuiding) {
      this.rotation.z += 0.1; // Simulate guiding motion
      if (this.rotation.z > 0.5 || this.rotation.z < -0.5) {
        this.rotation.z = 0; // Reset rotation
        this.userData.isGuiding = false; // Stop guiding
      }
    }
  };

  return crewMember;
}

// Add deck crew to the carrier
const deckCrew = [];
for (let i = -50; i <= 50; i += 20) {
  const crewMember = createDeckCrewMember({ x: i, y: 2.5, z: -10 }, 0x0000ff); // Blue for deck crew
  aircraftCarrier.add(crewMember);
  deckCrew.push(crewMember);
}

// Trigger guiding animation
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyG') {
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isGuiding = true;
    });
  }
});

// Update deck crew animations in the animation loop
function animateDeckCrew() {
  deckCrew.forEach((crewMember) => {
    crewMember.userData.guide();
  });
}
// Update UI to show who controls each elevator or catapult
function updateControlUI() {
  const controlPanel = document.getElementById('control-panel');
  controlPanel.innerHTML = '<h3>Deck Operations</h3>';

  carrierState.elevators.forEach((elevator, index) => {
    const controller = elevator.controlledBy || 'None';
    controlPanel.innerHTML += `<p>Elevator ${index + 1}: Controlled by ${controller}</p>`;
  });

  carrierState.catapults.forEach((catapult, index) => {
    const controller = catapult.controlledBy || 'None';
    controlPanel.innerHTML += `<p>Catapult ${index + 1}: Controlled by ${controller}</p>`;
  });
}

// Update UI when carrier state changes
socket.on('carrierState', (state) => {
  carrierState = state;
  updateControlUI();
});

// Add control panel to the UI
const controlPanel = document.createElement('div');
controlPanel.id = 'control-panel';
controlPanel.style.position = 'absolute';
controlPanel.style.top = '10px';
controlPanel.style.right = '10px';
controlPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
controlPanel.style.color = 'white';
controlPanel.style.padding = '10px';
controlPanel.style.borderRadius = '5px';
document.body.appendChild(controlPanel);
function addLaunchLighting(airplane) {
  const launchLight = new THREE.PointLight(0xffa500, 2, 50); // Bright orange light
  launchLight.position.copy(airplane.position);
  scene.add(launchLight);

  // Animate light intensity
  const lightInterval = setInterval(() => {
    launchLight.intensity -= 0.1;
    if (launchLight.intensity <= 0) {
      scene.remove(launchLight);
      clearInterval(lightInterval);
    }
  }, 100);
}

// Trigger lighting effects during catapult launch
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    addLaunchLighting(fa18f);
  }
});
// Initialize Speech Recognition
const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
recognition.lang = 'en-US';
recognition.interimResults = false;

recognition.onresult = (event) => {
  const command = event.results[0][0].transcript.toLowerCase();
  console.log(`Voice Command: ${command}`);

  if (command.includes('guide aircraft')) {
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isGuiding = true;
    });
  } else if (command.includes('stop guiding')) {
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isGuiding = false;
    });
  }
};

// Start listening for voice commands
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyV') {
    recognition.start();
    console.log('Listening for voice commands...');
  }
});
function detectGesture(airplane) {
  const distance = airplane.position.distanceTo(new THREE.Vector3(0, 2.5, -10)); // Example position
  if (distance < 20) {
    console.log('Gesture detected: Aircraft is nearby');
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isGuiding = true;
    });
  }
}

// Call this in the animation loop
function animateDeckCrewAI() {
  detectGesture(fa18f);
}
function animate() {
  requestAnimationFrame(animate);

  // Update elevators
  animateElevators();

  // Update catapults
  animateCatapults();

  // Update deck crew animations
  animateDeckCrew();

  // Update deck crew AI
  animateDeckCrewAI();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function createDeckCrewMember(position, color) {
  const crewGeometry = new THREE.BoxGeometry(1, 2, 1);
  const crewMaterial = new THREE.MeshStandardMaterial({ color });
  const crewMember = new THREE.Mesh(crewGeometry, crewMaterial);
  crewMember.position.set(position.x, position.y, position.z);

  // Add gesture animations
  crewMember.userData.isStopping = false;
  crewMember.userData.isSignalingTakeoff = false;

  crewMember.userData.stopAircraft = function () {
    if (this.userData.isStopping) {
      this.rotation.z += 0.1; // Simulate stopping motion
      if (this.rotation.z > 0.5 || this.rotation.z < -0.5) {
        this.rotation.z = 0; // Reset rotation
        this.userData.isStopping = false; // Stop gesture
      }
    }
  };

  crewMember.userData.signalTakeoff = function () {
    if (this.userData.isSignalingTakeoff) {
      this.rotation.x += 0.1; // Simulate takeoff signal motion
      if (this.rotation.x > 0.5 || this.rotation.x < -0.5) {
        this.rotation.x = 0; // Reset rotation
        this.userData.isSignalingTakeoff = false; // Stop gesture
      }
    }
  };

  return crewMember;
}

// Add deck crew to the carrier
const deckCrew = [];
for (let i = -50; i <= 50; i += 20) {
  const crewMember = createDeckCrewMember({ x: i, y: 2.5, z: -10 }, 0x0000ff); // Blue for deck crew
  aircraftCarrier.add(crewMember);
  deckCrew.push(crewMember);
}

// Trigger gestures
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyS') {
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isStopping = true; // Stop aircraft
    });
  } else if (event.code === 'KeyT') {
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isSignalingTakeoff = true; // Signal takeoff
    });
  }
});

// Update deck crew animations in the animation loop
function animateDeckCrew() {
  deckCrew.forEach((crewMember) => {
    crewMember.userData.stopAircraft();
    crewMember.userData.signalTakeoff();
  });
}
io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Request control of an elevator
  socket.on('requestElevatorControl', (elevatorIndex) => {
    const elevator = carrierState.elevators[elevatorIndex];
    if (!elevator.controlledBy) {
      elevator.controlledBy = socket.id;
      io.emit('updateElevator', elevatorIndex, elevator); // Notify all players
    } else {
      socket.emit('controlDenied', `Elevator ${elevatorIndex + 1} is already controlled by another player.`);
    }
  });

  // Request control of a catapult
  socket.on('requestCatapultControl', (catapultIndex) => {
    const catapult = carrierState.catapults[catapultIndex];
    if (!catapult.controlledBy) {
      catapult.controlledBy = socket.id;
      io.emit('updateCatapult', catapultIndex, catapult); // Notify all players
    } else {
      socket.emit('controlDenied', `Catapult ${catapultIndex + 1} is already controlled by another player.`);
    }
  });
});
// Handle control denial
socket.on('controlDenied', (message) => {
  alert(message); // Display notification
});

// Example: Request control of an elevator
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyE') {
    requestElevatorControl(0); // Request control of elevator 0
  }
});

// Example: Request control of a catapult
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    requestCatapultControl(0); // Request control of catapult 0
  }
});
function addLaunchEffects(airplane) {
  const smokeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
  const smokeMaterial = new THREE.MeshStandardMaterial({
    color: 0xaaaaaa,
    transparent: true,
    opacity: 0.5,
  });

  const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
  smoke.position.copy(airplane.position);
  scene.add(smoke);

  // Animate smoke
  const smokeInterval = setInterval(() => {
    smoke.scale.multiplyScalar(1.1); // Expand smoke
    smoke.material.opacity -= 0.05; // Fade out
    if (smoke.material.opacity <= 0) {
      scene.remove(smoke);
      clearInterval(smokeInterval);
    }
  }, 100);

  // Add sparks
  for (let i = 0; i < 10; i++) {
    const sparkGeometry = new THREE.SphereGeometry(0.1, 8, 8);
    const sparkMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500 });
    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
    spark.position.copy(airplane.position);
    spark.position.x += Math.random() * 2 - 1;
    spark.position.y += Math.random() * 2 - 1;
    spark.position.z += Math.random() * 2 - 1;
    scene.add(spark);

    setTimeout(() => scene.remove(spark), 500); // Remove sparks after 0.5 seconds
  }
}

// Trigger launch effects during catapult launch
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') {
    addLaunchEffects(fa18f);
  }
});
// Initialize Speech Recognition
const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
recognition.lang = 'en-US';
recognition.interimResults = false;

recognition.onresult = (event) => {
  const command = event.results[0][0].transcript.toLowerCase();
  console.log(`Voice Command: ${command}`);

  if (command.includes('stop aircraft')) {
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isStopping = true;
    });
  } else if (command.includes('signal takeoff')) {
    deckCrew.forEach((crewMember) => {
      crewMember.userData.isSignalingTakeoff = true;
    });
  } else if (command.includes('turn on lights')) {
    setDeckLights(true); // Turn on deck lights
  } else if (command.includes('turn off lights')) {
    setDeckLights(false); // Turn off deck lights
  }
};

// Start listening for voice commands
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyV') {
    recognition.start();
    console.log('Listening for voice commands...');
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Update elevators
  animateElevators();

  // Update catapults
  animateCatapults();

  // Update deck crew animations
  animateDeckCrew();

  // Update deck crew AI
  animateDeckCrewAI();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function createShip({ name, length, width, height, color, position }) {
  const ship = new THREE.Group();

  // Hull
  const hullGeometry = new THREE.BoxGeometry(length, height, width);
  const hullMaterial = new THREE.MeshStandardMaterial({ color });
  const hull = new THREE.Mesh(hullGeometry, hullMaterial);
  hull.position.y = height / 2; // Raise hull above water level
  ship.add(hull);

  // Superstructure
  const superstructureGeometry = new THREE.BoxGeometry(length / 3, height / 2, width / 2);
  const superstructureMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const superstructure = new THREE.Mesh(superstructureGeometry, superstructureMaterial);
  superstructure.position.set(0, height, 0);
  ship.add(superstructure);

  // Add ship name
  ship.name = name;

  // Position the ship
  ship.position.set(position.x, position.y, position.z);

  return ship;
}

// Add Yamato-class ship
const yamato = createShip({
  name: 'Yamato',
  length: 263,
  width: 38.9,
  height: 15,
  color: 0x333333,
  position: { x: 0, y: 0, z: 0 },
});
scene.add(yamato);

// Add Iowa-class ship
const iowa = createShip({
  name: 'USS Iowa',
  length: 270,
  width: 33,
  height: 15,
  color: 0x444444,
  position: { x: 300, y: 0, z: 0 },
});
scene.add(iowa);

// Add HMS Dreadnought
const dreadnought = createShip({
  name: 'HMS Dreadnought',
  length: 160,
  width: 25,
  height: 12,
  color: 0x555555,
  position: { x: -300, y: 0, z: 0 },
});
scene.add(dreadnought);
function applyShipPhysics(ship) {
  // Simulate buoyancy
  const waterLevel = 0; // Assume water level is at y = 0
  if (ship.position.y < waterLevel) {
    ship.position.y += 0.1; // Push ship upward
  } else if (ship.position.y > waterLevel) {
    ship.position.y -= 0.1; // Pull ship downward
  }

  // Simulate drag
  ship.userData.velocity = ship.userData.velocity || new THREE.Vector3(0, 0, 0);
  ship.userData.velocity.multiplyScalar(0.98); // Apply drag
  ship.position.add(ship.userData.velocity);
}

// Call this in the animation loop
function animateShips() {
  [yamato, iowa, dreadnought].forEach((ship) => {
    applyShipPhysics(ship);
  });
}
function controlShip(ship) {
  document.addEventListener('keydown', (event) => {
    const speed = 0.5;
    const rotationSpeed = 0.02;

    switch (event.code) {
      case 'ArrowUp': // Move forward
        ship.userData.velocity.z -= speed;
        break;
      case 'ArrowDown': // Move backward
        ship.userData.velocity.z += speed;
        break;
      case 'ArrowLeft': // Turn left
        ship.rotation.y += rotationSpeed;
        break;
      case 'ArrowRight': // Turn right
        ship.rotation.y -= rotationSpeed;
        break;
    }
  });
}

// Enable controls for Yamato
controlShip(yamato);
function addTurrets(ship, turretPositions) {
  const turrets = [];

  turretPositions.forEach((pos) => {
    const turretGeometry = new THREE.CylinderGeometry(2, 2, 5, 32);
    const turretMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const turret = new THREE.Mesh(turretGeometry, turretMaterial);
    turret.rotation.x = Math.PI / 2; // Align turret horizontally
    turret.position.set(pos.x, pos.y, pos.z);
    ship.add(turret);
    turrets.push(turret);
  });

  return turrets;
}

// Add turrets to Yamato
const yamatoTurrets = addTurrets(yamato, [
  { x: 0, y: 15, z: -20 },
  { x: 0, y: 15, z: 0 },
  { x: 0, y: 15, z: 20 },
]);

// Fire shells
function fireShell(turret) {
  const shellGeometry = new THREE.SphereGeometry(1, 16, 16);
  const shellMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
  const shell = new THREE.Mesh(shellGeometry, shellMaterial);
  shell.position.copy(turret.position);
  shell.userData.velocity = new THREE.Vector3(0, 0, -2).applyQuaternion(turret.quaternion);
  scene.add(shell);

  // Animate shell
  const shellInterval = setInterval(() => {
    shell.position.add(shell.userData.velocity);
    if (shell.position.z < -500) {
      scene.remove(shell);
      clearInterval(shellInterval);
    }
  }, 16);
}

// Trigger turret fire
document.addEventListener('keydown', (event) => {
  if (event.code === 'Space') {
    yamatoTurrets.forEach((turret) => fireShell(turret));
  }
});
const io = require('socket.io')(3000);

const ships = {
  yamato: { position: { x: 0, y: 0, z: 0 }, rotation: { y: 0 } },
  iowa: { position: { x: 300, y: 0, z: 0 }, rotation: { y: 0 } },
  dreadnought: { position: { x: -300, y: 0, z: 0 }, rotation: { y: 0 } },
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send initial ship states
  socket.emit('shipStates', ships);

  // Update ship state
  socket.on('updateShip', (shipName, state) => {
    ships[shipName] = state;
    socket.broadcast.emit('updateShip', shipName, state);
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
const socket = io('http://localhost:3000');

// Receive initial ship states
socket.on('shipStates', (states) => {
  yamato.position.set(states.yamato.position.x, states.yamato.position.y, states.yamato.position.z);
  yamato.rotation.y = states.yamato.rotation.y;

  iowa.position.set(states.iowa.position.x, states.iowa.position.y, states.iowa.position.z);
  iowa.rotation.y = states.iowa.rotation.y;

  dreadnought.position.set(states.dreadnought.position.x, states.dreadnought.position.y, states.dreadnought.position.z);
  dreadnought.rotation.y = states.dreadnought.rotation.y;
});

// Send ship updates
function updateShipState(shipName, ship) {
  const state = {
    position: { x: ship.position.x, y: ship.position.y, z: ship.position.z },
    rotation: { y: ship.rotation.y },
  };
  socket.emit('updateShip', shipName, state);
}

// Example: Update Yamato's state during animation
function animate() {
  requestAnimationFrame(animate);

  updateShipState('yamato', yamato);

  animateShips();
  renderer.render(scene, camera);
}

animate();
const waterGeometry = new THREE.PlaneGeometry(10000, 10000);
const water = new THREE.Water(waterGeometry, {
  color: 0x001e0f,
  scale: 4,
  flowDirection: new THREE.Vector2(1, 1),
  textureWidth: 1024,
  textureHeight: 1024,
});
water.rotation.x = -Math.PI / 2;
scene.add(water);
function applyShipTextures(ship, textures) {
  const textureLoader = new THREE.TextureLoader();

  // Apply hull texture
  const hullMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load(textures.hull),
    normalMap: textureLoader.load(textures.hullNormal),
  });
  ship.children[0].material = hullMaterial; // Assuming the hull is the first child

  // Apply superstructure texture
  const superstructureMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load(textures.superstructure),
  });
  ship.children[1].material = superstructureMaterial; // Assuming the superstructure is the second child
}

// Example: Apply textures to Yamato
applyShipTextures(yamato, {
  hull: 'textures/yamato-hull.jpg',
  hullNormal: 'textures/yamato-hull-normal.jpg',
  superstructure: 'textures/yamato-superstructure.jpg',
});
function addHealthBar(ship) {
  const healthBarGeometry = new THREE.PlaneGeometry(10, 1);
  const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
  healthBar.position.set(0, 20, 0); // Position above the ship
  ship.add(healthBar);

  ship.userData.health = 100; // Initial health
  ship.userData.healthBar = healthBar;
}

function updateHealth(ship, damage) {
  ship.userData.health -= damage;
  if (ship.userData.health <= 0) {
    console.log(`${ship.name} has been destroyed!`);
    scene.remove(ship); // Remove the ship from the scene
  } else {
    // Update health bar color and size
    const healthPercentage = ship.userData.health / 100;
    ship.userData.healthBar.scale.x = healthPercentage;
    ship.userData.healthBar.material.color.set(healthPercentage > 0.5 ? 0x00ff00 : 0xff0000);
  }
}

// Example: Add health bars to ships
[yamato, iowa, dreadnought].forEach((ship) => addHealthBar(ship));

// Example: Apply damage to Yamato
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyD') {
    updateHealth(yamato, 10); // Apply 10 damage
  }
});
const io = require('socket.io')(3000);

const shells = []; // Store active shells

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast shell fire
  socket.on('fireShell', (data) => {
    shells.push(data);
    socket.broadcast.emit('fireShell', data); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Fire a shell and notify the server
function fireShell(turret) {
  const shellGeometry = new THREE.SphereGeometry(1, 16, 16);
  const shellMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
  const shell = new THREE.Mesh(shellGeometry, shellMaterial);
  shell.position.copy(turret.position);
  shell.userData.velocity = new THREE.Vector3(0, 0, -2).applyQuaternion(turret.quaternion);
  scene.add(shell);

  // Notify the server
  socket.emit('fireShell', { position: shell.position, velocity: shell.userData.velocity });

  // Animate shell
  const shellInterval = setInterval(() => {
    shell.position.add(shell.userData.velocity);
    if (shell.position.z < -500) {
      scene.remove(shell);
      clearInterval(shellInterval);
    }
  }, 16);
}

// Receive shell fire from other players
socket.on('fireShell', (data) => {
  const shellGeometry = new THREE.SphereGeometry(1, 16, 16);
  const shellMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
  const shell = new THREE.Mesh(shellGeometry, shellMaterial);
  shell.position.set(data.position.x, data.position.y, data.position.z);
  shell.userData.velocity = new THREE.Vector3(data.velocity.x, data.velocity.y, data.velocity.z);
  scene.add(shell);

  // Animate shell
  const shellInterval = setInterval(() => {
    shell.position.add(shell.userData.velocity);
    if (shell.position.z < -500) {
      scene.remove(shell);
      clearInterval(shellInterval);
    }
  }, 16);
});
class AIShip {
  constructor(ship, target) {
    this.ship = ship;
    this.target = target;
    this.speed = 0.5;
  }

  update() {
    // Move toward the target
    const direction = new THREE.Vector3().subVectors(this.target.position, this.ship.position).normalize();
    this.ship.position.addScaledVector(direction, this.speed);

    // Rotate to face the target
    this.ship.lookAt(this.target.position);

    // Fire weapons randomly
    if (Math.random() < 0.01) {
      const turret = this.ship.children.find((child) => child.geometry instanceof THREE.CylinderGeometry);
      fireShell(turret);
    }
  }
}

// Example: Add AI ships
const aiShip1 = new AIShip(iowa, yamato);
const aiShip2 = new AIShip(dreadnought, iowa);

function animateAIShips() {
  aiShip1.update();
  aiShip2.update();
}
function animate() {
  requestAnimationFrame(animate);

  // Update AI ships
  animateAIShips();

  // Update ship physics
  animateShips();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
class AIShip {
  constructor(ship, target, team) {
    this.ship = ship;
    this.target = target;
    this.team = team; // Team identifier
    this.speed = 0.5;
    this.evasiveCooldown = 0;
  }

  update() {
    // Move toward the target
    const direction = new THREE.Vector3().subVectors(this.target.position, this.ship.position).normalize();
    this.ship.position.addScaledVector(direction, this.speed);

    // Rotate to face the target
    this.ship.lookAt(this.target.position);

    // Perform evasive maneuvers
    if (this.evasiveCooldown <= 0 && Math.random() < 0.1) {
      this.performEvasiveManeuver();
      this.evasiveCooldown = 100; // Cooldown for evasive maneuvers
    } else {
      this.evasiveCooldown--;
    }

    // Fire weapons randomly
    if (Math.random() < 0.01) {
      const turret = this.ship.children.find((child) => child.geometry instanceof THREE.CylinderGeometry);
      fireShell(turret);
    }
  }

  performEvasiveManeuver() {
    const roll = Math.random() < 0.5 ? 1 : -1; // Random roll direction
    this.ship.rotation.y += roll * Math.PI / 4; // Perform a sharp turn
    console.log(`${this.ship.name} performing evasive maneuver!`);
  }
}

// Example: Add AI ships
const aiShip1 = new AIShip(iowa, yamato, 'red');
const aiShip2 = new AIShip(dreadnought, iowa, 'blue');

function animateAIShips() {
  aiShip1.update();
  aiShip2.update();
}
const io = require('socket.io')(3000);

const ships = {
  yamato: { health: 100, position: { x: 0, y: 0, z: 0 }, rotation: { y: 0 } },
  iowa: { health: 100, position: { x: 300, y: 0, z: 0 }, rotation: { y: 0 } },
  dreadnought: { health: 100, position: { x: -300, y: 0, z: 0 }, rotation: { y: 0 } },
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send initial ship states
  socket.emit('shipStates', ships);

  // Update ship health
  socket.on('updateHealth', (shipName, damage) => {
    ships[shipName].health -= damage;
    if (ships[shipName].health <= 0) {
      console.log(`${shipName} has been destroyed!`);
    }
    io.emit('updateHealth', shipName, ships[shipName].health); // Broadcast updated health
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Receive health updates
socket.on('updateHealth', (shipName, health) => {
  const ship = ships[shipName];
  ship.userData.health = health;
  updateHealthBar(ship);
});

// Apply damage to a ship and notify the server
function applyDamage(ship, damage) {
  socket.emit('updateHealth', ship.name, damage);
}

// Example: Apply damage to Yamato
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyD') {
    applyDamage(yamato, 10); // Apply 10 damage
  }
});
function addExplosion(position) {
  const explosionGeometry = new THREE.SphereGeometry(5, 32, 32);
  const explosionMaterial = new THREE.MeshStandardMaterial({
    color: 0xff4500,
    emissive: 0xff0000,
    emissiveIntensity: 1,
    transparent: true,
    opacity: 0.8,
  });
  const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
  explosion.position.copy(position);
  scene.add(explosion);

  // Animate explosion
  const explosionInterval = setInterval(() => {
    explosion.scale.multiplyScalar(1.1); // Expand explosion
    explosion.material.opacity -= 0.05; // Fade out
    if (explosion.material.opacity <= 0) {
      scene.remove(explosion);
      clearInterval(explosionInterval);
    }
  }, 100);
}

function addWaterSplash(position) {
  const splashGeometry = new THREE.CircleGeometry(5, 32);
  const splashMaterial = new THREE.MeshStandardMaterial({
    color: 0x00aaff,
    transparent: true,
    opacity: 0.5,
  });
  const splash = new THREE.Mesh(splashGeometry, splashMaterial);
  splash.rotation.x = -Math.PI / 2; // Align with the water surface
  splash.position.copy(position);
  scene.add(splash);

  // Animate splash
  const splashInterval = setInterval(() => {
    splash.scale.multiplyScalar(1.1); // Expand splash
    splash.material.opacity -= 0.05; // Fade out
    if (splash.material.opacity <= 0) {
      scene.remove(splash);
      clearInterval(splashInterval);
    }
  }, 100);
}

// Trigger effects on shell impact
function handleShellImpact(shell) {
  addExplosion(shell.position);
  addWaterSplash(shell.position);
  scene.remove(shell);
}
function upgradeShip(ship, upgrades) {
  if (upgrades.armor) {
    ship.userData.armor += upgrades.armor;
    console.log(`${ship.name} armor upgraded by ${upgrades.armor}`);
  }
  if (upgrades.weapons) {
    ship.userData.weapons.push(...upgrades.weapons);
    console.log(`${ship.name} weapons upgraded: ${upgrades.weapons.join(', ')}`);
  }
}

// Example: Upgrade Yamato
upgradeShip(yamato, {
  armor: 20,
  weapons: ['Torpedo Launcher', 'Anti-Aircraft Guns'],
});
function createSubmarine({ name, length, width, height, color, position }) {
  const submarine = new THREE.Group();

  // Hull
  const hullGeometry = new THREE.CylinderGeometry(width / 2, width / 2, length, 32);
  const hullMaterial = new THREE.MeshStandardMaterial({ color });
  const hull = new THREE.Mesh(hullGeometry, hullMaterial);
  hull.rotation.z = Math.PI / 2; // Align with x-axis
  submarine.add(hull);

  // Conning tower
  const towerGeometry = new THREE.BoxGeometry(width / 2, height, width / 2);
  const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const tower = new THREE.Mesh(towerGeometry, towerMaterial);
  tower.position.set(0, height / 2, 0);
  submarine.add(tower);

  submarine.name = name;
  submarine.position.set(position.x, position.y, position.z);

  return submarine;
}

// Add a submarine
const submarine = createSubmarine({
  name: 'U-Boat',
  length: 70,
  width: 10,
  height: 15,
  color: 0x333333,
  position: { x: 0, y: -10, z: 0 },
});
scene.add(submarine);
function createInterior(ship) {
  const interior = new THREE.Group();

  // Add rooms
  const roomGeometry = new THREE.BoxGeometry(10, 5, 10);
  const roomMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
  for (let i = 0; i < 5; i++) {
    const room = new THREE.Mesh(roomGeometry, roomMaterial);
    room.position.set(0, 5, i * 15 - 30); // Stack rooms along the ship
    interior.add(room);
  }

  // Add control room
  const controlRoomGeometry = new THREE.BoxGeometry(15, 5, 15);
  const controlRoomMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const controlRoom = new THREE.Mesh(controlRoomGeometry, controlRoomMaterial);
  controlRoom.position.set(0, 5, 30);
  interior.add(controlRoom);

  ship.add(interior);
}

// Add interiors to ships
createInterior(yamato);
createInterior(iowa);
createInterior(dreadnought);
function animate() {
  requestAnimationFrame(animate);

  // Update AI ships
  animateAIShips();

  // Update ship physics
  animateShips();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function addTorpedoSystem(submarine) {
  submarine.userData.torpedoes = [];

  submarine.userData.fireTorpedo = function (target) {
    const torpedoGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 32);
    const torpedoMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const torpedo = new THREE.Mesh(torpedoGeometry, torpedoMaterial);
    torpedo.rotation.z = Math.PI / 2; // Align with the submarine's direction
    torpedo.position.copy(submarine.position);
    torpedo.userData.velocity = new THREE.Vector3(0, 0, -1).applyQuaternion(submarine.quaternion);
    torpedo.userData.target = target;
    scene.add(torpedo);
    submarine.userData.torpedoes.push(torpedo);

    // Animate torpedo
    const torpedoInterval = setInterval(() => {
      torpedo.position.add(torpedo.userData.velocity);
      if (torpedo.position.distanceTo(target.position) < 5) {
        handleTorpedoImpact(torpedo, target);
        clearInterval(torpedoInterval);
      }
    }, 16);
  };
}

function handleTorpedoImpact(torpedo, target) {
  addExplosion(torpedo.position);
  updateHealth(target, 20); // Apply 20 damage to the target
  scene.remove(torpedo);
}

// Add torpedo system to the submarine
addTorpedoSystem(submarine);

// Fire a torpedo
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyT') {
    submarine.userData.fireTorpedo(yamato); // Fire at Yamato
  }
});
function enableInteriorInteractivity(ship) {
  const player = new THREE.Mesh(
    new THREE.BoxGeometry(1, 2, 1),
    new THREE.MeshStandardMaterial({ color: 0x00ff00 })
  );
  player.position.set(0, 5, 0); // Start inside the ship
  ship.add(player);

  document.addEventListener('keydown', (event) => {
    const speed = 0.5;
    switch (event.code) {
      case 'ArrowUp': // Move forward
        player.position.z -= speed;
        break;
      case 'ArrowDown': // Move backward
        player.position.z += speed;
        break;
      case 'ArrowLeft': // Move left
        player.position.x -= speed;
        break;
      case 'ArrowRight': // Move right
        player.position.x += speed;
        break;
    }
  });
}

// Enable interior interactivity for ships
enableInteriorInteractivity(yamato);
enableInteriorInteractivity(iowa);
enableInteriorInteractivity(dreadnought);
const io = require('socket.io')(3000);

const submarines = {
  uBoat: { position: { x: 0, y: -10, z: 0 }, rotation: { y: 0 }, health: 100 },
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send initial submarine states
  socket.emit('submarineStates', submarines);

  // Update submarine state
  socket.on('updateSubmarine', (submarineName, state) => {
    submarines[submarineName] = state;
    socket.broadcast.emit('updateSubmarine', submarineName, state);
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Receive initial submarine states
socket.on('submarineStates', (states) => {
  submarine.position.set(states.uBoat.position.x, states.uBoat.position.y, states.uBoat.position.z);
  submarine.rotation.y = states.uBoat.rotation.y;
});

// Send submarine updates
function updateSubmarineState(submarine) {
  const state = {
    position: { x: submarine.position.x, y: submarine.position.y, z: submarine.position.z },
    rotation: { y: submarine.rotation.y },
    health: submarine.userData.health,
  };
  socket.emit('updateSubmarine', 'uBoat', state);
}

// Example: Update submarine state during animation
function animate() {
  requestAnimationFrame(animate);

  updateSubmarineState(submarine);

  renderer.render(scene, camera);
}

animate();
function addUnderwaterBubbles(submarine) {
  const bubbleGeometry = new THREE.SphereGeometry(0.2, 16, 16);
  const bubbleMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.5 });

  const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
  bubble.position.copy(submarine.position);
  bubble.position.y += 2; // Offset above the submarine
  scene.add(bubble);

  // Animate bubble
  const bubbleInterval = setInterval(() => {
    bubble.position.y += 0.1; // Move upward
    bubble.material.opacity -= 0.01; // Fade out
    if (bubble.material.opacity <= 0) {
      scene.remove(bubble);
      clearInterval(bubbleInterval);
    }
  }, 100);
}

// Add bubbles periodically
setInterval(() => {
  addUnderwaterBubbles(submarine);
}, 500); // Add bubbles every 500ms

function addSonarPing(submarine) {
  const pingGeometry = new THREE.RingGeometry(1, 1.5, 32);
  const pingMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
  const ping = new THREE.Mesh(pingGeometry, pingMaterial);
  ping.position.copy(submarine.position);
  ping.rotation.x = -Math.PI / 2; // Align with the water surface
  scene.add(ping);

  // Animate sonar ping
  const pingInterval = setInterval(() => {
    ping.scale.multiplyScalar(1.1); // Expand ping
    ping.material.opacity -= 0.02; // Fade out
    if (ping.material.opacity <= 0) {
      scene.remove(ping);
      clearInterval(pingInterval);
    }
  }, 100);
}

// Trigger sonar ping
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyP') {
    addSonarPing(submarine);
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Update AI ships
  animateAIShips();

  // Update ship physics
  animateShips();

  // Update submarine state
  updateSubmarineState(submarine);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function enableSubmarineStealth(submarine) {
  submarine.userData.depth = 0; // Initial depth
  submarine.userData.isStealth = false;

  document.addEventListener('keydown', (event) => {
    const depthChange = 1;
    switch (event.code) {
      case 'KeyW': // Dive deeper
        submarine.userData.depth += depthChange;
        submarine.position.y -= depthChange;
        break;
      case 'KeyS': // Surface
        if (submarine.userData.depth > 0) {
          submarine.userData.depth -= depthChange;
          submarine.position.y += depthChange;
        }
        break;
      case 'KeyH': // Enable stealth mode
        submarine.userData.isStealth = true;
        console.log(`${submarine.name} is now in stealth mode.`);
        break;
      case 'KeyJ': // Disable stealth mode
        submarine.userData.isStealth = false;
        console.log(`${submarine.name} exited stealth mode.`);
        break;
    }
  });
}

// Enable stealth mechanics for the submarine
enableSubmarineStealth(submarine);
function addInteractiveInterior(submarine) {
  const controlPanelGeometry = new THREE.BoxGeometry(5, 2, 1);
  const controlPanelMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const controlPanel = new THREE.Mesh(controlPanelGeometry, controlPanelMaterial);
  controlPanel.position.set(0, 2, 5); // Position inside the submarine
  submarine.add(controlPanel);

  const periscopeGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 32);
  const periscopeMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const periscope = new THREE.Mesh(periscopeGeometry, periscopeMaterial);
  periscope.position.set(0, 10, 0); // Position above the submarine
  submarine.add(periscope);

  // Add walking mechanics
  const player = new THREE.Mesh(
    new THREE.BoxGeometry(1, 2, 1),
    new THREE.MeshStandardMaterial({ color: 0x00ff00 })
  );
  player.position.set(0, 2, 0); // Start inside the submarine
  submarine.add(player);

  document.addEventListener('keydown', (event) => {
    const speed = 0.5;
    switch (event.code) {
      case 'ArrowUp': // Move forward
        player.position.z -= speed;
        break;
      case 'ArrowDown': // Move backward
        player.position.z += speed;
        break;
      case 'ArrowLeft': // Move left
        player.position.x -= speed;
        break;
      case 'ArrowRight': // Move right
        player.position.x += speed;
        break;
    }
  });
}

// Add interactive interior to the submarine
addInteractiveInterior(submarine);
const io = require('socket.io')(3000);

const torpedoes = [];
const sonarPings = [];

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast torpedo fire
  socket.on('fireTorpedo', (data) => {
    torpedoes.push(data);
    socket.broadcast.emit('fireTorpedo', data); // Notify all other players
  });

  // Broadcast sonar ping
  socket.on('sonarPing', (data) => {
    sonarPings.push(data);
    socket.broadcast.emit('sonarPing', data); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Fire a torpedo and notify the server
function fireTorpedo(target) {
  const torpedo = {
    position: submarine.position.clone(),
    velocity: new THREE.Vector3(0, 0, -1).applyQuaternion(submarine.quaternion),
    target,
  };
  socket.emit('fireTorpedo', torpedo);

  // Animate torpedo locally
  animateTorpedo(torpedo);
}

// Receive torpedo fire from other players
socket.on('fireTorpedo', (data) => {
  animateTorpedo(data);
});

// Trigger sonar ping and notify the server
function triggerSonarPing() {
  const ping = { position: submarine.position.clone() };
  socket.emit('sonarPing', ping);

  // Animate sonar ping locally
  addSonarPing(submarine);
}

// Receive sonar pings from other players
socket.on('sonarPing', (data) => {
  addSonarPing(data.position);
});
function addUnderwaterLighting() {
  const light = new THREE.PointLight(0x00aaff, 1, 50); // Blue light for underwater effect
  light.position.set(0, -10, 0); // Position underwater
  scene.add(light);

  // Animate light flickering
  setInterval(() => {
    light.intensity = 0.8 + Math.random() * 0.4; // Flicker effect
  }, 100);
}

// Add underwater lighting
addUnderwaterLighting();
function animate() {
  requestAnimationFrame(animate);

  // Update AI ships
  animateAIShips();

  // Update ship physics
  animateShips();

  // Update submarine state
  updateSubmarineState(submarine);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function addInteractiveInterior(submarine) {
  // Create control panel
  const controlPanelGeometry = new THREE.BoxGeometry(5, 2, 1);
  const controlPanelMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const controlPanel = new THREE.Mesh(controlPanelGeometry, controlPanelMaterial);
  controlPanel.position.set(0, 2, 5); // Position inside the submarine
  submarine.add(controlPanel);

  // Add click interaction for the control panel
  controlPanel.userData.onClick = () => {
    console.log('Control panel clicked!');
    submarine.userData.isStealth = !submarine.userData.isStealth;
    console.log(`${submarine.name} stealth mode: ${submarine.userData.isStealth ? 'ON' : 'OFF'}`);
  };

  // Create periscope
  const periscopeGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 32);
  const periscopeMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const periscope = new THREE.Mesh(periscopeGeometry, periscopeMaterial);
  periscope.position.set(0, 10, 0); // Position above the submarine
  submarine.add(periscope);

  // Add periscope functionality
  periscope.userData.onClick = () => {
    console.log('Periscope activated!');
    camera.position.set(periscope.position.x, periscope.position.y + 2, periscope.position.z);
    camera.lookAt(0, 0, -100); // Adjust to look forward
  };

  // Add raycasting for clickable objects
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  window.addEventListener('click', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects([controlPanel, periscope]);

    if (intersects.length > 0) {
      const clickedObject = intersects[0].object;
      if (clickedObject.userData.onClick) {
        clickedObject.userData.onClick();
      }
    }
  });
}

// Add interactive interior to the submarine
addInteractiveInterior(submarine);
const io = require('socket.io')(3000);

const submarines = {
  uBoat: { position: { x: 0, y: -10, z: 0 }, rotation: { y: 0 }, health: 100, isStealth: false },
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send initial submarine states
  socket.emit('submarineStates', submarines);

  // Update submarine state
  socket.on('updateSubmarine', (submarineName, state) => {
    submarines[submarineName] = state;
    socket.broadcast.emit('updateSubmarine', submarineName, state); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Receive initial submarine states
socket.on('submarineStates', (states) => {
  submarine.position.set(states.uBoat.position.x, states.uBoat.position.y, states.uBoat.position.z);
  submarine.rotation.y = states.uBoat.rotation.y;
  submarine.userData.isStealth = states.uBoat.isStealth;
});

// Send submarine updates
function updateSubmarineState(submarine) {
  const state = {
    position: { x: submarine.position.x, y: submarine.position.y, z: submarine.position.z },
    rotation: { y: submarine.rotation.y },
    health: submarine.userData.health,
    isStealth: submarine.userData.isStealth,
  };
  socket.emit('updateSubmarine', 'uBoat', state);
}

// Example: Update submarine state during animation
function animate() {
  requestAnimationFrame(animate);

  updateSubmarineState(submarine);

  renderer.render(scene, camera);
}

animate();
const underwaterLighting = { intensity: 1 };

io.on('connection', (socket) => {
  // Send initial lighting state
  socket.emit('underwaterLighting', underwaterLighting);

  // Update lighting state
  socket.on('updateLighting', (state) => {
    underwaterLighting.intensity = state.intensity;
    socket.broadcast.emit('underwaterLighting', underwaterLighting); // Notify all other players
  });
});
// Receive underwater lighting updates
socket.on('underwaterLighting', (state) => {
  underwaterLight.intensity = state.intensity;
});

// Update underwater lighting
function updateUnderwaterLighting(intensity) {
  socket.emit('updateLighting', { intensity });
}

// Example: Adjust lighting intensity
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyL') {
    underwaterLight.intensity = Math.random(); // Random flicker effect
    updateUnderwaterLighting(underwaterLight.intensity);
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Update submarine state
  updateSubmarineState(submarine);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function addPeriscopeFunctionality(submarine) {
  const periscopeGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 32);
  const periscopeMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const periscope = new THREE.Mesh(periscopeGeometry, periscopeMaterial);
  periscope.position.set(0, 10, 0); // Position above the submarine
  submarine.add(periscope);

  // Add periscope camera
  const periscopeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  periscopeCamera.position.set(0, 12, 0); // Position slightly above the periscope
  submarine.add(periscopeCamera);

  // Add zoom and rotation controls
  let zoomLevel = 75; // Default zoom level
  document.addEventListener('keydown', (event) => {
    switch (event.code) {
      case 'KeyZ': // Zoom in
        zoomLevel = Math.max(30, zoomLevel - 5); // Minimum zoom level
        periscopeCamera.fov = zoomLevel;
        periscopeCamera.updateProjectionMatrix();
        break;
      case 'KeyX': // Zoom out
        zoomLevel = Math.min(100, zoomLevel + 5); // Maximum zoom level
        periscopeCamera.fov = zoomLevel;
        periscopeCamera.updateProjectionMatrix();
        break;
      case 'ArrowLeft': // Rotate left
        periscope.rotation.y += 0.1;
        periscopeCamera.rotation.y += 0.1;
        break;
      case 'ArrowRight': // Rotate right
        periscope.rotation.y -= 0.1;
        periscopeCamera.rotation.y -= 0.1;
        break;
    }
  });

  // Switch to periscope view
  document.addEventListener('keydown', (event) => {
    if (event.code === 'KeyP') {
      camera = periscopeCamera;
      console.log('Switched to periscope view');
    }
  });

  // Switch back to external view
  document.addEventListener('keydown', (event) => {
    if (event.code === 'KeyE') {
      camera = externalCamera;
      console.log('Switched to external view');
    }
  });
}

// Add periscope functionality to the submarine
addPeriscopeFunctionality(submarine);
function addTorpedoLaunchControls(submarine) {
  // Create torpedo launch control panel
  const controlPanelGeometry = new THREE.BoxGeometry(5, 2, 1);
  const controlPanelMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const controlPanel = new THREE.Mesh(controlPanelGeometry, controlPanelMaterial);
  controlPanel.position.set(0, 2, 5); // Position inside the submarine
  submarine.add(controlPanel);

  // Add click interaction for the control panel
  controlPanel.userData.onClick = () => {
    console.log('Torpedo launch control clicked!');
    submarine.userData.fireTorpedo(yamato); // Fire a torpedo at Yamato
  };

  // Add raycasting for clickable objects
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  window.addEventListener('click', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects([controlPanel]);

    if (intersects.length > 0) {
      const clickedObject = intersects[0].object;
      if (clickedObject.userData.onClick) {
        clickedObject.userData.onClick();
      }
    }
  });
}

// Add torpedo launch controls to the submarine
addTorpedoLaunchControls(submarine);
function animate() {
  requestAnimationFrame(animate);

  // Update submarine state
  updateSubmarineState(submarine);

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const io = require('socket.io')(3000);

const submarines = {
  uBoat: { position: { x: 0, y: -10, z: 0 }, rotation: { y: 0 }, health: 100, isStealth: false },
};

const torpedoes = [];
const periscopeViews = {};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send initial submarine states
  socket.emit('submarineStates', submarines);

  // Update submarine state
  socket.on('updateSubmarine', (submarineName, state) => {
    submarines[submarineName] = state;
    socket.broadcast.emit('updateSubmarine', submarineName, state); // Notify all other players
  });

  // Broadcast torpedo fire
  socket.on('fireTorpedo', (data) => {
    torpedoes.push(data);
    socket.broadcast.emit('fireTorpedo', data); // Notify all other players
  });

  // Broadcast periscope view changes
  socket.on('updatePeriscopeView', (data) => {
    periscopeViews[socket.id] = data;
    socket.broadcast.emit('updatePeriscopeView', { id: socket.id, data }); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    delete periscopeViews[socket.id];
    console.log('Player disconnected:', socket.id);
  });
});
// Receive initial submarine states
socket.on('submarineStates', (states) => {
  submarine.position.set(states.uBoat.position.x, states.uBoat.position.y, states.uBoat.position.z);
  submarine.rotation.y = states.uBoat.rotation.y;
  submarine.userData.isStealth = states.uBoat.isStealth;
});

// Send submarine updates
function updateSubmarineState(submarine) {
  const state = {
    position: { x: submarine.position.x, y: submarine.position.y, z: submarine.position.z },
    rotation: { y: submarine.rotation.y },
    health: submarine.userData.health,
    isStealth: submarine.userData.isStealth,
  };
  socket.emit('updateSubmarine', 'uBoat', state);
}

// Fire a torpedo and notify the server
function fireTorpedo(target) {
  const torpedo = {
    position: submarine.position.clone(),
    velocity: new THREE.Vector3(0, 0, -1).applyQuaternion(submarine.quaternion),
    target,
  };
  socket.emit('fireTorpedo', torpedo);

  // Animate torpedo locally
  animateTorpedo(torpedo);
}

// Receive torpedo fire from other players
socket.on('fireTorpedo', (data) => {
  animateTorpedo(data);
});

// Update periscope view and notify the server
function updatePeriscopeView(rotation, zoomLevel) {
  const viewData = { rotation, zoomLevel };
  socket.emit('updatePeriscopeView', viewData);
}

// Receive periscope view updates from other players
socket.on('updatePeriscopeView', ({ id, data }) => {
  console.log(`Player ${id} updated periscope view:`, data);
});
let currentMode = 'plane'; // Default mode is flying planes

function toggleMode() {
  if (currentMode === 'plane') {
    currentMode = 'boat';
    console.log('Switched to boat mode');
    enableBoatControls();
    disablePlaneControls();
  } else {
    currentMode = 'plane';
    console.log('Switched to plane mode');
    enablePlaneControls();
    disableBoatControls();
  }
}

// Enable boat controls
function enableBoatControls() {
  document.addEventListener('keydown', controlShipHandler);
}

// Disable boat controls
function disableBoatControls() {
  document.removeEventListener('keydown', controlShipHandler);
}

// Enable plane controls
function enablePlaneControls() {
  document.addEventListener('keydown', controlPlaneHandler);
}

// Disable plane controls
function disablePlaneControls() {
  document.removeEventListener('keydown', controlPlaneHandler);
}

// Example: Add event listener for toggling modes
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyM') {
    toggleMode(); // Toggle between plane and boat modes
  }
});

// Example: Ship control handler
function controlShipHandler(event) {
  const speed = 0.5;
  const rotationSpeed = 0.02;

  switch (event.code) {
    case 'ArrowUp': // Move forward
      yamato.userData.velocity.z -= speed;
      break;
    case 'ArrowDown': // Move backward
      yamato.userData.velocity.z += speed;
      break;
    case 'ArrowLeft': // Turn left
      yamato.rotation.y += rotationSpeed;
      break;
    case 'ArrowRight': // Turn right
      yamato.rotation.y -= rotationSpeed;
      break;
  }
}

// Example: Plane control handler
function controlPlaneHandler(event) {
  const pitchSpeed = 0.05;
  const rollSpeed = 0.05;

  switch (event.code) {
    case 'ArrowUp': // Pitch up
      fa18f.rotation.x -= pitchSpeed;
      break;
    case 'ArrowDown': // Pitch down
      fa18f.rotation.x += pitchSpeed;
      break;
    case 'ArrowLeft': // Roll left
      fa18f.rotation.z += rollSpeed;
      break;
    case 'ArrowRight': // Roll right
      fa18f.rotation.z -= rollSpeed;
      break;
  }
}
function animate() {
  requestAnimationFrame(animate);

  // Update submarine state
  updateSubmarineState(submarine);

  // Update ship physics
  animateShips();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const io = require('socket.io')(3000);

const periscopeViews = {};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast periscope view changes
  socket.on('updatePeriscopeView', (data) => {
    periscopeViews[socket.id] = data;
    socket.broadcast.emit('updatePeriscopeView', { id: socket.id, data }); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    delete periscopeViews[socket.id];
    console.log('Player disconnected:', socket.id);
  });
});
// Update periscope view and notify the server
function updatePeriscopeView(rotation, zoomLevel) {
  const viewData = { rotation, zoomLevel };
  socket.emit('updatePeriscopeView', viewData);
}

// Receive periscope view updates from other players
socket.on('updatePeriscopeView', ({ id, data }) => {
  console.log(`Player ${id} updated periscope view:`, data);
});
function updateHUD(mode) {
  const hud = document.getElementById('hud');
  if (mode === 'plane') {
    hud.innerHTML = `
      <p>Throttle: <span id="throttle">50%</span></p>
      <p>Altitude: <span id="altitude">1000m</span></p>
      <p>Weapon: <span id="weapon">Missile</span></p>
    `;
  } else if (mode === 'boat') {
    hud.innerHTML = `
      <p>Speed: <span id="speed">20 knots</span></p>
      <p>Depth: <span id="depth">0m</span></p>
      <p>Weapon: <span id="weapon">Torpedo</span></p>
    `;
  }
}

// Example: Switch HUD when toggling modes
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyM') {
    toggleMode();
    updateHUD(currentMode);
  }
});
const torpedoes = [];
const impacts = [];

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast torpedo fire
  socket.on('fireTorpedo', (data) => {
    torpedoes.push(data);
    socket.broadcast.emit('fireTorpedo', data); // Notify all other players
  });

  // Broadcast impact events
  socket.on('torpedoImpact', (data) => {
    impacts.push(data);
    socket.broadcast.emit('torpedoImpact', data); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Fire a torpedo and notify the server
function fireTorpedo(target) {
  const torpedo = {
    position: submarine.position.clone(),
    velocity: new THREE.Vector3(0, 0, -1).applyQuaternion(submarine.quaternion),
    target,
  };
  socket.emit('fireTorpedo', torpedo);

  // Animate torpedo locally
  animateTorpedo(torpedo);
}

// Notify server of torpedo impact
function notifyTorpedoImpact(target) {
  socket.emit('torpedoImpact', { target });
}

// Receive torpedo impacts from other players
socket.on('torpedoImpact', (data) => {
  console.log(`Torpedo impacted target:`, data.target);
});
window.addEventListener('gamepadconnected', (event) => {
  console.log('Gamepad connected:', event.gamepad);
});

function updateControllerInput() {
  const gamepads = navigator.getGamepads();
  if (gamepads[0]) {
    const axes = gamepads[0].axes;
    const buttons = gamepads[0].buttons;

    if (currentMode === 'plane') {
      // Use axes for pitch and roll
      fa18f.rotation.x = axes[1] * 0.1; // Pitch
      fa18f.rotation.z = axes[0] * 0.1; // Roll
    } else if (currentMode === 'boat') {
      // Use axes for steering
      yamato.rotation.y += axes[0] * 0.05; // Turn
    }

    // Example: Fire weapon with a button press
    if (buttons[0].pressed) {
      if (currentMode === 'plane') {
        weaponSystem.fireMissile(enemyTarget);
      } else if (currentMode === 'boat') {
        fireTorpedo(enemyTarget);
      }
    }
  }
  requestAnimationFrame(updateControllerInput);
}

updateControllerInput();
function createSubmarine({ name, length, width, height, color, position }) {
  const submarine = new THREE.Group();

  // Hull
  const hullGeometry = new THREE.CylinderGeometry(width / 2, width / 2, length, 32);
  const hullMaterial = new THREE.MeshStandardMaterial({ color });
  const hull = new THREE.Mesh(hullGeometry, hullMaterial);
  hull.rotation.z = Math.PI / 2; // Align with x-axis
  submarine.add(hull);

  // Conning tower
  const towerGeometry = new THREE.BoxGeometry(width / 2, height, width / 2);
  const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const tower = new THREE.Mesh(towerGeometry, towerMaterial);
  tower.position.set(0, height / 2, 0);
  submarine.add(tower);

  submarine.name = name;
  submarine.position.set(position.x, position.y, position.z);

  return submarine;
}

// Add submarines
const ohioClass = createSubmarine({
  name: 'Ohio-Class',
  length: 170,
  width: 13,
  height: 20,
  color: 0x333333,
  position: { x: 0, y: -10, z: 0 },
});
scene.add(ohioClass);

const virginiaClass = createSubmarine({
  name: 'Virginia-Class',
  length: 115,
  width: 10,
  height: 15,
  color: 0x444444,
  position: { x: 50, y: -10, z: 50 },
});
scene.add(virginiaClass);

const seawolfClass = createSubmarine({
  name: 'Seawolf-Class',
  length: 108,
  width: 12,
  height: 18,
  color: 0x555555,
  position: { x: -50, y: -10, z: -50 },
});
scene.add(seawolfClass);

const astuteClass = createSubmarine({
  name: 'Astute-Class',
  length: 97,
  width: 11,
  height: 16,
  color: 0x666666,
  position: { x: 100, y: -10, z: 100 },
});
scene.add(astuteClass);
function animate() {
  requestAnimationFrame(animate);

  // Update submarine state
  updateSubmarineState(submarine);

  // Update ship physics
  animateShips();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function addSonarDetection(submarine, targets) {
  submarine.userData.sonarActive = false;

  // Activate sonar
  document.addEventListener('keydown', (event) => {
    if (event.code === 'KeyS') {
      submarine.userData.sonarActive = true;
      console.log('Sonar activated!');
      targets.forEach((target) => {
        const distance = submarine.position.distanceTo(target.position);
        if (distance < 100) {
          console.log(`Target detected: ${target.name} at distance ${Math.round(distance)}m`);
        }
      });
    }
  });

  // Deactivate sonar
  document.addEventListener('keyup', (event) => {
    if (event.code === 'KeyS') {
      submarine.userData.sonarActive = false;
      console.log('Sonar deactivated!');
    }
  });
}

function addCountermeasures(submarine) {
  submarine.userData.countermeasures = 3; // Limited countermeasures

  document.addEventListener('keydown', (event) => {
    if (event.code === 'KeyC' && submarine.userData.countermeasures > 0) {
      console.log('Countermeasure deployed!');
      submarine.userData.countermeasures--;

      // Create a decoy
      const decoyGeometry = new THREE.SphereGeometry(1, 16, 16);
      const decoyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const decoy = new THREE.Mesh(decoyGeometry, decoyMaterial);
      decoy.position.copy(submarine.position);
      scene.add(decoy);

      // Animate decoy
      const decoyInterval = setInterval(() => {
        decoy.position.x += (Math.random() - 0.5) * 2;
        decoy.position.y += (Math.random() - 0.5) * 2;
        decoy.position.z += (Math.random() - 0.5) * 2;
        decoy.material.opacity -= 0.05;
        if (decoy.material.opacity <= 0) {
          scene.remove(decoy);
          clearInterval(decoyInterval);
        }
      }, 100);
    }
  });
}

// Add sonar and countermeasures to the submarine
addSonarDetection(submarine, [yamato, iowa, dreadnought]);
addCountermeasures(submarine);
const stealthStates = {};
const underwaterLighting = { intensity: 1 };

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Update stealth state
  socket.on('updateStealth', (data) => {
    stealthStates[socket.id] = data;
    socket.broadcast.emit('updateStealth', { id: socket.id, data });
  });

  // Update underwater lighting
  socket.on('updateLighting', (state) => {
    underwaterLighting.intensity = state.intensity;
    socket.broadcast.emit('updateLighting', underwaterLighting);
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    delete stealthStates[socket.id];
    console.log('Player disconnected:', socket.id);
  });
});
// Send stealth state
function updateStealthState(isStealth) {
  socket.emit('updateStealth', { isStealth });
}

// Receive stealth updates
socket.on('updateStealth', ({ id, data }) => {
  console.log(`Player ${id} stealth state: ${data.isStealth ? 'ON' : 'OFF'}`);
});

// Update underwater lighting
function updateUnderwaterLighting(intensity) {
  socket.emit('updateLighting', { intensity });
}

// Receive underwater lighting updates
socket.on('updateLighting', (state) => {
  underwaterLight.intensity = state.intensity;
});
function updateHUD(mode, submarine) {
  const hud = document.getElementById('hud');
  if (mode === 'boat') {
    hud.innerHTML = `
      <p>Speed: <span id="speed">${Math.round(submarine.userData.velocity.length())} knots</span></p>
      <p>Depth: <span id="depth">${Math.round(submarine.position.y)}m</span></p>
      <p>Countermeasures: <span id="countermeasures">${submarine.userData.countermeasures}</span></p>
    `;
  }
}

// Update HUD in the animation loop
function animateHUD() {
  updateHUD('boat', submarine);
}
function sinkShip(ship) {
  console.log(`${ship.name} is sinking!`);
  const sinkInterval = setInterval(() => {
    ship.position.y -= 0.1; // Sink downward
    ship.rotation.z += 0.01; // Tilt as it sinks
    if (ship.position.y < -50) {
      console.log(`${ship.name} has sunk.`);
      scene.remove(ship);
      clearInterval(sinkInterval);
    }
  }, 100);
}

// Example: Trigger sinking animation
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyK') {
    sinkShip(yamato); // Sink the Yamato
  }
});
const startingPositions = {
  yamato: { position: { x: 0, y: 0, z: 0 }, rotation: { y: 0 } },
  fa18f: { position: { x: 0, y: 2, z: 0 }, rotation: { x: 0, y: 0, z: 0 } },
};

function resetVehicle(vehicle, type) {
  const start = startingPositions[type];
  vehicle.position.set(start.position.x, start.position.y, start.position.z);
  vehicle.rotation.set(start.rotation.x || 0, start.rotation.y || 0, start.rotation.z || 0);
  console.log(`${type} reset to starting position.`);
}

// Example: Reset vehicle on "Tab" key press
document.addEventListener('keydown', (event) => {
  if (event.code === 'Tab') {
    if (currentMode === 'plane') {
      resetVehicle(fa18f, 'fa18f');
    } else if (currentMode === 'boat') {
      resetVehicle(yamato, 'yamato');
    }
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Update submarine state
  updateSubmarineState(submarine);

  // Update HUD
  animateHUD();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function addDirectionalSonar(submarine, targets) {
  submarine.userData.sonarActive = false;

  document.addEventListener('keydown', (event) => {
    if (event.code === 'KeyS') {
      submarine.userData.sonarActive = true;
      console.log('Sonar activated!');

      targets.forEach((target) => {
        const directionToTarget = new THREE.Vector3().subVectors(target.position, submarine.position).normalize();
        const submarineDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(submarine.quaternion);

        const angle = submarineDirection.angleTo(directionToTarget);
        const distance = submarine.position.distanceTo(target.position);

        if (angle < Math.PI / 6 && distance < 200) { // Narrow detection cone and range
          console.log(`Target detected: ${target.name} at distance ${Math.round(distance)}m`);
        }
      });
    }
  });

  document.addEventListener('keyup', (event) => {
    if (event.code === 'KeyS') {
      submarine.userData.sonarActive = false;
      console.log('Sonar deactivated!');
    }
  });
}

// Add directional sonar to the submarine
addDirectionalSonar(submarine, [yamato, iowa, dreadnought]);
const io = require('socket.io')(3000);

const sinkingShips = [];
const countermeasures = [];

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast sinking animation
  socket.on('sinkShip', (shipName) => {
    sinkingShips.push(shipName);
    socket.broadcast.emit('sinkShip', shipName);
  });

  // Broadcast countermeasure deployment
  socket.on('deployCountermeasure', (data) => {
    countermeasures.push(data);
    socket.broadcast.emit('deployCountermeasure', data);
  });

  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Notify server of sinking animation
function notifySinkShip(shipName) {
  socket.emit('sinkShip', shipName);
}

// Receive sinking animation from other players
socket.on('sinkShip', (shipName) => {
  const ship = scene.getObjectByName(shipName);
  if (ship) sinkShip(ship);
});

// Notify server of countermeasure deployment
function deployCountermeasure() {
  const countermeasure = {
    position: submarine.position.clone(),
    id: socket.id,
  };
  socket.emit('deployCountermeasure', countermeasure);

  // Animate locally
  animateCountermeasure(countermeasure);
}

// Receive countermeasure deployment from other players
socket.on('deployCountermeasure', (data) => {
  animateCountermeasure(data);
});
function updateHUD(mode, submarine) {
  const hud = document.getElementById('hud');
  if (mode === 'boat') {
    hud.innerHTML = `
      <p>Speed: <span id="speed">${Math.round(submarine.userData.velocity.length())} knots</span></p>
      <p>Depth: <span id="depth">${Math.round(submarine.position.y)}m</span></p>
      <p>Countermeasures: <span id="countermeasures">${submarine.userData.countermeasures}</span></p>
      <p>Weapon Cooldown: <span id="cooldown">${submarine.userData.weaponCooldown}s</span></p>
      <p>Health: <span id="health">${submarine.userData.health}</span></p>
    `;
  }
}

// Update cooldown and health in the animation loop
function animateHUD() {
  if (submarine.userData.weaponCooldown > 0) {
    submarine.userData.weaponCooldown -= 0.1; // Decrease cooldown
  }
  updateHUD('boat', submarine);
}
// Enable VR
renderer.xr.enabled = true;
document.body.appendChild(VRButton.createButton(renderer));

// Add VR controls
const vrControls = new THREE.VRControls(camera);
vrControls.standing = true;

// Add VR interaction for submarines and battleships
function addVRInteraction(object) {
  object.userData.onSelect = () => {
    console.log(`${object.name} selected in VR!`);
  };

  const controller = renderer.xr.getController(0);
  controller.addEventListener('selectstart', () => {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(), camera);

    const intersects = raycaster.intersectObjects(scene.children);
    if (intersects.length > 0) {
      const selectedObject = intersects[0].object;
      if (selectedObject.userData.onSelect) {
        selectedObject.userData.onSelect();
      }
    }
  });

  scene.add(controller);
}

// Add VR interaction to submarines and battleships
addVRInteraction(submarine);
addVRInteraction(yamato);
addVRInteraction(iowa);
addVRInteraction(dreadnought);
function animate() {
  requestAnimationFrame(animate);

  // Update submarine state
  updateSubmarineState(submarine);

  // Update HUD
  animateHUD();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
// Enable VR
renderer.xr.enabled = true;
document.body.appendChild(VRButton.createButton(renderer));

// Add VR hand tracking
const hand1 = renderer.xr.getHand(0);
const hand2 = renderer.xr.getHand(1);
scene.add(hand1, hand2);

// Add cockpit controls for submarines and battleships
function addCockpitControls(object) {
  const controlPanel = new THREE.Group();

  // Add buttons
  const buttonGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.05);
  const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const fireButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
  fireButton.position.set(0, 1, -1);
  fireButton.userData.onSelect = () => {
    console.log('Fire weapon!');
    if (object.name === 'submarine') {
      fireTorpedo(yamato); // Example: Fire torpedo
    } else if (object.name === 'battleship') {
      fireShell(yamatoTurrets[0]); // Example: Fire shell
    }
  };
  controlPanel.add(fireButton);

  // Add control panel to the object
  object.add(controlPanel);

  // Add VR interaction
  const controller = renderer.xr.getController(0);
  controller.addEventListener('selectstart', () => {
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(), camera);

    const intersects = raycaster.intersectObjects(controlPanel.children);
    if (intersects.length > 0) {
      const selectedObject = intersects[0].object;
      if (selectedObject.userData.onSelect) {
        selectedObject.userData.onSelect();
      }
    }
  });

  scene.add(controller);
}

// Add cockpit controls to submarines and battleships
addCockpitControls(submarine);
addCockpitControls(yamato);
function addSonarPingVR(submarine) {
  const pingGeometry = new THREE.RingGeometry(1, 1.5, 32);
  const pingMaterial = new THREE.MeshStandardMaterial({
    color: 0x00ff00,
    transparent: true,
    opacity: 0.5,
  });
  const ping = new THREE.Mesh(pingGeometry, pingMaterial);
  ping.position.copy(submarine.position);
  ping.rotation.x = -Math.PI / 2; // Align with the water surface
  scene.add(ping);

  // Animate sonar ping
  const pingInterval = setInterval(() => {
    ping.scale.multiplyScalar(1.1); // Expand ping
    ping.material.opacity -= 0.02; // Fade out
    if (ping.material.opacity <= 0) {
      scene.remove(ping);
      clearInterval(pingInterval);
    }
  }, 100);
}

// Trigger sonar ping in VR
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyP') {
    addSonarPingVR(submarine);
  }
});
const vrInteractions = {};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast VR interactions
  socket.on('vrInteraction', (data) => {
    vrInteractions[socket.id] = data;
    socket.broadcast.emit('vrInteraction', { id: socket.id, data });
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    delete vrInteractions[socket.id];
    console.log('Player disconnected:', socket.id);
  });
});
// Send VR interaction data
function sendVRInteraction(data) {
  socket.emit('vrInteraction', data);
}

// Receive VR interactions from other players
socket.on('vrInteraction', ({ id, data }) => {
  console.log(`Player ${id} performed VR interaction:`, data);
});
function createVRHUD() {
  const hud = new THREE.Group();

  // Add speed indicator
  const speedText = createTextMesh('Speed: 20 knots', 0.1, 0xffffff);
  speedText.position.set(-0.5, 0.5, -1);
  hud.add(speedText);

  // Add depth indicator
  const depthText = createTextMesh('Depth: 0m', 0.1, 0xffffff);
  depthText.position.set(-0.5, 0.3, -1);
  hud.add(depthText);

  // Add weapon status
  const weaponText = createTextMesh('Weapon: Torpedo', 0.1, 0xffffff);
  weaponText.position.set(-0.5, 0.1, -1);
  hud.add(weaponText);

  // Attach HUD to the camera
  camera.add(hud);
}

// Create text mesh for HUD
function createTextMesh(text, size, color) {
  const loader = new THREE.FontLoader();
  const font = loader.parse(/* Font JSON data */);
  const geometry = new THREE.TextGeometry(text, {
    font: font,
    size: size,
    height: 0.01,
  });
  const material = new THREE.MeshBasicMaterial({ color: color });
  return new THREE.Mesh(geometry, material);
}

// Add VR HUD
createVRHUD();
let cameraMode = 'external'; // Default camera mode
const freeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
freeCamera.position.set(0, 50, 100); // Default free camera position

function switchCameraMode() {
  if (cameraMode === 'external') {
    camera = freeCamera;
    cameraMode = 'free';
    console.log('Switched to free camera mode');
  } else if (cameraMode === 'free') {
    camera = externalCamera; // Switch back to external camera
    cameraMode = 'external';
    console.log('Switched to external camera mode');
  }
}

// Add event listener for switching camera modes
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyF') {
    switchCameraMode();
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Update submarine state
  updateSubmarineState(submarine);

  // Update HUD
  animateHUD();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
let cameraMode = 'external'; // Default camera mode
const freeCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
freeCamera.position.set(0, 50, 100); // Default free camera position

// Movement variables
const freeCameraSpeed = 2;
const freeCameraRotationSpeed = 0.02;
const freeCameraVelocity = new THREE.Vector3(0, 0, 0);

function switchCameraMode() {
  if (cameraMode === 'external') {
    camera = freeCamera;
    cameraMode = 'free';
    console.log('Switched to free camera mode');
  } else if (cameraMode === 'free') {
    camera = externalCamera; // Switch back to external camera
    cameraMode = 'external';
    console.log('Switched to external camera mode');
  }
}

// Add movement controls for the free camera
document.addEventListener('keydown', (event) => {
  if (cameraMode === 'free') {
    switch (event.code) {
      case 'KeyW': // Move forward
        freeCameraVelocity.z = -freeCameraSpeed;
        break;
      case 'KeyS': // Move backward
        freeCameraVelocity.z = freeCameraSpeed;
        break;
      case 'KeyA': // Move left
        freeCameraVelocity.x = -freeCameraSpeed;
        break;
      case 'KeyD': // Move right
        freeCameraVelocity.x = freeCameraSpeed;
        break;
      case 'ArrowUp': // Look up
        freeCamera.rotation.x -= freeCameraRotationSpeed;
        break;
      case 'ArrowDown': // Look down
        freeCamera.rotation.x += freeCameraRotationSpeed;
        break;
      case 'ArrowLeft': // Look left
        freeCamera.rotation.y -= freeCameraRotationSpeed;
        break;
      case 'ArrowRight': // Look right
        freeCamera.rotation.y += freeCameraRotationSpeed;
        break;
    }
  }
});

document.addEventListener('keyup', (event) => {
  if (cameraMode === 'free') {
    switch (event.code) {
      case 'KeyW':
      case 'KeyS':
        freeCameraVelocity.z = 0;
        break;
      case 'KeyA':
      case 'KeyD':
        freeCameraVelocity.x = 0;
        break;
    }
  }
});

// Update free camera position in the animation loop
function updateFreeCamera() {
  if (cameraMode === 'free') {
    freeCamera.position.add(freeCameraVelocity);
  }
}
function animate() {
  requestAnimationFrame(animate);

  // Update submarine state
  updateSubmarineState(submarine);

  // Update HUD
  animateHUD();

  // Update free camera movement
  updateFreeCamera();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
// Add event listener for switching camera modes
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyF') {
    switchCameraMode();
  }
});
let engineOn = false;
let engineCooldown = false;
let flapsLevel = 0;

document.addEventListener('keydown', (event) => {
  switch (event.code) {
    case 'KeyW': // Forward thrust
      console.log('Plane: Forward thrust');
      break;
    case 'KeyS': // Reverse thrust
      console.log('Plane: Reverse thrust');
      break;
    case 'Comma': // Turn left
      console.log('Plane: Turn left');
      break;
    case 'Period': // Turn right
      console.log('Plane: Turn right');
      break;
    case 'ArrowUp': // Pitch up
      console.log('Plane: Pitch up');
      break;
    case 'ArrowDown': // Pitch down
      console.log('Plane: Pitch down');
      break;
    case 'Semicolon': // Brakes/handbrake
      console.log('Plane: Brakes applied');
      break;
    case 'KeyB': // Spoilers
      console.log('Plane: Spoilers deployed');
      break;
    case 'KeyF': // Flaps
      flapsLevel = (flapsLevel + 1) % 4; // Cycle through 0, 1, 2, 3
      console.log(`Plane: Flaps set to level ${flapsLevel}`);
      break;
    case 'KeyE': // Engine on/off
      if (!engineCooldown) {
        if (engineOn) {
          console.log('Plane: Engine turning off');
          engineOn = false;
        } else {
          console.log('Plane: Engine starting...');
          engineCooldown = true;
          setTimeout(() => {
            engineOn = true;
            engineCooldown = false;
            console.log('Plane: Engine started');
          }, 2500); // 2.5 seconds to start the engine
        }
      }
      break;
  }
});
let zoomLevel = 1; // Default zoom level for cannons
let ammoType = 'APCR'; // Default ammo type
let torpedoRange = 'short'; // Default torpedo range
let lightsOn = false;

document.addEventListener('keydown', (event) => {
  switch (event.code) {
    case 'KeyW': // Forward
      console.log('Boat: Moving forward');
      break;
    case 'KeyS': // Reverse
      console.log('Boat: Moving backward');
      break;
    case 'KeyA': // Turn left
      console.log('Boat: Turning left');
      break;
    case 'KeyD': // Turn right
      console.log('Boat: Turning right');
      break;
    case 'KeyL': // Lights
      lightsOn = !lightsOn;
      console.log(`Boat: Lights ${lightsOn ? 'on' : 'off'}`);
      break;
    case 'Digit1': // APCR Ammo
      ammoType = 'APCR';
      console.log('Boat: APCR ammo selected');
      break;
    case 'Digit2': // HE/HEAT Ammo
      ammoType = 'HE/HEAT';
      console.log('Boat: HE/HEAT ammo selected');
      break;
    case 'Digit3': // Torpedoes
      if (torpedoRange === 'short') {
        torpedoRange = 'long';
        console.log('Boat: Torpedoes set to long range');
      } else {
        torpedoRange = 'short';
        console.log('Boat: Torpedoes set to short range');
      }
      break;
    case 'Digit4': // Smoke screen
      console.log('Boat: Smoke screen deployed');
      break;
    case 'KeyT': // Scout plane
      console.log('Boat: Scout plane launched');
      break;
  }
});

// Mouse controls for zoom and firing
document.addEventListener('wheel', (event) => {
  zoomLevel += event.deltaY > 0 ? -1 : 1; // Scroll up to zoom in, down to zoom out
  zoomLevel = Math.max(1, Math.min(10, zoomLevel)); // Clamp zoom level between 1 and 10
  console.log(`Boat: Cannon zoom level set to ${zoomLevel}`);
});

document.addEventListener('mousedown', (event) => {
  if (event.button === 0) { // Left mouse button
    console.log(`Boat: Firing ${ammoType} ammo`);
  } else if (event.button === 2) { // Right mouse button
    console.log('Boat: Target lock toggled');
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Update plane and boat states
  updatePlaneState();
  updateBoatState();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function updateHUD(mode, settings) {
  const hud = document.getElementById('hud');
  if (mode === 'plane') {
    hud.innerHTML = `
      <p>Throttle: <span id="throttle">${settings.throttle}%</span></p>
      <p>Flaps: <span id="flaps">${settings.flaps}</span></p>
      <p>Altitude: <span id="altitude">${settings.altitude}m</span></p>
      <p>Weapon: <span id="weapon">${settings.weapon}</span></p>
    `;
  } else if (mode === 'boat') {
    hud.innerHTML = `
      <p>Speed: <span id="speed">${settings.speed} knots</span></p>
      <p>Ammo Type: <span id="ammo">${settings.ammoType}</span></p>
      <p>Zoom Level: <span id="zoom">${settings.zoomLevel}</span></p>
      <p>Torpedo Range: <span id="torpedo">${settings.torpedoRange}</span></p>
    `;
  }
}

// Example: Update HUD in the animation loop
function animateHUD() {
  if (currentMode === 'plane') {
    updateHUD('plane', {
      throttle: 50,
      flaps: flapsLevel,
      altitude: Math.round(fa18f.position.y),
      weapon: 'Missile',
    });
  } else if (currentMode === 'boat') {
    updateHUD('boat', {
      speed: Math.round(yamato.userData.velocity.length()),
      ammoType: ammoType,
      zoomLevel: zoomLevel,
      torpedoRange: torpedoRange,
    });
  }
}
const sounds = {
  engineStart: new Audio('sounds/engine-start.mp3'),
  engineStop: new Audio('sounds/engine-stop.mp3'),
  fireWeapon: new Audio('sounds/fire-weapon.mp3'),
  torpedoLaunch: new Audio('sounds/torpedo-launch.mp3'),
};

function playSound(sound) {
  if (sounds[sound]) {
    sounds[sound].currentTime = 0; // Reset sound
    sounds[sound].play();
  }
}

// Example: Play sound on specific actions
document.addEventListener('keydown', (event) => {
  switch (event.code) {
    case 'KeyE': // Engine on/off
      playSound(engineOn ? 'engineStop' : 'engineStart');
      break;
    case 'Space': // Fire weapon
      playSound('fireWeapon');
      break;
    case 'KeyT': // Launch torpedo
      playSound('torpedoLaunch');
      break;
  }
});
const io = require('socket.io')(3000);

const playerStates = {};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Update player state
  socket.on('updateState', (state) => {
    playerStates[socket.id] = state;
    socket.broadcast.emit('updateState', { id: socket.id, state });
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    delete playerStates[socket.id];
    console.log('Player disconnected:', socket.id);
  });
});
// Send player state to the server
function sendPlayerState(state) {
  socket.emit('updateState', state);
}

// Receive player state updates from other players
socket.on('updateState', ({ id, state }) => {
  console.log(`Player ${id} updated state:`, state);
});

// Example: Send state during animation
function animate() {
  requestAnimationFrame(animate);

  const state = {
    position: currentMode === 'plane' ? fa18f.position : yamato.position,
    rotation: currentMode === 'plane' ? fa18f.rotation : yamato.rotation,
    mode: currentMode,
  };
  sendPlayerState(state);

  renderer.render(scene, camera);
}

animate();
function applyPhysics(object) {
  // Apply drag
  object.userData.velocity.multiplyScalar(0.98); // Reduce velocity over time

  // Apply buoyancy for boats
  if (object.userData.isBoat) {
    const waterLevel = 0; // Assume water level is at y = 0
    if (object.position.y < waterLevel) {
      object.position.y += 0.1; // Push upward
    } else if (object.position.y > waterLevel) {
      object.position.y -= 0.1; // Pull downward
    }
  }

  // Apply recoil for weapons
  if (object.userData.isFiring) {
    object.userData.velocity.z -= 0.1; // Push backward slightly
    object.userData.isFiring = false; // Reset firing state
  }

  // Update position
  object.position.add(object.userData.velocity);
}

// Example: Apply physics in the animation loop
function animatePhysics() {
  [fa18f, yamato].forEach((object) => {
    applyPhysics(object);
  });
}
function animate() {
  requestAnimationFrame(animate);

  // Update HUD
  animateHUD();

  // Apply physics
  animatePhysics();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function updateHUD(mode, settings) {
  const hud = document.getElementById('hud');
  if (mode === 'plane') {
    hud.innerHTML = `
      <p>Throttle: <span id="throttle">${settings.throttle}%</span></p>
      <p>Flaps: <span id="flaps">${settings.flaps}</span></p>
      <p>Altitude: <span id="altitude">${settings.altitude}m</span></p>
      <p>Weapon Cooldown: <span id="cooldown">${settings.weaponCooldown}s</span></p>
      <p>Fuel: <span id="fuel">${settings.fuel}%</span></p>
      <p>Health: <span id="health">${settings.health}</span></p>
    `;
  } else if (mode === 'boat') {
    hud.innerHTML = `
      <p>Speed: <span id="speed">${settings.speed} knots</span></p>
      <p>Ammo Type: <span id="ammo">${settings.ammoType}</span></p>
      <p>Zoom Level: <span id="zoom">${settings.zoomLevel}</span></p>
      <p>Torpedo Range: <span id="torpedo">${settings.torpedoRange}</span></p>
      <p>Weapon Cooldown: <span id="cooldown">${settings.weaponCooldown}s</span></p>
      <p>Fuel: <span id="fuel">${settings.fuel}%</span></p>
      <p>Health: <span id="health">${settings.health}</span></p>
    `;
  }
}

// Example: Update HUD in the animation loop
function animateHUD() {
  if (currentMode === 'plane') {
    updateHUD('plane', {
      throttle: 50,
      flaps: flapsLevel,
      altitude: Math.round(fa18f.position.y),
      weaponCooldown: Math.max(0, weaponCooldown).toFixed(1),
      fuel: Math.max(0, fuelLevel).toFixed(1),
      health: fa18f.userData.health,
    });
  } else if (currentMode === 'boat') {
    updateHUD('boat', {
      speed: Math.round(yamato.userData.velocity.length()),
      ammoType: ammoType,
      zoomLevel: zoomLevel,
      torpedoRange: torpedoRange,
      weaponCooldown: Math.max(0, weaponCooldown).toFixed(1),
      fuel: Math.max(0, fuelLevel).toFixed(1),
      health: yamato.userData.health,
    });
  }
}
const environmentalSounds = {
  wind: new Audio('sounds/wind.mp3'),
  waterSplash: new Audio('sounds/water-splash.mp3'),
  explosion: new Audio('sounds/explosion.mp3'),
};

function playEnvironmentalSound(sound) {
  if (environmentalSounds[sound]) {
    environmentalSounds[sound].currentTime = 0; // Reset sound
    environmentalSounds[sound].play();
  }
}

// Example: Play sound on specific events
function handleWeaponImpact(target) {
  playEnvironmentalSound('explosion');
  console.log(`${target.name} hit!`);
}

function handleWaterInteraction() {
  playEnvironmentalSound('waterSplash');
  console.log('Water interaction detected!');
}

// Example: Play wind sound continuously for planes
environmentalSounds.wind.loop = true;
environmentalSounds.wind.play();
const io = require('socket.io')(3000);

const weaponImpacts = [];

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast weapon impacts
  socket.on('weaponImpact', (data) => {
    weaponImpacts.push(data);
    socket.broadcast.emit('weaponImpact', data); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Notify server of weapon impact
function notifyWeaponImpact(target) {
  socket.emit('weaponImpact', { target });
}

// Receive weapon impacts from other players
socket.on('weaponImpact', (data) => {
  console.log(`Weapon impacted target:`, data.target);
  handleWeaponImpact(data.target);
});
function applyTurbulence(airplane) {
  const turbulence = (Math.random() - 0.5) * 0.1; // Random turbulence factor
  airplane.position.x += turbulence;
  airplane.position.y += turbulence;
  airplane.rotation.z += turbulence * 0.1; // Slight roll
}

// Example: Apply turbulence in the animation loop
function animateTurbulence() {
  if (currentMode === 'plane') {
    applyTurbulence(fa18f);
  }
}

function applyWaveEffects(ship) {
  const waveHeight = Math.sin(Date.now() * 0.001) * 0.5; // Simulate wave motion
  ship.position.y += waveHeight * 0.01; // Vertical wave motion
  ship.rotation.x += waveHeight * 0.001; // Slight pitch
}

// Example: Apply wave effects in the animation loop
function animateWaveEffects() {
  if (currentMode === 'boat') {
    applyWaveEffects(yamato);
  }
}
function animate() {
  requestAnimationFrame(animate);

  // Update HUD
  animateHUD();

  // Apply physics
  animatePhysics();

  // Apply turbulence and wave effects
  animateTurbulence();
  animateWaveEffects();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function updateHUD(mode, settings) {
  const hud = document.getElementById('hud');
  if (mode === 'plane') {
    hud.innerHTML = `
      <p>Throttle: <span id="throttle">${settings.throttle}%</span></p>
      <p>Flaps: <span id="flaps">${settings.flaps}</span></p>
      <p>Altitude: <span id="altitude">${settings.altitude}m</span></p>
      <p>Weapon Cooldown: <span id="cooldown">${settings.weaponCooldown}s</span></p>
      <p>Fuel: <span id="fuel">${settings.fuel}%</span></p>
      <p>Health: <span id="health">${settings.health}</span></p>
    `;
  } else if (mode === 'boat') {
    hud.innerHTML = `
      <p>Speed: <span id="speed">${settings.speed} knots</span></p>
      <p>Ammo Type: <span id="ammo">${settings.ammoType}</span></p>
      <p>Zoom Level: <span id="zoom">${settings.zoomLevel}</span></p>
      <p>Torpedo Range: <span id="torpedo">${settings.torpedoRange}</span></p>
      <p>Weapon Cooldown: <span id="cooldown">${settings.weaponCooldown}s</span></p>
      <p>Fuel: <span id="fuel">${settings.fuel}%</span></p>
      <p>Health: <span id="health">${settings.health}</span></p>
    `;
  }
}

// Example: Update HUD in the animation loop
function animateHUD() {
  if (currentMode === 'plane') {
    updateHUD('plane', {
      throttle: 50,
      flaps: flapsLevel,
      altitude: Math.round(fa18f.position.y),
      weaponCooldown: Math.max(0, weaponCooldown).toFixed(1),
      fuel: Math.max(0, fuelLevel).toFixed(1),
      health: fa18f.userData.health,
    });
  } else if (currentMode === 'boat') {
    updateHUD('boat', {
      speed: Math.round(yamato.userData.velocity.length()),
      ammoType: ammoType,
      zoomLevel: zoomLevel,
      torpedoRange: torpedoRange,
      weaponCooldown: Math.max(0, weaponCooldown).toFixed(1),
      fuel: Math.max(0, fuelLevel).toFixed(1),
      health: yamato.userData.health,
    });
  }
}

// Example: Decrease fuel and update weapon cooldown in the animation loop
function updateFuelAndCooldown() {
  if (currentMode === 'plane') {
    fuelLevel = Math.max(0, fuelLevel - 0.01); // Decrease fuel over time
    if (weaponCooldown > 0) weaponCooldown -= 0.1; // Decrease weapon cooldown
  } else if (currentMode === 'boat') {
    fuelLevel = Math.max(0, fuelLevel - 0.005); // Decrease fuel at a slower rate
    if (weaponCooldown > 0) weaponCooldown -= 0.1; // Decrease weapon cooldown
  }
}
const environmentalSounds = {
  explosion: new Audio('sounds/explosion.mp3'),
  waterSplash: new Audio('sounds/water-splash.mp3'),
};

function playSoundWithProximity(sound, sourcePosition, listenerPosition) {
  if (environmentalSounds[sound]) {
    const distance = sourcePosition.distanceTo(listenerPosition);
    const maxDistance = 100; // Maximum distance for sound to be audible
    const volume = Math.max(0, 1 - distance / maxDistance); // Adjust volume based on distance
    environmentalSounds[sound].volume = volume;
    environmentalSounds[sound].currentTime = 0; // Reset sound
    environmentalSounds[sound].play();
  }
}

// Example: Play explosion sound with proximity adjustment
function handleWeaponImpact(target) {
  playSoundWithProximity('explosion', target.position, camera.position);
  console.log(`${target.name} hit!`);
}

// Example: Play water splash sound with proximity adjustment
function handleWaterInteraction(position) {
  playSoundWithProximity('waterSplash', position, camera.position);
  console.log('Water interaction detected!');
}
const io = require('socket.io')(3000);

const sinkingShips = [];

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast sinking animation
  socket.on('sinkShip', (shipName) => {
    sinkingShips.push(shipName);
    socket.broadcast.emit('sinkShip', shipName); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Notify server of sinking animation
function notifySinkShip(shipName) {
  socket.emit('sinkShip', shipName);
}

// Receive sinking animation from other players
socket.on('sinkShip', (shipName) => {
  const ship = scene.getObjectByName(shipName);
  if (ship) sinkShip(ship);
});

// Example: Trigger sinking animation
function sinkShip(ship) {
  console.log(`${ship.name} is sinking!`);
  const sinkInterval = setInterval(() => {
    ship.position.y -= 0.1; // Sink downward
    ship.rotation.z += 0.01; // Tilt as it sinks
    if (ship.position.y < -50) {
      console.log(`${ship.name} has sunk.`);
      scene.remove(ship);
      clearInterval(sinkInterval);
    }
  }, 100);
}

// Example: Trigger sinking animation locally and notify the server
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyK') {
    sinkShip(yamato); // Sink the Yamato locally
    notifySinkShip('yamato'); // Notify the server
  }
});
function animate() {
  requestAnimationFrame(animate);

  // Update HUD
  animateHUD();

  // Update fuel and weapon cooldown
  updateFuelAndCooldown();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const dopplerSounds = {
  missile: new Audio('sounds/missile.mp3'),
  plane: new Audio('sounds/plane.mp3'),
};

function playDopplerSound(sound, sourcePosition, listenerPosition, sourceVelocity) {
  if (dopplerSounds[sound]) {
    const distance = sourcePosition.distanceTo(listenerPosition);
    const maxDistance = 500; // Maximum distance for sound to be audible
    const volume = Math.max(0, 1 - distance / maxDistance); // Adjust volume based on distance
    dopplerSounds[sound].volume = volume;

    // Calculate Doppler shift
    const relativeVelocity = sourceVelocity.clone().sub(camera.position.clone().sub(listenerPosition));
    const dopplerFactor = relativeVelocity.length() / 343; // Speed of sound in air (343 m/s)
    dopplerSounds[sound].playbackRate = Math.max(0.5, Math.min(2, 1 + dopplerFactor)); // Clamp playback rate

    dopplerSounds[sound].currentTime = 0; // Reset sound
    dopplerSounds[sound].play();
  }
}

// Example: Play Doppler effect for a missile
function handleMissileSound(missile) {
  playDopplerSound('missile', missile.position, camera.position, missile.userData.velocity);
}

// Example: Play Doppler effect for a plane
function handlePlaneSound(plane) {
  playDopplerSound('plane', plane.position, camera.position, plane.userData.velocity);
}

// Call these functions in the animation loop
function animateDopplerEffects() {
  handleMissileSound(missile); // Replace `missile` with your missile object
  handlePlaneSound(fa18f); // Replace `fa18f` with your plane object
}
const io = require('socket.io')(3000);

const ships = {
  yamato: { health: 100, position: { x: 0, y: 0, z: 0 }, rotation: { y: 0 } },
  iowa: { health: 100, position: { x: 300, y: 0, z: 0 }, rotation: { y: 0 } },
  dreadnought: { health: 100, position: { x: -300, y: 0, z: 0 }, rotation: { y: 0 } },
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send initial ship states
  socket.emit('shipStates', ships);

  // Update ship health
  socket.on('updateHealth', (shipName, damage) => {
    ships[shipName].health -= damage;
    if (ships[shipName].health <= 0) {
      console.log(`${shipName} has been destroyed!`);
    }
    io.emit('updateHealth', shipName, ships[shipName].health); // Broadcast updated health
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Receive health updates
socket.on('updateHealth', (shipName, health) => {
  const ship = scene.getObjectByName(shipName);
  if (ship) {
    ship.userData.health = health;
    updateHealthBar(ship);
    if (health <= 0) {
      sinkShip(ship); // Trigger sinking animation if health is 0
    }
  }
});

// Apply damage to a ship and notify the server
function applyDamage(ship, damage) {
  socket.emit('updateHealth', ship.name, damage);
}

// Example: Apply damage to Yamato
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyD') {
    applyDamage(yamato, 10); // Apply 10 damage
  }
});

// Update health bar
function updateHealthBar(ship) {
  const healthPercentage = ship.userData.health / 100;
  ship.userData.healthBar.scale.x = healthPercentage;
  ship.userData.healthBar.material.color.set(healthPercentage > 0.5 ? 0x00ff00 : 0xff0000);
}
function animate() {
  requestAnimationFrame(animate);

  // Update Doppler effects
  animateDopplerEffects();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const environmentalSounds = {
  explosion: new Audio('sounds/explosion.mp3'),
  waterSplash: new Audio('sounds/water-splash.mp3'),
};

function playSoundWithDoppler(sound, sourcePosition, listenerPosition, sourceVelocity) {
  if (environmentalSounds[sound]) {
    const distance = sourcePosition.distanceTo(listenerPosition);
    const maxDistance = 500; // Maximum distance for sound to be audible
    const volume = Math.max(0, 1 - distance / maxDistance); // Adjust volume based on distance
    environmentalSounds[sound].volume = volume;

    // Calculate Doppler shift
    const relativeVelocity = sourceVelocity.clone().sub(camera.position.clone().sub(listenerPosition));
    const dopplerFactor = relativeVelocity.length() / 343; // Speed of sound in air (343 m/s)
    environmentalSounds[sound].playbackRate = Math.max(0.5, Math.min(2, 1 + dopplerFactor)); // Clamp playback rate

    environmentalSounds[sound].currentTime = 0; // Reset sound
    environmentalSounds[sound].play();
  }
}

// Example: Play explosion sound with Doppler effect
function handleExplosionSound(position, velocity) {
  playSoundWithDoppler('explosion', position, camera.position, velocity);
}

// Example: Play water splash sound with Doppler effect
function handleWaterSplashSound(position, velocity) {
  playSoundWithDoppler('waterSplash', position, camera.position, velocity);
}
const io = require('socket.io')(3000);

const weaponImpacts = [];

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast weapon impacts
  socket.on('weaponImpact', (data) => {
    weaponImpacts.push(data);
    socket.broadcast.emit('weaponImpact', data); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Notify server of weapon impact
function notifyWeaponImpact(target, position) {
  socket.emit('weaponImpact', { target, position });
}

// Receive weapon impacts from other players
socket.on('weaponImpact', (data) => {
  console.log(`Weapon impacted target:`, data.target);
  handleExplosionSound(data.position, new THREE.Vector3(0, 0, 0)); // Play explosion sound
  addExplosion(data.position); // Add explosion effect
});

// Example: Trigger weapon impact
function triggerWeaponImpact(target) {
  const impactPosition = target.position.clone();
  notifyWeaponImpact(target.name, impactPosition);
  addExplosion(impactPosition);
}
function addHPBar(entity) {
  const hpBarGeometry = new THREE.PlaneGeometry(10, 1);
  const hpBarMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
  const hpBar = new THREE.Mesh(hpBarGeometry, hpBarMaterial);
  hpBar.position.set(0, 10, 0); // Position above the entity
  hpBar.visible = false; // Initially hidden
  entity.add(hpBar);

  entity.userData.hpBar = hpBar;
  entity.userData.health = 100; // Initial health
}

function updateHPBar(entity, damage) {
  entity.userData.health -= damage;
  if (entity.userData.health <= 0) {
    console.log(`${entity.name} has been destroyed!`);
    scene.remove(entity); // Remove the entity from the scene
  } else {
    const healthPercentage = entity.userData.health / 100;
    entity.userData.hpBar.scale.x = healthPercentage;
    entity.userData.hpBar.material.color.set(healthPercentage > 0.5 ? 0x00ff00 : 0xff0000);
  }
}

// Show HP bar only during dogfights
function toggleHPBar(entity, isDogfight) {
  entity.userData.hpBar.visible = isDogfight;
}

// Example: Add HP bars to planes and ships
[enemyPlane, enemyShip].forEach((entity) => addHPBar(entity));

// Example: Trigger a dogfight and show HP bar
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyF') { // Start dogfight
    toggleHPBar(enemyPlane, true);
    console.log('Dogfight initiated!');
  } else if (event.code === 'KeyG') { // End dogfight
    toggleHPBar(enemyPlane, false);
    console.log('Dogfight ended!');
  }
});

// Example: Apply damage during a dogfight
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyD') { // Apply damage
    updateHPBar(enemyPlane, 10); // Apply 10 damage
  }
});
function addExplosion(position) {
  const explosionGeometry = new THREE.SphereGeometry(5, 32, 32);
  const explosionMaterial = new THREE.MeshStandardMaterial({
    color: 0xff4500,
    emissive: 0xff0000,
    emissiveIntensity: 1,
    transparent: true,
    opacity: 0.8,
  });
  const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
  explosion.position.copy(position);
  scene.add(explosion);

  // Animate explosion
  const explosionInterval = setInterval(() => {
    explosion.scale.multiplyScalar(1.1); // Expand explosion
    explosion.material.opacity -= 0.05; // Fade out
    if (explosion.material.opacity <= 0) {
      scene.remove(explosion);
      clearInterval(explosionInterval);
    }
  }, 100);
}

function addWaterSplash(position) {
  const splashGeometry = new THREE.CircleGeometry(5, 32);
  const splashMaterial = new THREE.MeshStandardMaterial({
    color: 0x00aaff,
    transparent: true,
    opacity: 0.5,
  });
  const splash = new THREE.Mesh(splashGeometry, splashMaterial);
  splash.rotation.x = -Math.PI / 2; // Align with the water surface
  splash.position.copy(position);
  scene.add(splash);

  // Animate splash
  const splashInterval = setInterval(() => {
    splash.scale.multiplyScalar(1.1); // Expand splash
    splash.material.opacity -= 0.05; // Fade out
    if (splash.material.opacity <= 0) {
      scene.remove(splash);
      clearInterval(splashInterval);
    }
  }, 100);
}
function animate() {
  requestAnimationFrame(animate);

  // Update Doppler effects
  animateDopplerEffects();

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const environmentalSounds = {
  wind: new Audio('sounds/wind.mp3'),
  cannonFire: new Audio('sounds/cannon-fire.mp3'),
  torpedoWarning: new Audio('sounds/stopwatch.mp3'),
};

function playEnvironmentalSound(sound) {
  if (environmentalSounds[sound]) {
    environmentalSounds[sound].currentTime = 0; // Reset sound
    environmentalSounds[sound].play();
  }
}

// Example: Play wind sound continuously for planes
environmentalSounds.wind.loop = true;
environmentalSounds.wind.play();

// Example: Play cannon fire sound
function handleCannonFire() {
  playEnvironmentalSound('cannonFire');
  console.log('Cannon fired!');
}

// Example: Play stopwatch sound for incoming torpedo
function handleTorpedoWarning() {
  playEnvironmentalSound('torpedoWarning');
  console.log('Torpedo incoming!');
}

// Trigger cannon fire
document.addEventListener('keydown', (event) => {
  if (event.code === 'Space') {
    handleCannonFire();
  }
});

// Trigger torpedo warning
function detectIncomingTorpedo(torpedo, playerPosition) {
  const distance = torpedo.position.distanceTo(playerPosition);
  if (distance < 100) {
    handleTorpedoWarning();
  }
}
const io = require('socket.io')(3000);

const entities = {
  yamato: { health: 100, isDogfight: false },
  enemyPlane: { health: 100, isDogfight: false },
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send initial entity states
  socket.emit('entityStates', entities);

  // Update health and dogfight status
  socket.on('updateEntity', (entityName, data) => {
    entities[entityName] = { ...entities[entityName], ...data };
    io.emit('updateEntity', entityName, entities[entityName]); // Broadcast updates
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Receive initial entity states
socket.on('entityStates', (states) => {
  Object.keys(states).forEach((entityName) => {
    const entity = scene.getObjectByName(entityName);
    if (entity) {
      entity.userData.health = states[entityName].health;
      toggleHPBar(entity, states[entityName].isDogfight);
    }
  });
});

// Update entity state and notify the server
function updateEntityState(entity, data) {
  socket.emit('updateEntity', entity.name, data);
}

// Receive updates for entities
socket.on('updateEntity', (entityName, data) => {
  const entity = scene.getObjectByName(entityName);
  if (entity) {
    entity.userData.health = data.health;
    toggleHPBar(entity, data.isDogfight);
    updateHPBar(entity, 0); // Update HP bar without applying damage
  }
});

// Example: Trigger a dogfight and show HP bar
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyF') {
    updateEntityState(enemyPlane, { isDogfight: true });
    console.log('Dogfight initiated!');
  } else if (event.code === 'KeyG') {
    updateEntityState(enemyPlane, { isDogfight: false });
    console.log('Dogfight ended!');
  }
});
function addDamageIndicator(entity) {
  if (entity.userData.health <= 50 && !entity.userData.smoke) {
    const smokeGeometry = new THREE.SphereGeometry(2, 16, 16);
    const smokeMaterial = new THREE.MeshStandardMaterial({
      color: 0x555555,
      transparent: true,
      opacity: 0.5,
    });
    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
    smoke.position.set(0, 10, 0); // Position above the entity
    entity.add(smoke);
    entity.userData.smoke = smoke;

    // Animate smoke
    const smokeInterval = setInterval(() => {
      smoke.scale.multiplyScalar(1.05); // Expand smoke
      smoke.material.opacity -= 0.01; // Fade out
      if (smoke.material.opacity <= 0) {
        entity.remove(smoke);
        clearInterval(smokeInterval);
        entity.userData.smoke = null;
      }
    }, 100);
  }

  if (entity.userData.health <= 20 && !entity.userData.fire) {
    const fireGeometry = new THREE.SphereGeometry(1, 16, 16);
    const fireMaterial = new THREE.MeshStandardMaterial({
      color: 0xff4500,
      emissive: 0xff0000,
      emissiveIntensity: 1,
    });
    const fire = new THREE.Mesh(fireGeometry, fireMaterial);
    fire.position.set(0, 5, 0); // Position above the entity
    entity.add(fire);
    entity.userData.fire = fire;

    // Animate fire
    const fireInterval = setInterval(() => {
      fire.scale.multiplyScalar(1.02); // Expand fire
      if (entity.userData.health > 20) {
        entity.remove(fire);
        clearInterval(fireInterval);
        entity.userData.fire = null;
      }
    }, 100);
  }
}

// Example: Apply damage and trigger damage indicators
function applyDamage(entity, damage) {
  entity.userData.health -= damage;
  updateHPBar(entity, 0); // Update HP bar
  addDamageIndicator(entity); // Add smoke or fire if health is low
}
function animate() {
  requestAnimationFrame(animate);

  // Detect incoming torpedoes
  torpedoes.forEach((torpedo) => detectIncomingTorpedo(torpedo, player.position));

  // Update damage indicators
  [yamato, enemyPlane].forEach((entity) => {
    if (entity.userData.health <= 50) {
      addDamageIndicator(entity);
    }
  });

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const dopplerSounds = {
  cannonFire: new Audio('sounds/cannon-fire.mp3'),
  torpedoWarning: new Audio('sounds/torpedo-warning.mp3'),
};

function playDopplerSound(sound, sourcePosition, listenerPosition, sourceVelocity) {
  if (dopplerSounds[sound]) {
    const distance = sourcePosition.distanceTo(listenerPosition);
    const maxDistance = 500; // Maximum distance for sound to be audible
    const volume = Math.max(0, 1 - distance / maxDistance); // Adjust volume based on distance
    dopplerSounds[sound].volume = volume;

    // Calculate Doppler shift
    const relativeVelocity = sourceVelocity.clone().sub(camera.position.clone().sub(listenerPosition));
    const dopplerFactor = relativeVelocity.length() / 343; // Speed of sound in air (343 m/s)
    dopplerSounds[sound].playbackRate = Math.max(0.5, Math.min(2, 1 + dopplerFactor)); // Clamp playback rate

    dopplerSounds[sound].currentTime = 0; // Reset sound
    dopplerSounds[sound].play();
  }
}

// Example: Play Doppler effect for cannon fire
function handleCannonFire(turret) {
  playDopplerSound('cannonFire', turret.position, camera.position, new THREE.Vector3(0, 0, -2));
  console.log('Cannon fired!');
}

// Example: Play Doppler effect for torpedo warning
function handleTorpedoWarning(torpedo) {
  playDopplerSound('torpedoWarning', torpedo.position, camera.position, torpedo.userData.velocity);
  console.log('Torpedo incoming!');
}
const io = require('socket.io')(3000);

const torpedoes = [];
const damageIndicators = [];

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast torpedo warnings
  socket.on('torpedoWarning', (data) => {
    torpedoes.push(data);
    socket.broadcast.emit('torpedoWarning', data); // Notify all other players
  });

  // Broadcast damage indicators
  socket.on('damageIndicator', (data) => {
    damageIndicators.push(data);
    socket.broadcast.emit('damageIndicator', data); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Notify server of torpedo warning
function notifyTorpedoWarning(torpedo) {
  socket.emit('torpedoWarning', { position: torpedo.position });
}

// Receive torpedo warnings from other players
socket.on('torpedoWarning', (data) => {
  handleTorpedoWarning(data);
  addTorpedoIndicator(data.position); // Add red torpedo indicator
});

// Notify server of damage indicator
function notifyDamageIndicator(entity) {
  socket.emit('damageIndicator', { entityName: entity.name, position: entity.position });
}

// Receive damage indicators from other players
socket.on('damageIndicator', (data) => {
  addDebrisEffect(data.position); // Add debris effect
});
function addDebrisEffect(position) {
  for (let i = 0; i < 10; i++) {
    const debrisGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const debrisMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
    debris.position.copy(position);
    debris.userData.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 2,
      Math.random() * 2,
      (Math.random() - 0.5) * 2
    );
    scene.add(debris);

    // Animate debris
    const debrisInterval = setInterval(() => {
      debris.position.add(debris.userData.velocity);
      debris.userData.velocity.multiplyScalar(0.98); // Apply drag
      debris.position.y -= 0.1; // Simulate gravity
      if (debris.position.y < -10) {
        scene.remove(debris);
        clearInterval(debrisInterval);
      }
    }, 16);
  }
}

// Example: Trigger debris effect when an entity is destroyed
function destroyEntity(entity) {
  console.log(`${entity.name} has been destroyed!`);
  addDebrisEffect(entity.position);
  scene.remove(entity);
}
function addTorpedoIndicator(position) {
  const indicatorGeometry = new THREE.SphereGeometry(1, 16, 16);
  const indicatorMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
  indicator.position.copy(position);
  scene.add(indicator);

  // Animate indicator
  const indicatorInterval = setInterval(() => {
    indicator.scale.multiplyScalar(1.05); // Expand indicator
    indicator.material.opacity -= 0.05; // Fade out
    if (indicator.material.opacity <= 0) {
      scene.remove(indicator);
      clearInterval(indicatorInterval);
    }
  }, 100);
}

// Example: Trigger torpedo indicator
function detectIncomingTorpedo(torpedo, playerPosition) {
  const distance = torpedo.position.distanceTo(playerPosition);
  if (distance < 100) {
    addTorpedoIndicator(torpedo.position);
    handleTorpedoWarning(torpedo);
  }
}
function animate() {
  requestAnimationFrame(animate);

  // Detect incoming torpedoes
  torpedoes.forEach((torpedo) => detectIncomingTorpedo(torpedo, player.position));

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const commanderVoices = {
  german: {
    voiceLines: [
      { text: "Feindliches Schiff gesichtet!", audio: new Audio('sounds/german_enemy_spotted.mp3') },
      { text: "Torpedo abgefeuert!", audio: new Audio('sounds/german_torpedo_fired.mp3') },
      { text: "Wir nehmen Schaden!", audio: new Audio('sounds/german_taking_damage.mp3') },
    ],
  },
  english: {
    voiceLines: [
      { text: "Enemy ship spotted!", audio: new Audio('sounds/english_enemy_spotted.mp3') },
      { text: "Torpedo launched!", audio: new Audio('sounds/english_torpedo_fired.mp3') },
      { text: "We're taking damage!", audio: new Audio('sounds/english_taking_damage.mp3') },
    ],
  },
  japanese: {
    voiceLines: [
      { text: "敵艦を発見しました！", audio: new Audio('sounds/japanese_enemy_spotted.mp3') },
      { text: "魚雷を発射しました！", audio: new Audio('sounds/japanese_torpedo_fired.mp3') },
      { text: "損傷を受けています！", audio: new Audio('sounds/japanese_taking_damage.mp3') },
    ],
  },
};

function playCommanderVoice(ship, event) {
  const country = ship.userData.country; // e.g., 'german', 'english', 'japanese'
  const voiceLines = commanderVoices[country]?.voiceLines;

  if (voiceLines) {
    let voiceLine;
    switch (event) {
      case 'enemySpotted':
        voiceLine = voiceLines[0];
        break;
      case 'torpedoFired':
        voiceLine = voiceLines[1];
        break;
      case 'takingDamage':
        voiceLine = voiceLines[2];
        break;
    }

    if (voiceLine) {
      voiceLine.audio.currentTime = 0; // Reset audio
      voiceLine.audio.play();
      if (captionsEnabled) {
        showCaption(voiceLine.text);
      }
    }
  }
}
let captionsEnabled = false; // Default: captions off

// Toggle captions
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') { // Press 'C' to toggle captions
    captionsEnabled = !captionsEnabled;
    console.log(`Captions ${captionsEnabled ? 'enabled' : 'disabled'}`);
  }
});

// Display captions
function showCaption(text) {
  const captionElement = document.getElementById('captions');
  captionElement.innerText = text;
  captionElement.style.display = 'block';

  // Hide caption after 3 seconds
  setTimeout(() => {
    captionElement.style.display = 'none';
  }, 3000);
}

// Add a caption element to the UI
const captionElement = document.createElement('div');
captionElement.id = 'captions';
captionElement.style.position = 'absolute';
captionElement.style.bottom = '10px';
captionElement.style.left = '50%';
captionElement.style.transform = 'translateX(-50%)';
captionElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
captionElement.style.color = 'white';
captionElement.style.padding = '10px';
captionElement.style.borderRadius = '5px';
captionElement.style.display = 'none';
document.body.appendChild(captionElement);
// Example: Trigger commander voice lines
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyS') { // Enemy spotted
    playCommanderVoice(yamato, 'enemySpotted');
  } else if (event.code === 'KeyT') { // Torpedo fired
    playCommanderVoice(yamato, 'torpedoFired');
  } else if (event.code === 'KeyD') { // Taking damage
    playCommanderVoice(yamato, 'takingDamage');
  }
});

// Assign countries to ships
yamato.userData.country = 'japanese';
iowa.userData.country = 'english';
dreadnought.userData.country = 'german';
function animate() {
  requestAnimationFrame(animate);

  // Example: Trigger voice lines based on game events
  if (Math.random() < 0.01) {
    playCommanderVoice(yamato, 'enemySpotted');
  }

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const commanderVoices = {
  german: {
    voiceLines: [
      { text: "Feindliches Schiff gesichtet!", audio: new Audio('sounds/german_enemy_spotted.mp3') },
      { text: "Torpedo abgefeuert!", audio: new Audio('sounds/german_torpedo_fired.mp3') },
      { text: "Wir nehmen Schaden!", audio: new Audio('sounds/german_taking_damage.mp3') },
    ],
  },
  english: {
    voiceLines: [
      { text: "Enemy ship spotted!", audio: new Audio('sounds/english_enemy_spotted.mp3') },
      { text: "Torpedo launched!", audio: new Audio('sounds/english_torpedo_fired.mp3') },
      { text: "We're taking damage!", audio: new Audio('sounds/english_taking_damage.mp3') },
    ],
  },
  japanese: {
    voiceLines: [
      { text: "敵艦を発見しました！", audio: new Audio('sounds/japanese_enemy_spotted.mp3') },
      { text: "魚雷を発射しました！", audio: new Audio('sounds/japanese_torpedo_fired.mp3') },
      { text: "損傷を受けています！", audio: new Audio('sounds/japanese_taking_damage.mp3') },
    ],
  },
  french: {
    voiceLines: [
      { text: "Navire ennemi repéré!", audio: new Audio('sounds/french_enemy_spotted.mp3') },
      { text: "Torpille lancée!", audio: new Audio('sounds/french_torpedo_fired.mp3') },
      { text: "Nous subissons des dégâts!", audio: new Audio('sounds/french_taking_damage.mp3') },
    ],
  },
  russian: {
    voiceLines: [
      { text: "Обнаружен вражеский корабль!", audio: new Audio('sounds/russian_enemy_spotted.mp3') },
      { text: "Торпеда выпущена!", audio: new Audio('sounds/russian_torpedo_fired.mp3') },
      { text: "Мы получаем урон!", audio: new Audio('sounds/russian_taking_damage.mp3') },
    ],
  },
};
function playCommanderVoice(ship, event) {
  const country = ship.userData.country; // e.g., 'german', 'english', 'japanese', etc.
  const voiceLines = commanderVoices[country]?.voiceLines;

  if (voiceLines) {
    let voiceLine;
    switch (event) {
      case 'enemySpotted':
        voiceLine = voiceLines[0];
        break;
      case 'torpedoFired':
        voiceLine = voiceLines[1];
        break;
      case 'takingDamage':
        voiceLine = voiceLines[2];
        break;
      case 'victory':
        voiceLine = { text: "Victory achieved!", audio: new Audio('sounds/victory.mp3') }; // Example
        break;
    }

    if (voiceLine) {
      voiceLine.audio.currentTime = 0; // Reset audio
      voiceLine.audio.play();
      if (captionsEnabled) {
        showCaption(voiceLine.text);
      }
    }
  }
}

// Example: Trigger voice lines dynamically
function handleGameEvents(ship) {
  if (Math.random() < 0.01) {
    playCommanderVoice(ship, 'enemySpotted');
  }

  if (ship.userData.health < 50 && Math.random() < 0.01) {
    playCommanderVoice(ship, 'takingDamage');
  }

  if (ship.userData.health <= 0) {
    playCommanderVoice(ship, 'victory');
  }
}
function animate() {
  requestAnimationFrame(animate);

  // Trigger dynamic voice lines based on game events
  [yamato, iowa, dreadnought].forEach((ship) => {
    handleGameEvents(ship);
  });

  // Render the scene
  renderer.render(scene, camera);
}

animate();
function handleGameEnd(isVictory) {
  const voiceLine = isVictory
    ? { text: "Victory achieved!", audio: new Audio('sounds/victory.mp3') }
    : { text: "We have been defeated!", audio: new Audio('sounds/defeat.mp3') };

  voiceLine.audio.currentTime = 0;
  voiceLine.audio.play();
  if (captionsEnabled) {
    showCaption(voiceLine.text);
  }
}

// Example: Trigger victory or defeat
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyV') {
    handleGameEnd(true); // Victory
  } else if (event.code === 'KeyL') {
    handleGameEnd(false); // Defeat
  }
});
let captionsEnabled = false; // Default: captions off

// Toggle captions
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') { // Press 'C' to toggle captions
    captionsEnabled = !captionsEnabled;
    console.log(`Captions ${captionsEnabled ? 'enabled' : 'disabled'}`);
  }
});

// Display captions
function showCaption(text) {
  const captionElement = document.getElementById('captions');
  captionElement.innerText = text;
  captionElement.style.display = 'block';

  // Hide caption after 3 seconds
  setTimeout(() => {
    captionElement.style.display = 'none';
  }, 3000);
}

// Add a caption element to the UI
const captionElement = document.createElement('div');
captionElement.id = 'captions';
captionElement.style.position = 'absolute';
captionElement.style.bottom = '10px';
captionElement.style.left = '50%';
captionElement.style.transform = 'translateX(-50%)';
captionElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
captionElement.style.color = 'white';
captionElement.style.padding = '10px';
captionElement.style.borderRadius = '5px';
captionElement.style.display = 'none';
document.body.appendChild(captionElement);
const io = require('socket.io')(3000);

const voiceEvents = [];

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Broadcast voice line events
  socket.on('playVoiceLine', (data) => {
    voiceEvents.push(data);
    socket.broadcast.emit('playVoiceLine', data); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Notify server to play a voice line
function notifyVoiceLine(ship, event) {
  const country = ship.userData.country;
  const voiceLine = commanderVoices[country]?.voiceLines.find((line) => line.event === event);

  if (voiceLine) {
    const data = {
      shipName: ship.name,
      event,
      text: voiceLine.text,
      country,
    };
    socket.emit('playVoiceLine', data);
    playVoiceLineLocally(data); // Play locally for the triggering player
  }
}

// Play voice line locally
function playVoiceLineLocally(data) {
  const voiceLine = commanderVoices[data.country]?.voiceLines.find((line) => line.event === data.event);
  if (voiceLine) {
    voiceLine.audio.currentTime = 0; // Reset audio
    voiceLine.audio.play();
    if (captionsEnabled) {
      showCaption(voiceLine.text);
    }
  }
}

// Receive voice line events from other players
socket.on('playVoiceLine', (data) => {
  playVoiceLineLocally(data);
});
function handleGameEvents(ship) {
  if (Math.random() < 0.01) {
    notifyVoiceLine(ship, 'enemySpotted');
  }

  if (ship.userData.health < 50 && Math.random() < 0.01) {
    notifyVoiceLine(ship, 'takingDamage');
  }

  if (ship.userData.health <= 0) {
    notifyVoiceLine(ship, 'victory');
  }
}

// Example: Trigger voice lines in the animation loop
function animate() {
  requestAnimationFrame(animate);

  [yamato, iowa, dreadnought].forEach((ship) => {
    handleGameEvents(ship);
  });

  renderer.render(scene, camera);
}

animate();
let captionsEnabled = false; // Default: captions off

// Toggle captions
document.addEventListener('keydown', (event) => {
  if (event.code === 'KeyC') { // Press 'C' to toggle captions
    captionsEnabled = !captionsEnabled;
    console.log(`Captions ${captionsEnabled ? 'enabled' : 'disabled'}`);
  }
});

// Display captions
function showCaption(text) {
  const captionElement = document.getElementById('captions');
  captionElement.innerText = text;
  captionElement.style.display = 'block';

  // Hide caption after 3 seconds
  setTimeout(() => {
    captionElement.style.display = 'none';
  }, 3000);
}

// Add a caption element to the UI
const captionElement = document.createElement('div');
captionElement.id = 'captions';
captionElement.style.position = 'absolute';
captionElement.style.bottom = '10px';
captionElement.style.left = '50%';
captionElement.style.transform = 'translateX(-50%)';
captionElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
captionElement.style.color = 'white';
captionElement.style.padding = '10px';
captionElement.style.borderRadius = '5px';
captionElement.style.display = 'none';
document.body.appendChild(captionElement);
// Assign countries to ships
yamato.userData.country = 'japanese';
iowa.userData.country = 'english';
dreadnought.userData.country = 'german';
function animate() {
  requestAnimationFrame(animate);

  // Trigger dynamic voice lines based on game events
  [yamato, iowa, dreadnought].forEach((ship) => {
    handleGameEvents(ship);
  });

  // Render the scene
  renderer.render(scene, camera);
}

animate();
const soundtrack = {
  rock: [
    { title: "Rock Anthem", audio: new Audio('sounds/rock_anthem.mp3') },
    { title: "Guitar Riff", audio: new Audio('sounds/guitar_riff.mp3') },
  ],
  blues: [
    { title: "Blues Groove", audio: new Audio('sounds/blues_groove.mp3') },
    { title: "Slow Blues", audio: new Audio('sounds/slow_blues.mp3') },
  ],
  nastyBlues: [
    { title: "Dirty Blues", audio: new Audio('sounds/dirty_blues.mp3') },
    { title: "Gritty Blues", audio: new Audio('sounds/gritty_blues.mp3') },
  ],
};

let currentGenre = 'rock'; // Default genre
let currentTrackIndex = 0; // Default track index
let isPlaying = false;

// Play the current track
function playTrack() {
  const track = soundtrack[currentGenre][currentTrackIndex];
  if (track) {
    track.audio.currentTime = 0; // Reset track
    track.audio.play();
    isPlaying = true;
    console.log(`Now playing: ${track.title}`);
  }
}

// Stop the current track
function stopTrack() {
  const track = soundtrack[currentGenre][currentTrackIndex];
  if (track) {
    track.audio.pause();
    track.audio.currentTime = 0; // Reset track
    isPlaying = false;
    console.log(`Stopped: ${track.title}`);
  }
}

// Play the next track
function nextTrack() {
  stopTrack();
  currentTrackIndex = (currentTrackIndex + 1) % soundtrack[currentGenre].length;
  playTrack();
}

// Play the previous track
function previousTrack() {
  stopTrack();
  currentTrackIndex =
    (currentTrackIndex - 1 + soundtrack[currentGenre].length) % soundtrack[currentGenre].length;
  playTrack();
}

// Switch genre
function switchGenre(genre) {
  if (soundtrack[genre]) {
    stopTrack();
    currentGenre = genre;
    currentTrackIndex = 0; // Reset to the first track in the new genre
    console.log(`Switched to ${genre} genre`);
    playTrack();
  } else {
    console.log(`Genre ${genre} not found`);
  }
}
// Add keyboard controls for the playlist
document.addEventListener('keydown', (event) => {
  switch (event.code) {
    case 'KeyP': // Play/Pause
      if (isPlaying) {
        stopTrack();
      } else {
        playTrack();
      }
      break;
    case 'KeyN': // Next track
      nextTrack();
      break;
    case 'KeyB': // Previous track
      previousTrack();
      break;
    case 'KeyR': // Switch to Rock
      switchGenre('rock');
      break;
    case 'KeyL': // Switch to Blues
      switchGenre('blues');
      break;
    case 'KeyM': // Switch to Nasty Blues
      switchGenre('nastyBlues');
      break;
  }
});
function updateTrackInfo() {
  const trackInfoElement = document.getElementById('track-info');
  const track = soundtrack[currentGenre][currentTrackIndex];
  if (track) {
    trackInfoElement.innerText = `Now Playing: ${track.title} (${currentGenre})`;
  }
}

// Update track info when a new track starts
document.addEventListener('keydown', (event) => {
  if (['KeyP', 'KeyN', 'KeyB', 'KeyR', 'KeyL', 'KeyM'].includes(event.code)) {
    updateTrackInfo();
  }
});

// Add a track info element to the UI
const trackInfoElement = document.createElement('div');
trackInfoElement.id = 'track-info';
trackInfoElement.style.position = 'absolute';
trackInfoElement.style.bottom = '10px';
trackInfoElement.style.left = '10px';
trackInfoElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
trackInfoElement.style.color = 'white';
trackInfoElement.style.padding = '10px';
trackInfoElement.style.borderRadius = '5px';
document.body.appendChild(trackInfoElement);

// Initialize track info
updateTrackInfo();
function animate() {
  requestAnimationFrame(animate);

  // Update game logic
  // ...

  // Render the scene
  renderer.render(scene, camera);
}

animate();

// Start the soundtrack when the game starts
playTrack();
let volumeLevel = 0.5; // Default volume level (50%)

// Update volume for all tracks
function updateVolume(level) {
  volumeLevel = Math.max(0, Math.min(1, level)); // Clamp volume between 0 and 1
  Object.values(soundtrack).forEach((genre) => {
    genre.forEach((track) => {
      track.audio.volume = volumeLevel;
    });
  });
  console.log(`Volume set to ${Math.round(volumeLevel * 100)}%`);
}

// Add keyboard controls for volume adjustment
document.addEventListener('keydown', (event) => {
  switch (event.code) {
    case 'ArrowUp': // Increase volume
      updateVolume(volumeLevel + 0.1);
      break;
    case 'ArrowDown': // Decrease volume
      updateVolume(volumeLevel - 0.1);
      break;
  }
});
const io = require('socket.io')(3000);

const soundtrackState = {
  currentGenre: 'rock',
  currentTrackIndex: 0,
  isPlaying: false,
  volumeLevel: 0.5,
};

io.on('connection', (socket) => {
  console.log('Player connected:', socket.id);

  // Send current soundtrack state to the new player
  socket.emit('soundtrackState', soundtrackState);

  // Update soundtrack state
  socket.on('updateSoundtrack', (state) => {
    Object.assign(soundtrackState, state);
    socket.broadcast.emit('soundtrackState', soundtrackState); // Notify all other players
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Player disconnected:', socket.id);
  });
});
// Notify server of soundtrack updates
function updateSoundtrackState(state) {
  socket.emit('updateSoundtrack', state);
}

// Receive soundtrack state updates from the server
socket.on('soundtrackState', (state) => {
  currentGenre = state.currentGenre;
  currentTrackIndex = state.currentTrackIndex;
  volumeLevel = state.volumeLevel;
  isPlaying = state.isPlaying;

  updateVolume(volumeLevel); // Update volume
  if (isPlaying) {
    playTrack(); // Play the current track
  } else {
    stopTrack(); // Stop the current track
  }
});

// Example: Synchronize track changes
function playTrack() {
  const track = soundtrack[currentGenre][currentTrackIndex];
  if (track) {
    track.audio.currentTime = 0; // Reset track
    track.audio.volume = volumeLevel; // Set volume
    track.audio.play();
    isPlaying = true;
    updateSoundtrackState({ currentGenre, currentTrackIndex, isPlaying, volumeLevel });
    console.log(`Now playing: ${track.title}`);
  }
}

function stopTrack() {
  const track = soundtrack[currentGenre][currentTrackIndex];
  if (track) {
    track.audio.pause();
    track.audio.currentTime = 0; // Reset track
    isPlaying = false;
    updateSoundtrackState({ currentGenre, currentTrackIndex, isPlaying, volumeLevel });
    console.log(`Stopped: ${track.title}`);
  }
}

function nextTrack() {
  stopTrack();
  currentTrackIndex = (currentTrackIndex + 1) % soundtrack[currentGenre].length;
  playTrack();
}

function previousTrack() {
  stopTrack();
  currentTrackIndex =
    (currentTrackIndex - 1 + soundtrack[currentGenre].length) % soundtrack[currentGenre].length;
  playTrack();
}
function updateTrackInfo() {
  const trackInfoElement = document.getElementById('track-info');
  const track = soundtrack[currentGenre][currentTrackIndex];
  if (track) {
    trackInfoElement.innerText = `Now Playing: ${track.title} (${currentGenre})`;
  }
}

// Update track info when a new track starts
socket.on('soundtrackState', (state) => {
  updateTrackInfo();
});

// Add a track info element to the UI
const trackInfoElement = document.createElement('div');
trackInfoElement.id = 'track-info';
trackInfoElement.style.position = 'absolute';
trackInfoElement.style.bottom = '10px';
trackInfoElement.style.left = '10px';
trackInfoElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
trackInfoElement.style.color = 'white';
trackInfoElement.style.padding = '10px';
trackInfoElement.style.borderRadius = '5px';
document.body.appendChild(trackInfoElement);

// Initialize track info
updateTrackInfo();
function animate() {
  requestAnimationFrame(animate);

  // Update game logic
  // ...

  // Render the scene
  renderer.render(scene, camera);
}

animate();

// Start the soundtrack when the game starts
playTrack();
let crossfadeDuration = 2; // Crossfade duration in seconds

// Play the current track with crossfade
function playTrackWithCrossfade() {
  const track = soundtrack[currentGenre][currentTrackIndex];
  if (track) {
    track.audio.volume = 0; // Start with volume at 0
    track.audio.currentTime = 0; // Reset track
    track.audio.play();
    isPlaying = true;

    // Gradually increase volume
    const fadeInInterval = setInterval(() => {
      track.audio.volume = Math.min(track.audio.volume + 0.1 / crossfadeDuration, volumeLevel);
      if (track.audio.volume >= volumeLevel) {
        clearInterval(fadeInInterval);
      }
    }, 100);

    console.log(`Now playing: ${track.title}`);
  }
}

// Stop the current track with crossfade
function stopTrackWithCrossfade(callback) {
  const track = soundtrack[currentGenre][currentTrackIndex];
  if (track) {
    // Gradually decrease volume
    const fadeOutInterval = setInterval(() => {
      track.audio.volume = Math.max(track.audio.volume - 0.1 / crossfadeDuration, 0);
      if (track.audio.volume <= 0) {
        clearInterval(fadeOutInterval);
        track.audio.pause();
        track.audio.currentTime = 0; // Reset track
        isPlaying = false;
        console.log(`Stopped: ${track.title}`);
        if (callback) callback(); // Call the callback after fade-out
      }
    }, 100);
  } else if (callback) {
    callback(); // Call the callback immediately if no track is playing
  }
}

// Play the next track with crossfade
function nextTrackWithCrossfade() {
  stopTrackWithCrossfade(() => {
    currentTrackIndex = (currentTrackIndex + 1) % soundtrack[currentGenre].length;
    playTrackWithCrossfade();
  });
}

// Play the previous track with crossfade
function previousTrackWithCrossfade() {
  stopTrackWithCrossfade(() => {
    currentTrackIndex =
      (currentTrackIndex - 1 + soundtrack[currentGenre].length) % soundtrack[currentGenre].length;
    playTrackWithCrossfade();
  });
}

// Switch genre with crossfade
function switchGenreWithCrossfade(genre) {
  if (soundtrack[genre]) {
    stopTrackWithCrossfade(() => {
      currentGenre = genre;
      currentTrackIndex = 0; // Reset to the first track in the new genre
      console.log(`Switched to ${genre} genre`);
      playTrackWithCrossfade();
    });
  } else {
    console.log(`Genre ${genre} not found`);
  }
}
// Add keyboard controls for the playlist with crossfade
document.addEventListener('keydown', (event) => {
  switch (event.code) {
    case 'KeyP': // Play/Pause
      if (isPlaying) {
        stopTrackWithCrossfade();
      } else {
        playTrackWithCrossfade();
      }
      break;
    case 'KeyN': // Next track
      nextTrackWithCrossfade();
      break;
    case 'KeyB': // Previous track
      previousTrackWithCrossfade();
      break;
    case 'KeyR': // Switch to Rock
      switchGenreWithCrossfade('rock');
      break;
    case 'KeyL': // Switch to Blues
      switchGenreWithCrossfade('blues');
      break;
    case 'KeyM': // Switch to Nasty Blues
      switchGenreWithCrossfade('nastyBlues');
      break;
  }
});
function updateTrackInfo() {
  const trackInfoElement = document.getElementById('track-info');
  const track = soundtrack[currentGenre][currentTrackIndex];
  if (track) {
    trackInfoElement.innerText = `Now Playing: ${track.title} (${currentGenre})`;
  }
}

// Update track info when a new track starts
document.addEventListener('keydown', (event) => {
  if (['KeyP', 'KeyN', 'KeyB', 'KeyR', 'KeyL', 'KeyM'].includes(event.code)) {
    updateTrackInfo();
  }
});

// Add a track info element to the UI
const trackInfoElement = document.createElement('div');
trackInfoElement.id = 'track-info';
trackInfoElement.style.position = 'absolute';
trackInfoElement.style.bottom = '10px';
trackInfoElement.style.left = '10px';
trackInfoElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
trackInfoElement.style.color = 'white';
trackInfoElement.style.padding = '10px';
trackInfoElement.style.borderRadius = '5px';
document.body.appendChild(trackInfoElement);

// Initialize track info
updateTrackInfo();
function animate() {
  requestAnimationFrame(animate);

  // Update game logic
  // ...

  // Render the scene
  renderer.render(scene, camera);
}

animate();

// Start the soundtrack with crossfade when the game starts
playTrackWithCrossfade();

